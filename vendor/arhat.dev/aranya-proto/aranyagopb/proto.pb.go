// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto.proto

package aranyagopb

import (
	bytes "bytes"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CmdType int32

const (
	// 0-4: raw data related cmd
	// to reduce overhead, we also use this identifier to send data targeting the runtime
	// extension connected
	//
	// the agent should cache all non-terminated session ids
	// if the session id doesn't exist, send data to the runtime
	// if there is not runtime connected, discard data
	CMD_DATA_UPSTREAM CmdType = 0
	CMD_SESSION_CLOSE CmdType = 5
	CMD_REJECT        CmdType = 6
	// network operations, protobuf bytes of abbot proto
	CMD_NET CmdType = 9
	// runtime operations, protobuf bytes of runtime.Packet
	CMD_RUNTIME CmdType = 10
	// 11-19: node operations
	CMD_NODE_INFO_GET CmdType = 11
	CMD_EXEC          CmdType = 12
	CMD_ATTACH        CmdType = 13
	CMD_LOGS          CmdType = 14
	CMD_TTY_RESIZE    CmdType = 15
	CMD_PORT_FORWARD  CmdType = 16
	// 21-29: metrics operations
	CMD_METRICS_CONFIG  CmdType = 21
	CMD_METRICS_COLLECT CmdType = 22
	// 31-39: credentials operations
	CMD_CRED_ENSURE CmdType = 31
	// 51-59: storage operations (remote csi)
	CMD_STORAGE_LIST   CmdType = 41
	CMD_STORAGE_ENSURE CmdType = 42
	CMD_STORAGE_DELETE CmdType = 43
	// 71-79: peripheral operations
	CMD_PERIPHERAL_LIST            CmdType = 51
	CMD_PERIPHERAL_ENSURE          CmdType = 52
	CMD_PERIPHERAL_DELETE          CmdType = 53
	CMD_PERIPHERAL_OPERATE         CmdType = 54
	CMD_PERIPHERAL_COLLECT_METRICS CmdType = 55
)

var CmdType_name = map[int32]string{
	0:  "CMD_DATA_UPSTREAM",
	5:  "CMD_SESSION_CLOSE",
	6:  "CMD_REJECT",
	9:  "CMD_NET",
	10: "CMD_RUNTIME",
	11: "CMD_NODE_INFO_GET",
	12: "CMD_EXEC",
	13: "CMD_ATTACH",
	14: "CMD_LOGS",
	15: "CMD_TTY_RESIZE",
	16: "CMD_PORT_FORWARD",
	21: "CMD_METRICS_CONFIG",
	22: "CMD_METRICS_COLLECT",
	31: "CMD_CRED_ENSURE",
	41: "CMD_STORAGE_LIST",
	42: "CMD_STORAGE_ENSURE",
	43: "CMD_STORAGE_DELETE",
	51: "CMD_PERIPHERAL_LIST",
	52: "CMD_PERIPHERAL_ENSURE",
	53: "CMD_PERIPHERAL_DELETE",
	54: "CMD_PERIPHERAL_OPERATE",
	55: "CMD_PERIPHERAL_COLLECT_METRICS",
}

var CmdType_value = map[string]int32{
	"CMD_DATA_UPSTREAM":              0,
	"CMD_SESSION_CLOSE":              5,
	"CMD_REJECT":                     6,
	"CMD_NET":                        9,
	"CMD_RUNTIME":                    10,
	"CMD_NODE_INFO_GET":              11,
	"CMD_EXEC":                       12,
	"CMD_ATTACH":                     13,
	"CMD_LOGS":                       14,
	"CMD_TTY_RESIZE":                 15,
	"CMD_PORT_FORWARD":               16,
	"CMD_METRICS_CONFIG":             21,
	"CMD_METRICS_COLLECT":            22,
	"CMD_CRED_ENSURE":                31,
	"CMD_STORAGE_LIST":               41,
	"CMD_STORAGE_ENSURE":             42,
	"CMD_STORAGE_DELETE":             43,
	"CMD_PERIPHERAL_LIST":            51,
	"CMD_PERIPHERAL_ENSURE":          52,
	"CMD_PERIPHERAL_DELETE":          53,
	"CMD_PERIPHERAL_OPERATE":         54,
	"CMD_PERIPHERAL_COLLECT_METRICS": 55,
}

func (CmdType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{0}
}

type MsgType int32

const (
	MSG_DATA         MsgType = 0
	MSG_DATA_DEFAULT MsgType = 0
	MSG_DATA_STDOUT  MsgType = 0
	MSG_DATA_METRICS MsgType = 0
	// special message to allow data streaming, aranya can only send data after
	// receiving this message (empty data)
	MSG_STREAM_CONTINUE MsgType = 0
	MSG_DATA_STDERR     MsgType = 1
	MSG_DONE            MsgType = 5
	MSG_STATE           MsgType = 6
	MSG_ERROR           MsgType = 7
	// network msgs, protobuf bytes of abbot proto
	MSG_NET MsgType = 9
	// runtime messages, protobuf bytes of runtime.Packet
	MSG_RUNTIME MsgType = 10
	// 11-19: node msgs
	MSG_NODE_STATUS MsgType = 11
	// 31-39: credential msgs
	MSG_CRED_STATUS MsgType = 31
	// 51-59: storage msgs
	MSG_STORAGE_STATUS      MsgType = 41
	MSG_STORAGE_STATUS_LIST MsgType = 42
	// 71-79: peripheral msgs
	MSG_PERIPHERAL_STATUS           MsgType = 51
	MSG_PERIPHERAL_STATUS_LIST      MsgType = 52
	MSG_PERIPHERAL_OPERATION_RESULT MsgType = 53
)

var MsgType_name = map[int32]string{
	0: "MSG_DATA",
	// Duplicate value: 0: "MSG_DATA_DEFAULT",
	// Duplicate value: 0: "MSG_DATA_STDOUT",
	// Duplicate value: 0: "MSG_DATA_METRICS",
	// Duplicate value: 0: "MSG_STREAM_CONTINUE",
	1:  "MSG_DATA_STDERR",
	5:  "MSG_DONE",
	6:  "MSG_STATE",
	7:  "MSG_ERROR",
	9:  "MSG_NET",
	10: "MSG_RUNTIME",
	11: "MSG_NODE_STATUS",
	31: "MSG_CRED_STATUS",
	41: "MSG_STORAGE_STATUS",
	42: "MSG_STORAGE_STATUS_LIST",
	51: "MSG_PERIPHERAL_STATUS",
	52: "MSG_PERIPHERAL_STATUS_LIST",
	53: "MSG_PERIPHERAL_OPERATION_RESULT",
}

var MsgType_value = map[string]int32{
	"MSG_DATA":                        0,
	"MSG_DATA_DEFAULT":                0,
	"MSG_DATA_STDOUT":                 0,
	"MSG_DATA_METRICS":                0,
	"MSG_STREAM_CONTINUE":             0,
	"MSG_DATA_STDERR":                 1,
	"MSG_DONE":                        5,
	"MSG_STATE":                       6,
	"MSG_ERROR":                       7,
	"MSG_NET":                         9,
	"MSG_RUNTIME":                     10,
	"MSG_NODE_STATUS":                 11,
	"MSG_CRED_STATUS":                 31,
	"MSG_STORAGE_STATUS":              41,
	"MSG_STORAGE_STATUS_LIST":         42,
	"MSG_PERIPHERAL_STATUS":           51,
	"MSG_PERIPHERAL_STATUS_LIST":      52,
	"MSG_PERIPHERAL_OPERATION_RESULT": 53,
}

func (MsgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{1}
}

type RejectionReason int32

const (
	_INVALID_REJECTION_REASON       RejectionReason = 0
	REJECTION_INVALID_PROTO         RejectionReason = 1
	REJECTION_ALREADY_CONNECTED     RejectionReason = 2
	REJECTION_INITIAL_CHECK_FAILURE RejectionReason = 3
	REJECTION_INTERNAL_SERVER_ERROR RejectionReason = 4
)

var RejectionReason_name = map[int32]string{
	0: "_INVALID_REJECTION_REASON",
	1: "REJECTION_INVALID_PROTO",
	2: "REJECTION_ALREADY_CONNECTED",
	3: "REJECTION_INITIAL_CHECK_FAILURE",
	4: "REJECTION_INTERNAL_SERVER_ERROR",
}

var RejectionReason_value = map[string]int32{
	"_INVALID_REJECTION_REASON":       0,
	"REJECTION_INVALID_PROTO":         1,
	"REJECTION_ALREADY_CONNECTED":     2,
	"REJECTION_INITIAL_CHECK_FAILURE": 3,
	"REJECTION_INTERNAL_SERVER_ERROR": 4,
}

func (RejectionReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{2}
}

type NodeCondition int32

const (
	NODE_CONDITION_UNKNOWN   NodeCondition = 0
	NODE_CONDITION_HEALTHY   NodeCondition = 1
	NODE_CONDITION_UNHEALTHY NodeCondition = 2
)

var NodeCondition_name = map[int32]string{
	0: "NODE_CONDITION_UNKNOWN",
	1: "NODE_CONDITION_HEALTHY",
	2: "NODE_CONDITION_UNHEALTHY",
}

var NodeCondition_value = map[string]int32{
	"NODE_CONDITION_UNKNOWN":   0,
	"NODE_CONDITION_HEALTHY":   1,
	"NODE_CONDITION_UNHEALTHY": 2,
}

func (NodeCondition) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{3}
}

type StorageState int32

const (
	STORAGE_STATE_UNKONW    StorageState = 0
	STORAGE_STATE_UNMOUNTED StorageState = 1
	STORAGE_STATE_MOUNTED   StorageState = 2
)

var StorageState_name = map[int32]string{
	0: "STORAGE_STATE_UNKONW",
	1: "STORAGE_STATE_UNMOUNTED",
	2: "STORAGE_STATE_MOUNTED",
}

var StorageState_value = map[string]int32{
	"STORAGE_STATE_UNKONW":    0,
	"STORAGE_STATE_UNMOUNTED": 1,
	"STORAGE_STATE_MOUNTED":   2,
}

func (StorageState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{4}
}

type NodeInfoGetCmd_Kind int32

const (
	// Get dynamic node information only
	// including node conditions and resources
	// not including node system info and node ext info
	NODE_INFO_DYN NodeInfoGetCmd_Kind = 0
	NODE_INFO_ALL NodeInfoGetCmd_Kind = 1
)

var NodeInfoGetCmd_Kind_name = map[int32]string{
	0: "NODE_INFO_DYN",
	1: "NODE_INFO_ALL",
}

var NodeInfoGetCmd_Kind_value = map[string]int32{
	"NODE_INFO_DYN": 0,
	"NODE_INFO_ALL": 1,
}

func (NodeInfoGetCmd_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{2, 0}
}

type ErrorMsg_Kind int32

const (
	// ERR_COMMON means Error happened, but we don't know what to do,
	// report as failure and retry later.
	ERR_COMMON ErrorMsg_Kind = 0
	// ERR_NOT_FOUND means something not found but may be expected by
	// the scheduler, aranya should schedule according task or ignore.
	ERR_NOT_FOUND ErrorMsg_Kind = 1
	// ERR_ALREADY_EXISTS means something expected by the scheduler already
	// exists in agent, agent only report this error when it's sure the
	// existing object is the same with the one expected by the scheduler,
	// otherwise it should report ERR_NOT_FOUND.
	ERR_ALREADY_EXISTS ErrorMsg_Kind = 2
	// ERR_NOT_SUPPORTED means Cmd not supported by the agent,
	// aranya should ignore this error and cancel all future
	// job.
	ERR_NOT_SUPPORTED ErrorMsg_Kind = 3
	// ERR_TIMEOUT only happens in connectivity server,
	// right after the session is timed out
	ERR_TIMEOUT ErrorMsg_Kind = 4
)

var ErrorMsg_Kind_name = map[int32]string{
	0: "ERR_COMMON",
	1: "ERR_NOT_FOUND",
	2: "ERR_ALREADY_EXISTS",
	3: "ERR_NOT_SUPPORTED",
	4: "ERR_TIMEOUT",
}

var ErrorMsg_Kind_value = map[string]int32{
	"ERR_COMMON":         0,
	"ERR_NOT_FOUND":      1,
	"ERR_ALREADY_EXISTS": 2,
	"ERR_NOT_SUPPORTED":  3,
	"ERR_TIMEOUT":        4,
}

func (ErrorMsg_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{11, 0}
}

type StateMsg_Kind int32

const (
	_INVALID_STATE StateMsg_Kind = 0
	STATE_ONLINE   StateMsg_Kind = 1
	STATE_OFFLINE  StateMsg_Kind = 2
)

var StateMsg_Kind_name = map[int32]string{
	0: "_INVALID_STATE",
	1: "STATE_ONLINE",
	2: "STATE_OFFLINE",
}

var StateMsg_Kind_value = map[string]int32{
	"_INVALID_STATE": 0,
	"STATE_ONLINE":   1,
	"STATE_OFFLINE":  2,
}

func (StateMsg_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{12, 0}
}

type NodeExtInfo_ValueType int32

const (
	NODE_EXT_INFO_TYPE_STRING  NodeExtInfo_ValueType = 0
	NODE_EXT_INFO_TYPE_INTEGER NodeExtInfo_ValueType = 1
	NODE_EXT_INFO_TYPE_FLOAT   NodeExtInfo_ValueType = 2
)

var NodeExtInfo_ValueType_name = map[int32]string{
	0: "NODE_EXT_INFO_TYPE_STRING",
	1: "NODE_EXT_INFO_TYPE_INTEGER",
	2: "NODE_EXT_INFO_TYPE_FLOAT",
}

var NodeExtInfo_ValueType_value = map[string]int32{
	"NODE_EXT_INFO_TYPE_STRING":  0,
	"NODE_EXT_INFO_TYPE_INTEGER": 1,
	"NODE_EXT_INFO_TYPE_FLOAT":   2,
}

func (NodeExtInfo_ValueType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{17, 0}
}

type NodeExtInfo_Operator int32

const (
	// no matter what previous value is, set to new value
	NODE_EXT_INFO_OPERATOR_SET NodeExtInfo_Operator = 0
	// only valid for {integer, float}
	NODE_EXT_INFO_OPERATOR_ADD NodeExtInfo_Operator = 1
	// only valid for {integer, float}
	NODE_EXT_INFO_OPERATOR_MINUS NodeExtInfo_Operator = 2
)

var NodeExtInfo_Operator_name = map[int32]string{
	0: "NODE_EXT_INFO_OPERATOR_SET",
	1: "NODE_EXT_INFO_OPERATOR_ADD",
	2: "NODE_EXT_INFO_OPERATOR_MINUS",
}

var NodeExtInfo_Operator_value = map[string]int32{
	"NODE_EXT_INFO_OPERATOR_SET":   0,
	"NODE_EXT_INFO_OPERATOR_ADD":   1,
	"NODE_EXT_INFO_OPERATOR_MINUS": 2,
}

func (NodeExtInfo_Operator) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{17, 1}
}

type NodeExtInfo_Target int32

const (
	NODE_EXT_INFO_TARGET_ANNOTATION NodeExtInfo_Target = 0
	NODE_EXT_INFO_TARGET_LABEL      NodeExtInfo_Target = 1
)

var NodeExtInfo_Target_name = map[int32]string{
	0: "NODE_EXT_INFO_TARGET_ANNOTATION",
	1: "NODE_EXT_INFO_TARGET_LABEL",
}

var NodeExtInfo_Target_value = map[string]int32{
	"NODE_EXT_INFO_TARGET_ANNOTATION": 0,
	"NODE_EXT_INFO_TARGET_LABEL":      1,
}

func (NodeExtInfo_Target) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{17, 2}
}

type Cmd struct {
	Kind CmdType `protobuf:"varint,1,opt,name=kind,proto3,enum=aranya.CmdType" json:"kind,omitempty"`
	// session id
	Sid uint64 `protobuf:"varint,2,opt,name=sid,proto3" json:"sid,omitempty"`
	// sequence in the session, to ensure ordered data
	Seq uint64 `protobuf:"varint,3,opt,name=seq,proto3" json:"seq,omitempty"`
	// mark this Cmd is the last piece in the session
	Completed bool `protobuf:"varint,4,opt,name=completed,proto3" json:"completed,omitempty"`
	// payload of encoded XxxCmd or raw data bytes
	//
	// payload can be nil if kind has clear indication of what operation to do
	Payload []byte `protobuf:"bytes,11,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Cmd) Reset()      { *m = Cmd{} }
func (*Cmd) ProtoMessage() {}
func (*Cmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{0}
}
func (m *Cmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cmd.Merge(m, src)
}
func (m *Cmd) XXX_Size() int {
	return m.Size()
}
func (m *Cmd) XXX_DiscardUnknown() {
	xxx_messageInfo_Cmd.DiscardUnknown(m)
}

var xxx_messageInfo_Cmd proto.InternalMessageInfo

func (m *Cmd) GetKind() CmdType {
	if m != nil {
		return m.Kind
	}
	return CMD_DATA_UPSTREAM
}

func (m *Cmd) GetSid() uint64 {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *Cmd) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *Cmd) GetCompleted() bool {
	if m != nil {
		return m.Completed
	}
	return false
}

func (m *Cmd) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type Msg struct {
	Kind MsgType `protobuf:"varint,1,opt,name=kind,proto3,enum=aranya.MsgType" json:"kind,omitempty"`
	// session id
	Sid uint64 `protobuf:"varint,2,opt,name=sid,proto3" json:"sid,omitempty"`
	// sequence in the session, to ensure ordered data
	Seq uint64 `protobuf:"varint,3,opt,name=seq,proto3" json:"seq,omitempty"`
	// mark this Msg is the last piece in the session
	Completed bool `protobuf:"varint,4,opt,name=completed,proto3" json:"completed,omitempty"`
	// payload of encoded XxxMsg or raw data bytes
	//
	// payload can be nil if kind is clearly defined
	Payload []byte `protobuf:"bytes,11,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Msg) Reset()      { *m = Msg{} }
func (*Msg) ProtoMessage() {}
func (*Msg) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{1}
}
func (m *Msg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Msg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Msg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Msg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Msg.Merge(m, src)
}
func (m *Msg) XXX_Size() int {
	return m.Size()
}
func (m *Msg) XXX_DiscardUnknown() {
	xxx_messageInfo_Msg.DiscardUnknown(m)
}

var xxx_messageInfo_Msg proto.InternalMessageInfo

func (m *Msg) GetKind() MsgType {
	if m != nil {
		return m.Kind
	}
	return MSG_DATA
}

func (m *Msg) GetSid() uint64 {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *Msg) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *Msg) GetCompleted() bool {
	if m != nil {
		return m.Completed
	}
	return false
}

func (m *Msg) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type NodeInfoGetCmd struct {
	Kind NodeInfoGetCmd_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=aranya.NodeInfoGetCmd_Kind" json:"kind,omitempty"`
}

func (m *NodeInfoGetCmd) Reset()      { *m = NodeInfoGetCmd{} }
func (*NodeInfoGetCmd) ProtoMessage() {}
func (*NodeInfoGetCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{2}
}
func (m *NodeInfoGetCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfoGetCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfoGetCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfoGetCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfoGetCmd.Merge(m, src)
}
func (m *NodeInfoGetCmd) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfoGetCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfoGetCmd.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfoGetCmd proto.InternalMessageInfo

func (m *NodeInfoGetCmd) GetKind() NodeInfoGetCmd_Kind {
	if m != nil {
		return m.Kind
	}
	return NODE_INFO_DYN
}

type SessionCloseCmd struct {
	// session id to be closed
	Sid uint64 `protobuf:"varint,1,opt,name=sid,proto3" json:"sid,omitempty"`
}

func (m *SessionCloseCmd) Reset()      { *m = SessionCloseCmd{} }
func (*SessionCloseCmd) ProtoMessage() {}
func (*SessionCloseCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{3}
}
func (m *SessionCloseCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionCloseCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionCloseCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionCloseCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionCloseCmd.Merge(m, src)
}
func (m *SessionCloseCmd) XXX_Size() int {
	return m.Size()
}
func (m *SessionCloseCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionCloseCmd.DiscardUnknown(m)
}

var xxx_messageInfo_SessionCloseCmd proto.InternalMessageInfo

func (m *SessionCloseCmd) GetSid() uint64 {
	if m != nil {
		return m.Sid
	}
	return 0
}

type RejectCmd struct {
	Reason  RejectionReason `protobuf:"varint,1,opt,name=reason,proto3,enum=aranya.RejectionReason" json:"reason,omitempty"`
	Message string          `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *RejectCmd) Reset()      { *m = RejectCmd{} }
func (*RejectCmd) ProtoMessage() {}
func (*RejectCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{4}
}
func (m *RejectCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RejectCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RejectCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RejectCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RejectCmd.Merge(m, src)
}
func (m *RejectCmd) XXX_Size() int {
	return m.Size()
}
func (m *RejectCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_RejectCmd.DiscardUnknown(m)
}

var xxx_messageInfo_RejectCmd proto.InternalMessageInfo

func (m *RejectCmd) GetReason() RejectionReason {
	if m != nil {
		return m.Reason
	}
	return _INVALID_REJECTION_REASON
}

func (m *RejectCmd) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type NetworkCmd struct {
	// protobuf bytes of abbot proto
	AbbotRequestBytes []byte `protobuf:"bytes,1,opt,name=abbot_request_bytes,json=abbotRequestBytes,proto3" json:"abbot_request_bytes,omitempty"`
}

func (m *NetworkCmd) Reset()      { *m = NetworkCmd{} }
func (*NetworkCmd) ProtoMessage() {}
func (*NetworkCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{5}
}
func (m *NetworkCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkCmd.Merge(m, src)
}
func (m *NetworkCmd) XXX_Size() int {
	return m.Size()
}
func (m *NetworkCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkCmd.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkCmd proto.InternalMessageInfo

func (m *NetworkCmd) GetAbbotRequestBytes() []byte {
	if m != nil {
		return m.AbbotRequestBytes
	}
	return nil
}

type LogsCmd struct {
	PodUid     string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	Container  string `protobuf:"bytes,2,opt,name=container,proto3" json:"container,omitempty"`
	Follow     bool   `protobuf:"varint,3,opt,name=follow,proto3" json:"follow,omitempty"`
	Timestamp  bool   `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Since      string `protobuf:"bytes,5,opt,name=since,proto3" json:"since,omitempty"`
	TailLines  int64  `protobuf:"varint,6,opt,name=tail_lines,json=tailLines,proto3" json:"tail_lines,omitempty"`
	BytesLimit int64  `protobuf:"varint,7,opt,name=bytes_limit,json=bytesLimit,proto3" json:"bytes_limit,omitempty"`
	Previous   bool   `protobuf:"varint,8,opt,name=previous,proto3" json:"previous,omitempty"`
	// host log path
	Path string `protobuf:"bytes,9,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *LogsCmd) Reset()      { *m = LogsCmd{} }
func (*LogsCmd) ProtoMessage() {}
func (*LogsCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{6}
}
func (m *LogsCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogsCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogsCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogsCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogsCmd.Merge(m, src)
}
func (m *LogsCmd) XXX_Size() int {
	return m.Size()
}
func (m *LogsCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_LogsCmd.DiscardUnknown(m)
}

var xxx_messageInfo_LogsCmd proto.InternalMessageInfo

func (m *LogsCmd) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *LogsCmd) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *LogsCmd) GetFollow() bool {
	if m != nil {
		return m.Follow
	}
	return false
}

func (m *LogsCmd) GetTimestamp() bool {
	if m != nil {
		return m.Timestamp
	}
	return false
}

func (m *LogsCmd) GetSince() string {
	if m != nil {
		return m.Since
	}
	return ""
}

func (m *LogsCmd) GetTailLines() int64 {
	if m != nil {
		return m.TailLines
	}
	return 0
}

func (m *LogsCmd) GetBytesLimit() int64 {
	if m != nil {
		return m.BytesLimit
	}
	return 0
}

func (m *LogsCmd) GetPrevious() bool {
	if m != nil {
		return m.Previous
	}
	return false
}

func (m *LogsCmd) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Exec/Attach Cmd
type ExecOrAttachCmd struct {
	PodUid    string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	Container string `protobuf:"bytes,2,opt,name=container,proto3" json:"container,omitempty"`
	Stdin     bool   `protobuf:"varint,3,opt,name=stdin,proto3" json:"stdin,omitempty"`
	Stdout    bool   `protobuf:"varint,4,opt,name=stdout,proto3" json:"stdout,omitempty"`
	Stderr    bool   `protobuf:"varint,5,opt,name=stderr,proto3" json:"stderr,omitempty"`
	Tty       bool   `protobuf:"varint,6,opt,name=tty,proto3" json:"tty,omitempty"`
	// command is empty when used for container attach
	Command []string `protobuf:"bytes,7,rep,name=command,proto3" json:"command,omitempty"`
	// environment variables when used with virtual host container image
	// values are resolved by aranya
	Envs map[string]string `protobuf:"bytes,8,rep,name=envs,proto3" json:"envs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ExecOrAttachCmd) Reset()      { *m = ExecOrAttachCmd{} }
func (*ExecOrAttachCmd) ProtoMessage() {}
func (*ExecOrAttachCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{7}
}
func (m *ExecOrAttachCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecOrAttachCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecOrAttachCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecOrAttachCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecOrAttachCmd.Merge(m, src)
}
func (m *ExecOrAttachCmd) XXX_Size() int {
	return m.Size()
}
func (m *ExecOrAttachCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecOrAttachCmd.DiscardUnknown(m)
}

var xxx_messageInfo_ExecOrAttachCmd proto.InternalMessageInfo

func (m *ExecOrAttachCmd) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *ExecOrAttachCmd) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *ExecOrAttachCmd) GetStdin() bool {
	if m != nil {
		return m.Stdin
	}
	return false
}

func (m *ExecOrAttachCmd) GetStdout() bool {
	if m != nil {
		return m.Stdout
	}
	return false
}

func (m *ExecOrAttachCmd) GetStderr() bool {
	if m != nil {
		return m.Stderr
	}
	return false
}

func (m *ExecOrAttachCmd) GetTty() bool {
	if m != nil {
		return m.Tty
	}
	return false
}

func (m *ExecOrAttachCmd) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ExecOrAttachCmd) GetEnvs() map[string]string {
	if m != nil {
		return m.Envs
	}
	return nil
}

type PortForwardCmd struct {
	// pod uid to help runtime to find pod ip if no host provided
	PodUid string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	// Network type of the forwarded endpoint
	Network string `protobuf:"bytes,2,opt,name=network,proto3" json:"network,omitempty"`
	// host part of forwarded endpoint
	Host string `protobuf:"bytes,3,opt,name=host,proto3" json:"host,omitempty"`
	// port used for ip based protocols (e.g. tcp/udp)
	// for filed based protocols (e.g. unix/NamedPipe), this should be ignored
	Port int32 `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *PortForwardCmd) Reset()      { *m = PortForwardCmd{} }
func (*PortForwardCmd) ProtoMessage() {}
func (*PortForwardCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{8}
}
func (m *PortForwardCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortForwardCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortForwardCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortForwardCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortForwardCmd.Merge(m, src)
}
func (m *PortForwardCmd) XXX_Size() int {
	return m.Size()
}
func (m *PortForwardCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_PortForwardCmd.DiscardUnknown(m)
}

var xxx_messageInfo_PortForwardCmd proto.InternalMessageInfo

func (m *PortForwardCmd) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *PortForwardCmd) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *PortForwardCmd) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *PortForwardCmd) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type TerminalResizeCmd struct {
	Cols uint32 `protobuf:"varint,1,opt,name=cols,proto3" json:"cols,omitempty"`
	Rows uint32 `protobuf:"varint,2,opt,name=rows,proto3" json:"rows,omitempty"`
}

func (m *TerminalResizeCmd) Reset()      { *m = TerminalResizeCmd{} }
func (*TerminalResizeCmd) ProtoMessage() {}
func (*TerminalResizeCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{9}
}
func (m *TerminalResizeCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TerminalResizeCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TerminalResizeCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TerminalResizeCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TerminalResizeCmd.Merge(m, src)
}
func (m *TerminalResizeCmd) XXX_Size() int {
	return m.Size()
}
func (m *TerminalResizeCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_TerminalResizeCmd.DiscardUnknown(m)
}

var xxx_messageInfo_TerminalResizeCmd proto.InternalMessageInfo

func (m *TerminalResizeCmd) GetCols() uint32 {
	if m != nil {
		return m.Cols
	}
	return 0
}

func (m *TerminalResizeCmd) GetRows() uint32 {
	if m != nil {
		return m.Rows
	}
	return 0
}

type MetricsConfigCmd struct {
	Collect   []string `protobuf:"bytes,1,rep,name=collect,proto3" json:"collect,omitempty"`
	ExtraArgs []string `protobuf:"bytes,2,rep,name=extra_args,json=extraArgs,proto3" json:"extra_args,omitempty"`
}

func (m *MetricsConfigCmd) Reset()      { *m = MetricsConfigCmd{} }
func (*MetricsConfigCmd) ProtoMessage() {}
func (*MetricsConfigCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{10}
}
func (m *MetricsConfigCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricsConfigCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricsConfigCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricsConfigCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricsConfigCmd.Merge(m, src)
}
func (m *MetricsConfigCmd) XXX_Size() int {
	return m.Size()
}
func (m *MetricsConfigCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricsConfigCmd.DiscardUnknown(m)
}

var xxx_messageInfo_MetricsConfigCmd proto.InternalMessageInfo

func (m *MetricsConfigCmd) GetCollect() []string {
	if m != nil {
		return m.Collect
	}
	return nil
}

func (m *MetricsConfigCmd) GetExtraArgs() []string {
	if m != nil {
		return m.ExtraArgs
	}
	return nil
}

// Error infomation
type ErrorMsg struct {
	Kind ErrorMsg_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=aranya.ErrorMsg_Kind" json:"kind,omitempty"`
	// Human readable error description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// error code may be used for:
	//  - exit code of command execution
	//  - ...TBD
	Code int64 `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *ErrorMsg) Reset()      { *m = ErrorMsg{} }
func (*ErrorMsg) ProtoMessage() {}
func (*ErrorMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{11}
}
func (m *ErrorMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrorMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ErrorMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ErrorMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrorMsg.Merge(m, src)
}
func (m *ErrorMsg) XXX_Size() int {
	return m.Size()
}
func (m *ErrorMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrorMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ErrorMsg proto.InternalMessageInfo

func (m *ErrorMsg) GetKind() ErrorMsg_Kind {
	if m != nil {
		return m.Kind
	}
	return ERR_COMMON
}

func (m *ErrorMsg) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ErrorMsg) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

// State of agent, online/offline
type StateMsg struct {
	Kind     StateMsg_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=aranya.StateMsg_Kind" json:"kind,omitempty"`
	DeviceId string        `protobuf:"bytes,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
}

func (m *StateMsg) Reset()      { *m = StateMsg{} }
func (*StateMsg) ProtoMessage() {}
func (*StateMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{12}
}
func (m *StateMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMsg.Merge(m, src)
}
func (m *StateMsg) XXX_Size() int {
	return m.Size()
}
func (m *StateMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMsg.DiscardUnknown(m)
}

var xxx_messageInfo_StateMsg proto.InternalMessageInfo

func (m *StateMsg) GetKind() StateMsg_Kind {
	if m != nil {
		return m.Kind
	}
	return _INVALID_STATE
}

func (m *StateMsg) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

type NetworkMsg struct {
	// protobuf bytes of abbot proto
	AbbotResponseBytes []byte `protobuf:"bytes,1,opt,name=abbot_response_bytes,json=abbotResponseBytes,proto3" json:"abbot_response_bytes,omitempty"`
}

func (m *NetworkMsg) Reset()      { *m = NetworkMsg{} }
func (*NetworkMsg) ProtoMessage() {}
func (*NetworkMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{13}
}
func (m *NetworkMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkMsg.Merge(m, src)
}
func (m *NetworkMsg) XXX_Size() int {
	return m.Size()
}
func (m *NetworkMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkMsg.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkMsg proto.InternalMessageInfo

func (m *NetworkMsg) GetAbbotResponseBytes() []byte {
	if m != nil {
		return m.AbbotResponseBytes
	}
	return nil
}

//
//
//Node Information Sync
//
type NodeSystemInfo struct {
	Os            string `protobuf:"bytes,1,opt,name=os,proto3" json:"os,omitempty"`
	OsImage       string `protobuf:"bytes,2,opt,name=os_image,json=osImage,proto3" json:"os_image,omitempty"`
	Arch          string `protobuf:"bytes,3,opt,name=arch,proto3" json:"arch,omitempty"`
	KernelVersion string `protobuf:"bytes,4,opt,name=kernel_version,json=kernelVersion,proto3" json:"kernel_version,omitempty"`
	BootId        string `protobuf:"bytes,5,opt,name=boot_id,json=bootId,proto3" json:"boot_id,omitempty"`
	MachineId     string `protobuf:"bytes,6,opt,name=machine_id,json=machineId,proto3" json:"machine_id,omitempty"`
	SystemUuid    string `protobuf:"bytes,7,opt,name=system_uuid,json=systemUuid,proto3" json:"system_uuid,omitempty"`
}

func (m *NodeSystemInfo) Reset()      { *m = NodeSystemInfo{} }
func (*NodeSystemInfo) ProtoMessage() {}
func (*NodeSystemInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{14}
}
func (m *NodeSystemInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeSystemInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeSystemInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeSystemInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeSystemInfo.Merge(m, src)
}
func (m *NodeSystemInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeSystemInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeSystemInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeSystemInfo proto.InternalMessageInfo

func (m *NodeSystemInfo) GetOs() string {
	if m != nil {
		return m.Os
	}
	return ""
}

func (m *NodeSystemInfo) GetOsImage() string {
	if m != nil {
		return m.OsImage
	}
	return ""
}

func (m *NodeSystemInfo) GetArch() string {
	if m != nil {
		return m.Arch
	}
	return ""
}

func (m *NodeSystemInfo) GetKernelVersion() string {
	if m != nil {
		return m.KernelVersion
	}
	return ""
}

func (m *NodeSystemInfo) GetBootId() string {
	if m != nil {
		return m.BootId
	}
	return ""
}

func (m *NodeSystemInfo) GetMachineId() string {
	if m != nil {
		return m.MachineId
	}
	return ""
}

func (m *NodeSystemInfo) GetSystemUuid() string {
	if m != nil {
		return m.SystemUuid
	}
	return ""
}

type NodeResources struct {
	CpuCount     uint64 `protobuf:"varint,1,opt,name=cpu_count,json=cpuCount,proto3" json:"cpu_count,omitempty"`
	MemoryBytes  uint64 `protobuf:"varint,2,opt,name=memory_bytes,json=memoryBytes,proto3" json:"memory_bytes,omitempty"`
	StorageBytes uint64 `protobuf:"varint,3,opt,name=storage_bytes,json=storageBytes,proto3" json:"storage_bytes,omitempty"`
}

func (m *NodeResources) Reset()      { *m = NodeResources{} }
func (*NodeResources) ProtoMessage() {}
func (*NodeResources) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{15}
}
func (m *NodeResources) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeResources) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeResources.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeResources) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeResources.Merge(m, src)
}
func (m *NodeResources) XXX_Size() int {
	return m.Size()
}
func (m *NodeResources) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeResources.DiscardUnknown(m)
}

var xxx_messageInfo_NodeResources proto.InternalMessageInfo

func (m *NodeResources) GetCpuCount() uint64 {
	if m != nil {
		return m.CpuCount
	}
	return 0
}

func (m *NodeResources) GetMemoryBytes() uint64 {
	if m != nil {
		return m.MemoryBytes
	}
	return 0
}

func (m *NodeResources) GetStorageBytes() uint64 {
	if m != nil {
		return m.StorageBytes
	}
	return 0
}

type NodeConditions struct {
	Ready   NodeCondition `protobuf:"varint,1,opt,name=ready,proto3,enum=aranya.NodeCondition" json:"ready,omitempty"`
	Memory  NodeCondition `protobuf:"varint,2,opt,name=memory,proto3,enum=aranya.NodeCondition" json:"memory,omitempty"`
	Disk    NodeCondition `protobuf:"varint,3,opt,name=disk,proto3,enum=aranya.NodeCondition" json:"disk,omitempty"`
	Pid     NodeCondition `protobuf:"varint,4,opt,name=pid,proto3,enum=aranya.NodeCondition" json:"pid,omitempty"`
	Network NodeCondition `protobuf:"varint,5,opt,name=network,proto3,enum=aranya.NodeCondition" json:"network,omitempty"`
	Pod     NodeCondition `protobuf:"varint,6,opt,name=pod,proto3,enum=aranya.NodeCondition" json:"pod,omitempty"`
}

func (m *NodeConditions) Reset()      { *m = NodeConditions{} }
func (*NodeConditions) ProtoMessage() {}
func (*NodeConditions) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{16}
}
func (m *NodeConditions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeConditions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeConditions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeConditions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeConditions.Merge(m, src)
}
func (m *NodeConditions) XXX_Size() int {
	return m.Size()
}
func (m *NodeConditions) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeConditions.DiscardUnknown(m)
}

var xxx_messageInfo_NodeConditions proto.InternalMessageInfo

func (m *NodeConditions) GetReady() NodeCondition {
	if m != nil {
		return m.Ready
	}
	return NODE_CONDITION_UNKNOWN
}

func (m *NodeConditions) GetMemory() NodeCondition {
	if m != nil {
		return m.Memory
	}
	return NODE_CONDITION_UNKNOWN
}

func (m *NodeConditions) GetDisk() NodeCondition {
	if m != nil {
		return m.Disk
	}
	return NODE_CONDITION_UNKNOWN
}

func (m *NodeConditions) GetPid() NodeCondition {
	if m != nil {
		return m.Pid
	}
	return NODE_CONDITION_UNKNOWN
}

func (m *NodeConditions) GetNetwork() NodeCondition {
	if m != nil {
		return m.Network
	}
	return NODE_CONDITION_UNKNOWN
}

func (m *NodeConditions) GetPod() NodeCondition {
	if m != nil {
		return m.Pod
	}
	return NODE_CONDITION_UNKNOWN
}

type NodeExtInfo struct {
	// value is always transmitted in string format
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// type of the value
	ValueType NodeExtInfo_ValueType `protobuf:"varint,2,opt,name=value_type,json=valueType,proto3,enum=aranya.NodeExtInfo_ValueType" json:"value_type,omitempty"`
	// operator
	Operator  NodeExtInfo_Operator `protobuf:"varint,3,opt,name=operator,proto3,enum=aranya.NodeExtInfo_Operator" json:"operator,omitempty"`
	Target    NodeExtInfo_Target   `protobuf:"varint,4,opt,name=target,proto3,enum=aranya.NodeExtInfo_Target" json:"target,omitempty"`
	TargetKey string               `protobuf:"bytes,5,opt,name=target_key,json=targetKey,proto3" json:"target_key,omitempty"`
}

func (m *NodeExtInfo) Reset()      { *m = NodeExtInfo{} }
func (*NodeExtInfo) ProtoMessage() {}
func (*NodeExtInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{17}
}
func (m *NodeExtInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeExtInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeExtInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeExtInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeExtInfo.Merge(m, src)
}
func (m *NodeExtInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeExtInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeExtInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeExtInfo proto.InternalMessageInfo

func (m *NodeExtInfo) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *NodeExtInfo) GetValueType() NodeExtInfo_ValueType {
	if m != nil {
		return m.ValueType
	}
	return NODE_EXT_INFO_TYPE_STRING
}

func (m *NodeExtInfo) GetOperator() NodeExtInfo_Operator {
	if m != nil {
		return m.Operator
	}
	return NODE_EXT_INFO_OPERATOR_SET
}

func (m *NodeExtInfo) GetTarget() NodeExtInfo_Target {
	if m != nil {
		return m.Target
	}
	return NODE_EXT_INFO_TARGET_ANNOTATION
}

func (m *NodeExtInfo) GetTargetKey() string {
	if m != nil {
		return m.TargetKey
	}
	return ""
}

type NodeStatusMsg struct {
	SystemInfo *NodeSystemInfo `protobuf:"bytes,1,opt,name=system_info,json=systemInfo,proto3" json:"system_info,omitempty"`
	Capacity   *NodeResources  `protobuf:"bytes,2,opt,name=capacity,proto3" json:"capacity,omitempty"`
	Conditions *NodeConditions `protobuf:"bytes,3,opt,name=conditions,proto3" json:"conditions,omitempty"`
	ExtInfo    []*NodeExtInfo  `protobuf:"bytes,4,rep,name=ext_info,json=extInfo,proto3" json:"ext_info,omitempty"`
}

func (m *NodeStatusMsg) Reset()      { *m = NodeStatusMsg{} }
func (*NodeStatusMsg) ProtoMessage() {}
func (*NodeStatusMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{18}
}
func (m *NodeStatusMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeStatusMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeStatusMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeStatusMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeStatusMsg.Merge(m, src)
}
func (m *NodeStatusMsg) XXX_Size() int {
	return m.Size()
}
func (m *NodeStatusMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeStatusMsg.DiscardUnknown(m)
}

var xxx_messageInfo_NodeStatusMsg proto.InternalMessageInfo

func (m *NodeStatusMsg) GetSystemInfo() *NodeSystemInfo {
	if m != nil {
		return m.SystemInfo
	}
	return nil
}

func (m *NodeStatusMsg) GetCapacity() *NodeResources {
	if m != nil {
		return m.Capacity
	}
	return nil
}

func (m *NodeStatusMsg) GetConditions() *NodeConditions {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *NodeStatusMsg) GetExtInfo() []*NodeExtInfo {
	if m != nil {
		return m.ExtInfo
	}
	return nil
}

type StorageListCmd struct {
}

func (m *StorageListCmd) Reset()      { *m = StorageListCmd{} }
func (*StorageListCmd) ProtoMessage() {}
func (*StorageListCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{19}
}
func (m *StorageListCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageListCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageListCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageListCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageListCmd.Merge(m, src)
}
func (m *StorageListCmd) XXX_Size() int {
	return m.Size()
}
func (m *StorageListCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageListCmd.DiscardUnknown(m)
}

var xxx_messageInfo_StorageListCmd proto.InternalMessageInfo

type StorageEnsureCmd struct {
	RemotePath string `protobuf:"bytes,1,opt,name=remote_path,json=remotePath,proto3" json:"remote_path,omitempty"`
	LocalPath  string `protobuf:"bytes,2,opt,name=local_path,json=localPath,proto3" json:"local_path,omitempty"`
}

func (m *StorageEnsureCmd) Reset()      { *m = StorageEnsureCmd{} }
func (*StorageEnsureCmd) ProtoMessage() {}
func (*StorageEnsureCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{20}
}
func (m *StorageEnsureCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageEnsureCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageEnsureCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageEnsureCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageEnsureCmd.Merge(m, src)
}
func (m *StorageEnsureCmd) XXX_Size() int {
	return m.Size()
}
func (m *StorageEnsureCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageEnsureCmd.DiscardUnknown(m)
}

var xxx_messageInfo_StorageEnsureCmd proto.InternalMessageInfo

func (m *StorageEnsureCmd) GetRemotePath() string {
	if m != nil {
		return m.RemotePath
	}
	return ""
}

func (m *StorageEnsureCmd) GetLocalPath() string {
	if m != nil {
		return m.LocalPath
	}
	return ""
}

type StorageDeleteCmd struct {
	RemotePath string `protobuf:"bytes,1,opt,name=remote_path,json=remotePath,proto3" json:"remote_path,omitempty"`
	LocalPath  string `protobuf:"bytes,2,opt,name=local_path,json=localPath,proto3" json:"local_path,omitempty"`
}

func (m *StorageDeleteCmd) Reset()      { *m = StorageDeleteCmd{} }
func (*StorageDeleteCmd) ProtoMessage() {}
func (*StorageDeleteCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{21}
}
func (m *StorageDeleteCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageDeleteCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageDeleteCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageDeleteCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageDeleteCmd.Merge(m, src)
}
func (m *StorageDeleteCmd) XXX_Size() int {
	return m.Size()
}
func (m *StorageDeleteCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageDeleteCmd.DiscardUnknown(m)
}

var xxx_messageInfo_StorageDeleteCmd proto.InternalMessageInfo

func (m *StorageDeleteCmd) GetRemotePath() string {
	if m != nil {
		return m.RemotePath
	}
	return ""
}

func (m *StorageDeleteCmd) GetLocalPath() string {
	if m != nil {
		return m.LocalPath
	}
	return ""
}

type StorageStatusMsg struct {
	State      StorageState `protobuf:"varint,1,opt,name=state,proto3,enum=aranya.StorageState" json:"state,omitempty"`
	RemotePath string       `protobuf:"bytes,2,opt,name=remote_path,json=remotePath,proto3" json:"remote_path,omitempty"`
	MountPoint string       `protobuf:"bytes,3,opt,name=mount_point,json=mountPoint,proto3" json:"mount_point,omitempty"`
}

func (m *StorageStatusMsg) Reset()      { *m = StorageStatusMsg{} }
func (*StorageStatusMsg) ProtoMessage() {}
func (*StorageStatusMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{22}
}
func (m *StorageStatusMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageStatusMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageStatusMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageStatusMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageStatusMsg.Merge(m, src)
}
func (m *StorageStatusMsg) XXX_Size() int {
	return m.Size()
}
func (m *StorageStatusMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageStatusMsg.DiscardUnknown(m)
}

var xxx_messageInfo_StorageStatusMsg proto.InternalMessageInfo

func (m *StorageStatusMsg) GetState() StorageState {
	if m != nil {
		return m.State
	}
	return STORAGE_STATE_UNKONW
}

func (m *StorageStatusMsg) GetRemotePath() string {
	if m != nil {
		return m.RemotePath
	}
	return ""
}

func (m *StorageStatusMsg) GetMountPoint() string {
	if m != nil {
		return m.MountPoint
	}
	return ""
}

type StorageStatusListMsg struct {
	Storages []*StorageStatusMsg `protobuf:"bytes,1,rep,name=storages,proto3" json:"storages,omitempty"`
}

func (m *StorageStatusListMsg) Reset()      { *m = StorageStatusListMsg{} }
func (*StorageStatusListMsg) ProtoMessage() {}
func (*StorageStatusListMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{23}
}
func (m *StorageStatusListMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageStatusListMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageStatusListMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageStatusListMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageStatusListMsg.Merge(m, src)
}
func (m *StorageStatusListMsg) XXX_Size() int {
	return m.Size()
}
func (m *StorageStatusListMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageStatusListMsg.DiscardUnknown(m)
}

var xxx_messageInfo_StorageStatusListMsg proto.InternalMessageInfo

func (m *StorageStatusListMsg) GetStorages() []*StorageStatusMsg {
	if m != nil {
		return m.Storages
	}
	return nil
}

type CredentialListCmd struct {
}

func (m *CredentialListCmd) Reset()      { *m = CredentialListCmd{} }
func (*CredentialListCmd) ProtoMessage() {}
func (*CredentialListCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{24}
}
func (m *CredentialListCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CredentialListCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CredentialListCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CredentialListCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CredentialListCmd.Merge(m, src)
}
func (m *CredentialListCmd) XXX_Size() int {
	return m.Size()
}
func (m *CredentialListCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_CredentialListCmd.DiscardUnknown(m)
}

var xxx_messageInfo_CredentialListCmd proto.InternalMessageInfo

type CredentialDeleteCmd struct {
}

func (m *CredentialDeleteCmd) Reset()      { *m = CredentialDeleteCmd{} }
func (*CredentialDeleteCmd) ProtoMessage() {}
func (*CredentialDeleteCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{25}
}
func (m *CredentialDeleteCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CredentialDeleteCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CredentialDeleteCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CredentialDeleteCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CredentialDeleteCmd.Merge(m, src)
}
func (m *CredentialDeleteCmd) XXX_Size() int {
	return m.Size()
}
func (m *CredentialDeleteCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_CredentialDeleteCmd.DiscardUnknown(m)
}

var xxx_messageInfo_CredentialDeleteCmd proto.InternalMessageInfo

type CredentialEnsureCmd struct {
	SshPrivateKey []byte `protobuf:"bytes,1,opt,name=ssh_private_key,json=sshPrivateKey,proto3" json:"ssh_private_key,omitempty"`
}

func (m *CredentialEnsureCmd) Reset()      { *m = CredentialEnsureCmd{} }
func (*CredentialEnsureCmd) ProtoMessage() {}
func (*CredentialEnsureCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{26}
}
func (m *CredentialEnsureCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CredentialEnsureCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CredentialEnsureCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CredentialEnsureCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CredentialEnsureCmd.Merge(m, src)
}
func (m *CredentialEnsureCmd) XXX_Size() int {
	return m.Size()
}
func (m *CredentialEnsureCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_CredentialEnsureCmd.DiscardUnknown(m)
}

var xxx_messageInfo_CredentialEnsureCmd proto.InternalMessageInfo

func (m *CredentialEnsureCmd) GetSshPrivateKey() []byte {
	if m != nil {
		return m.SshPrivateKey
	}
	return nil
}

type CredentialStatusMsg struct {
	SshPrivateKeySha256 []byte `protobuf:"bytes,1,opt,name=ssh_private_key_sha256,json=sshPrivateKeySha256,proto3" json:"ssh_private_key_sha256,omitempty"`
}

func (m *CredentialStatusMsg) Reset()      { *m = CredentialStatusMsg{} }
func (*CredentialStatusMsg) ProtoMessage() {}
func (*CredentialStatusMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{27}
}
func (m *CredentialStatusMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CredentialStatusMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CredentialStatusMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CredentialStatusMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CredentialStatusMsg.Merge(m, src)
}
func (m *CredentialStatusMsg) XXX_Size() int {
	return m.Size()
}
func (m *CredentialStatusMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_CredentialStatusMsg.DiscardUnknown(m)
}

var xxx_messageInfo_CredentialStatusMsg proto.InternalMessageInfo

func (m *CredentialStatusMsg) GetSshPrivateKeySha256() []byte {
	if m != nil {
		return m.SshPrivateKeySha256
	}
	return nil
}

func init() {
	proto.RegisterEnum("aranya.CmdType", CmdType_name, CmdType_value)
	proto.RegisterEnum("aranya.MsgType", MsgType_name, MsgType_value)
	proto.RegisterEnum("aranya.RejectionReason", RejectionReason_name, RejectionReason_value)
	proto.RegisterEnum("aranya.NodeCondition", NodeCondition_name, NodeCondition_value)
	proto.RegisterEnum("aranya.StorageState", StorageState_name, StorageState_value)
	proto.RegisterEnum("aranya.NodeInfoGetCmd_Kind", NodeInfoGetCmd_Kind_name, NodeInfoGetCmd_Kind_value)
	proto.RegisterEnum("aranya.ErrorMsg_Kind", ErrorMsg_Kind_name, ErrorMsg_Kind_value)
	proto.RegisterEnum("aranya.StateMsg_Kind", StateMsg_Kind_name, StateMsg_Kind_value)
	proto.RegisterEnum("aranya.NodeExtInfo_ValueType", NodeExtInfo_ValueType_name, NodeExtInfo_ValueType_value)
	proto.RegisterEnum("aranya.NodeExtInfo_Operator", NodeExtInfo_Operator_name, NodeExtInfo_Operator_value)
	proto.RegisterEnum("aranya.NodeExtInfo_Target", NodeExtInfo_Target_name, NodeExtInfo_Target_value)
	proto.RegisterType((*Cmd)(nil), "aranya.Cmd")
	proto.RegisterType((*Msg)(nil), "aranya.Msg")
	proto.RegisterType((*NodeInfoGetCmd)(nil), "aranya.NodeInfoGetCmd")
	proto.RegisterType((*SessionCloseCmd)(nil), "aranya.SessionCloseCmd")
	proto.RegisterType((*RejectCmd)(nil), "aranya.RejectCmd")
	proto.RegisterType((*NetworkCmd)(nil), "aranya.NetworkCmd")
	proto.RegisterType((*LogsCmd)(nil), "aranya.LogsCmd")
	proto.RegisterType((*ExecOrAttachCmd)(nil), "aranya.ExecOrAttachCmd")
	proto.RegisterMapType((map[string]string)(nil), "aranya.ExecOrAttachCmd.EnvsEntry")
	proto.RegisterType((*PortForwardCmd)(nil), "aranya.PortForwardCmd")
	proto.RegisterType((*TerminalResizeCmd)(nil), "aranya.TerminalResizeCmd")
	proto.RegisterType((*MetricsConfigCmd)(nil), "aranya.MetricsConfigCmd")
	proto.RegisterType((*ErrorMsg)(nil), "aranya.ErrorMsg")
	proto.RegisterType((*StateMsg)(nil), "aranya.StateMsg")
	proto.RegisterType((*NetworkMsg)(nil), "aranya.NetworkMsg")
	proto.RegisterType((*NodeSystemInfo)(nil), "aranya.NodeSystemInfo")
	proto.RegisterType((*NodeResources)(nil), "aranya.NodeResources")
	proto.RegisterType((*NodeConditions)(nil), "aranya.NodeConditions")
	proto.RegisterType((*NodeExtInfo)(nil), "aranya.NodeExtInfo")
	proto.RegisterType((*NodeStatusMsg)(nil), "aranya.NodeStatusMsg")
	proto.RegisterType((*StorageListCmd)(nil), "aranya.StorageListCmd")
	proto.RegisterType((*StorageEnsureCmd)(nil), "aranya.StorageEnsureCmd")
	proto.RegisterType((*StorageDeleteCmd)(nil), "aranya.StorageDeleteCmd")
	proto.RegisterType((*StorageStatusMsg)(nil), "aranya.StorageStatusMsg")
	proto.RegisterType((*StorageStatusListMsg)(nil), "aranya.StorageStatusListMsg")
	proto.RegisterType((*CredentialListCmd)(nil), "aranya.CredentialListCmd")
	proto.RegisterType((*CredentialDeleteCmd)(nil), "aranya.CredentialDeleteCmd")
	proto.RegisterType((*CredentialEnsureCmd)(nil), "aranya.CredentialEnsureCmd")
	proto.RegisterType((*CredentialStatusMsg)(nil), "aranya.CredentialStatusMsg")
}

func init() { proto.RegisterFile("proto.proto", fileDescriptor_2fcc84b9998d60d8) }

var fileDescriptor_2fcc84b9998d60d8 = []byte{
	// 2350 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x4f, 0x73, 0xdb, 0xc6,
	0x15, 0x17, 0x28, 0x59, 0x22, 0x1f, 0xf5, 0x07, 0x5e, 0xf9, 0x0f, 0x63, 0x3b, 0x94, 0x02, 0x4f,
	0x5b, 0x47, 0x69, 0x94, 0xd6, 0x8e, 0x93, 0x4c, 0x9b, 0xb6, 0x83, 0x90, 0x2b, 0x19, 0x31, 0x09,
	0x68, 0x16, 0xa0, 0x1d, 0xe7, 0x82, 0xc2, 0xc4, 0x5a, 0x42, 0x4d, 0x62, 0x19, 0x00, 0x94, 0xad,
	0x9e, 0x72, 0xea, 0xb9, 0x33, 0x99, 0x5e, 0xfa, 0x09, 0x3a, 0xfd, 0x04, 0xfd, 0x08, 0xbd, 0x35,
	0xa7, 0x4e, 0x8e, 0xb5, 0x7c, 0xe9, 0xa5, 0x33, 0xf9, 0x00, 0x3d, 0x74, 0xde, 0xee, 0x82, 0xa4,
	0x68, 0xd9, 0x97, 0x76, 0x7a, 0xe1, 0xec, 0xfb, 0xbd, 0xb7, 0x6f, 0xdf, 0xbf, 0x7d, 0xfb, 0x40,
	0xa8, 0x8f, 0x32, 0x51, 0x88, 0x5d, 0xf9, 0x4b, 0x96, 0xa3, 0x2c, 0x4a, 0x4f, 0x22, 0xeb, 0x77,
	0x06, 0x2c, 0xb6, 0x86, 0x31, 0xb9, 0x09, 0x4b, 0x4f, 0x93, 0x34, 0x6e, 0x18, 0xdb, 0xc6, 0xad,
	0xf5, 0xdb, 0x1b, 0xbb, 0x8a, 0xbd, 0xdb, 0x1a, 0xc6, 0xc1, 0xc9, 0x88, 0x33, 0xc9, 0x24, 0x26,
	0x2c, 0xe6, 0x49, 0xdc, 0xa8, 0x6c, 0x1b, 0xb7, 0x96, 0x18, 0x2e, 0x25, 0xc2, 0xbf, 0x6a, 0x2c,
	0x6a, 0x84, 0x7f, 0x45, 0x6e, 0x40, 0xad, 0x2f, 0x86, 0xa3, 0x01, 0x2f, 0x78, 0xdc, 0x58, 0xda,
	0x36, 0x6e, 0x55, 0xd9, 0x14, 0x20, 0x0d, 0x58, 0x19, 0x45, 0x27, 0x03, 0x11, 0xc5, 0x8d, 0xfa,
	0xb6, 0x71, 0x6b, 0x95, 0x95, 0xa4, 0x34, 0xa4, 0x9b, 0x1f, 0xbe, 0xce, 0x90, 0x6e, 0x7e, 0xf8,
	0x7f, 0x32, 0x44, 0xc0, 0xba, 0x2b, 0x62, 0xee, 0xa4, 0x4f, 0xc4, 0x3e, 0x2f, 0x30, 0x36, 0x1f,
	0x9c, 0x31, 0xe9, 0x7a, 0x69, 0xd2, 0x59, 0xa9, 0xdd, 0xfb, 0x49, 0x1a, 0x2b, 0xf3, 0xac, 0x1f,
	0xc3, 0x12, 0x52, 0xe4, 0x22, 0xac, 0xb9, 0x5e, 0x9b, 0x86, 0x8e, 0xbb, 0xe7, 0x85, 0xed, 0x47,
	0xae, 0xb9, 0x70, 0x16, 0xb2, 0x3b, 0x1d, 0xd3, 0xb0, 0x6e, 0xc2, 0x86, 0xcf, 0xf3, 0x3c, 0x11,
	0x69, 0x6b, 0x20, 0x72, 0x8e, 0x27, 0x6a, 0xff, 0x8c, 0x89, 0x7f, 0xd6, 0x03, 0xa8, 0x31, 0xfe,
	0x1b, 0xde, 0xd7, 0x06, 0x2d, 0x67, 0x3c, 0xca, 0x45, 0xaa, 0x4d, 0xba, 0x5a, 0x9a, 0xa4, 0x44,
	0x12, 0x91, 0x32, 0xc9, 0x66, 0x5a, 0x0c, 0xbd, 0x1d, 0xf2, 0x3c, 0x8f, 0x0e, 0xb9, 0x8c, 0x59,
	0x8d, 0x95, 0xa4, 0xf5, 0x29, 0x80, 0xcb, 0x8b, 0x67, 0x22, 0x7b, 0x8a, 0x8a, 0x77, 0x61, 0x33,
	0x7a, 0xfc, 0x58, 0x14, 0x61, 0xc6, 0xbf, 0x1a, 0xf3, 0xbc, 0x08, 0x1f, 0x9f, 0x14, 0x3c, 0x97,
	0xa7, 0xac, 0xb2, 0x8b, 0x92, 0xc5, 0x14, 0xe7, 0x33, 0x64, 0x58, 0xff, 0x36, 0x60, 0xa5, 0x23,
	0x0e, 0x73, 0xdc, 0x7b, 0x15, 0x56, 0x46, 0x22, 0x0e, 0xc7, 0xda, 0xee, 0x1a, 0x5b, 0x1e, 0x89,
	0xb8, 0x97, 0xc4, 0x2a, 0x11, 0x69, 0x11, 0x25, 0x29, 0xcf, 0xf4, 0xf1, 0x53, 0x80, 0x5c, 0x81,
	0xe5, 0x27, 0x62, 0x30, 0x10, 0xcf, 0x64, 0xee, 0xaa, 0x4c, 0x53, 0xb8, 0xab, 0x48, 0x86, 0x3c,
	0x2f, 0xa2, 0xe1, 0xa8, 0x4c, 0xdf, 0x04, 0x20, 0x97, 0xe0, 0x42, 0x9e, 0xa4, 0x7d, 0xde, 0xb8,
	0x20, 0xf5, 0x29, 0x82, 0xbc, 0x0d, 0x50, 0x44, 0xc9, 0x20, 0x1c, 0x24, 0x29, 0xcf, 0x1b, 0xcb,
	0xdb, 0xc6, 0xad, 0x45, 0x56, 0x43, 0xa4, 0x83, 0x00, 0xd9, 0x82, 0xba, 0xf4, 0x27, 0x1c, 0x24,
	0xc3, 0xa4, 0x68, 0xac, 0x48, 0x3e, 0x48, 0xa8, 0x83, 0x08, 0xb9, 0x06, 0xd5, 0x51, 0xc6, 0x8f,
	0x13, 0x31, 0xce, 0x1b, 0x55, 0x79, 0xe4, 0x84, 0x26, 0x04, 0x96, 0x46, 0x51, 0x71, 0xd4, 0xa8,
	0xc9, 0x03, 0xe5, 0xda, 0xfa, 0x73, 0x05, 0x36, 0xe8, 0x73, 0xde, 0xf7, 0x32, 0xbb, 0x28, 0xa2,
	0xfe, 0xd1, 0x7f, 0x11, 0x06, 0x74, 0xa8, 0x88, 0x93, 0x54, 0x47, 0x41, 0x11, 0x18, 0x9c, 0xbc,
	0x88, 0xc5, 0xb8, 0xd0, 0x11, 0xd0, 0x94, 0xc6, 0x79, 0x96, 0x49, 0xff, 0x15, 0xce, 0xb3, 0x0c,
	0xeb, 0xa6, 0x28, 0x4e, 0xa4, 0xe7, 0x55, 0x86, 0x4b, 0xcc, 0x7c, 0x5f, 0x0c, 0x87, 0x51, 0x1a,
	0x37, 0x56, 0xb6, 0x17, 0x31, 0xf3, 0x9a, 0x24, 0x77, 0x61, 0x89, 0xa7, 0xc7, 0xe8, 0xe8, 0xe2,
	0xad, 0xfa, 0xed, 0x77, 0xca, 0x12, 0x9a, 0xf3, 0x67, 0x97, 0xa6, 0xc7, 0x39, 0x4d, 0x8b, 0xec,
	0x84, 0x49, 0xf1, 0x6b, 0x1f, 0x43, 0x6d, 0x02, 0xe1, 0x79, 0x4f, 0xf9, 0x89, 0x76, 0x14, 0x97,
	0xe8, 0xc7, 0x71, 0x34, 0x18, 0x97, 0x75, 0xa6, 0x88, 0x9f, 0x55, 0x3e, 0x31, 0xac, 0xa7, 0xb0,
	0x7e, 0x20, 0xb2, 0x62, 0x4f, 0x64, 0xcf, 0xa2, 0x2c, 0x7e, 0x63, 0xa8, 0x1a, 0xb0, 0x92, 0xaa,
	0xa2, 0x2c, 0xcb, 0x55, 0x93, 0x98, 0x85, 0x23, 0x91, 0x17, 0x32, 0x4a, 0x35, 0x26, 0xd7, 0x32,
	0x33, 0x22, 0x53, 0x21, 0xba, 0xc0, 0xe4, 0xda, 0xfa, 0x39, 0x5c, 0x0c, 0x78, 0x36, 0x4c, 0xd2,
	0x68, 0xc0, 0x78, 0x9e, 0xfc, 0x56, 0xde, 0x2a, 0x02, 0x4b, 0x7d, 0x31, 0x50, 0xe5, 0xbc, 0xc6,
	0xe4, 0x1a, 0xb1, 0x4c, 0x3c, 0xcb, 0xe5, 0x39, 0x6b, 0x4c, 0xae, 0xad, 0xfb, 0x60, 0x76, 0x79,
	0x91, 0x25, 0xfd, 0xbc, 0x25, 0xd2, 0x27, 0xc9, 0x21, 0xee, 0x95, 0x71, 0x1c, 0x0c, 0x78, 0xbf,
	0x68, 0x18, 0x65, 0x1c, 0x25, 0x89, 0x45, 0xc7, 0x9f, 0x17, 0x59, 0x14, 0x46, 0xd9, 0x21, 0xea,
	0x41, 0x66, 0x4d, 0x22, 0x76, 0x76, 0x98, 0x5b, 0x7f, 0x37, 0xa0, 0x4a, 0xb3, 0x4c, 0x64, 0xd8,
	0xdc, 0xde, 0x3d, 0xd3, 0x49, 0x2e, 0x4f, 0x62, 0xae, 0xf9, 0x33, 0x3d, 0x84, 0x6c, 0x43, 0x3d,
	0xe6, 0x79, 0x3f, 0x4b, 0x46, 0x78, 0x9f, 0x75, 0x1c, 0x66, 0x21, 0xe5, 0x4e, 0xcc, 0x65, 0x2c,
	0x16, 0x99, 0x5c, 0x5b, 0x89, 0xee, 0x3c, 0xeb, 0x00, 0x94, 0xb1, 0xb0, 0xe5, 0x75, 0xbb, 0x9e,
	0x6e, 0x3b, 0x48, 0xbb, 0x5e, 0x10, 0xee, 0x79, 0x3d, 0xb7, 0x6d, 0x1a, 0xe4, 0x0a, 0x10, 0x84,
	0xec, 0x0e, 0xa3, 0x76, 0xfb, 0x51, 0x48, 0xbf, 0x70, 0xfc, 0xc0, 0x37, 0x2b, 0xe4, 0x32, 0x5c,
	0x2c, 0x45, 0xfd, 0xde, 0xc1, 0x81, 0xc7, 0x02, 0xda, 0x36, 0x17, 0xc9, 0x06, 0xd4, 0x11, 0x0e,
	0x9c, 0x2e, 0xf5, 0x7a, 0x81, 0xb9, 0x64, 0x7d, 0x63, 0x40, 0xd5, 0x2f, 0xa2, 0x82, 0xbf, 0xc1,
	0xb1, 0x92, 0x3f, 0xeb, 0xd8, 0x75, 0xa8, 0xc5, 0xfc, 0x38, 0xe9, 0xf3, 0x50, 0x77, 0xf0, 0x1a,
	0xab, 0x2a, 0xc0, 0x89, 0xad, 0x5f, 0x69, 0xfb, 0x09, 0xac, 0x87, 0x8e, 0xfb, 0xc0, 0xee, 0x38,
	0xed, 0xd0, 0x0f, 0xec, 0x80, 0x9a, 0x0b, 0xc4, 0x84, 0x55, 0xb9, 0x0c, 0x3d, 0xb7, 0xe3, 0xb8,
	0xd4, 0x34, 0xd0, 0x2b, 0x8d, 0xec, 0xed, 0x49, 0xa8, 0x62, 0xfd, 0x72, 0xd2, 0xcf, 0xd0, 0xac,
	0x9f, 0xc0, 0xa5, 0xb2, 0x9f, 0xe5, 0x23, 0x91, 0xe6, 0xfc, 0x4c, 0x43, 0x23, 0xba, 0xa1, 0x29,
	0x96, 0xea, 0x68, 0x7f, 0x33, 0x54, 0xfb, 0xf7, 0x4f, 0xf2, 0x82, 0x0f, 0xb1, 0xbd, 0x93, 0x75,
	0xa8, 0x88, 0x5c, 0x57, 0x68, 0x45, 0xe4, 0xe4, 0x2d, 0xa8, 0x8a, 0x3c, 0x4c, 0x86, 0x33, 0xdd,
	0x54, 0xe4, 0x0e, 0x92, 0x98, 0x92, 0x28, 0xeb, 0x1f, 0x95, 0xe5, 0x89, 0x6b, 0xf2, 0x03, 0x58,
	0x7f, 0xca, 0xb3, 0x94, 0x0f, 0xc2, 0x63, 0x9e, 0x61, 0x97, 0x97, 0x85, 0x5a, 0x63, 0x6b, 0x0a,
	0x7d, 0xa0, 0x40, 0xbc, 0x0c, 0x8f, 0x85, 0x28, 0x30, 0x28, 0xaa, 0xa7, 0x2d, 0x23, 0xe9, 0xc4,
	0x58, 0x5f, 0xc3, 0xa8, 0x7f, 0x94, 0xa4, 0x32, 0x60, 0xcb, 0xaa, 0x71, 0x68, 0xc4, 0x89, 0xb1,
	0xa9, 0xe5, 0xd2, 0xd6, 0x70, 0x8c, 0x17, 0x69, 0x45, 0xf2, 0x41, 0x41, 0xbd, 0x71, 0x12, 0x5b,
	0x05, 0xac, 0xa1, 0x43, 0x8c, 0xe7, 0x62, 0x9c, 0xf5, 0x79, 0x8e, 0x09, 0xe8, 0x8f, 0xc6, 0x61,
	0x5f, 0x8c, 0xd3, 0x42, 0x3f, 0x31, 0xd5, 0xfe, 0x68, 0xdc, 0x42, 0x9a, 0xbc, 0x03, 0xab, 0x43,
	0x3e, 0x14, 0xd9, 0x89, 0x8e, 0x94, 0x7a, 0x62, 0xeb, 0x0a, 0x93, 0x21, 0x22, 0x37, 0x61, 0x2d,
	0x2f, 0x44, 0x16, 0x1d, 0x96, 0xd1, 0x54, 0x8f, 0xee, 0xaa, 0x06, 0x55, 0x1c, 0xff, 0x58, 0x51,
	0x71, 0x6c, 0x89, 0x34, 0x4e, 0xb0, 0x5c, 0x73, 0xf2, 0x1e, 0x5c, 0xc8, 0x78, 0x14, 0x9f, 0xcc,
	0x17, 0xc9, 0x19, 0x31, 0xa6, 0x64, 0xc8, 0xfb, 0xb0, 0xac, 0xce, 0x94, 0x16, 0xbc, 0x56, 0x5a,
	0x0b, 0x61, 0xfd, 0xc5, 0x49, 0xfe, 0x54, 0x9a, 0xf2, 0x5a, 0x61, 0x29, 0x42, 0x7e, 0x04, 0x8b,
	0xa3, 0x44, 0x4d, 0x04, 0xaf, 0x95, 0x44, 0x09, 0xf2, 0xc1, 0xb4, 0x0b, 0x5d, 0x78, 0x93, 0xf0,
	0xa4, 0x39, 0xa1, 0x66, 0xa1, 0x52, 0xf4, 0x06, 0xcd, 0x22, 0xb6, 0xfe, 0xb0, 0x04, 0x75, 0x84,
	0xe9, 0xf3, 0x42, 0x56, 0xd8, 0xa4, 0x69, 0x1a, 0x33, 0x4d, 0x93, 0x7c, 0x0a, 0x20, 0x17, 0x61,
	0x71, 0x32, 0xe2, 0x3a, 0x0c, 0x6f, 0xcf, 0x6a, 0xd5, 0xdb, 0x77, 0x1f, 0xa0, 0x94, 0x9c, 0x8e,
	0x6a, 0xc7, 0xe5, 0x92, 0x7c, 0x02, 0x55, 0x31, 0xe2, 0x59, 0x54, 0x88, 0x4c, 0x47, 0xe5, 0xc6,
	0x79, 0x7b, 0x3d, 0x2d, 0xc3, 0x26, 0xd2, 0xe4, 0x36, 0x2c, 0x17, 0x51, 0x76, 0xc8, 0x0b, 0x1d,
	0xa3, 0x6b, 0xe7, 0xed, 0x0b, 0xa4, 0x04, 0xd3, 0x92, 0xea, 0xe5, 0xc5, 0x55, 0x88, 0xef, 0x81,
	0x2a, 0xe0, 0x9a, 0x42, 0xee, 0xf3, 0x13, 0xeb, 0x08, 0x6a, 0x13, 0x23, 0xc9, 0xdb, 0xf0, 0x96,
	0x1c, 0x81, 0xe8, 0x17, 0x81, 0x1a, 0x83, 0x82, 0x47, 0x07, 0x34, 0xf4, 0x03, 0xe6, 0xb8, 0xfb,
	0xe6, 0x02, 0x69, 0xc2, 0xb5, 0x73, 0xd8, 0x8e, 0x1b, 0xd0, 0x7d, 0xca, 0x4c, 0x83, 0xdc, 0x80,
	0xc6, 0x39, 0xfc, 0xbd, 0x8e, 0x67, 0x07, 0x66, 0xc5, 0x1a, 0x40, 0xb5, 0x74, 0xe9, 0x55, 0x4d,
	0xde, 0x01, 0x65, 0x76, 0xe0, 0xb1, 0xd0, 0xa7, 0xc1, 0x79, 0x27, 0x4d, 0xf8, 0x76, 0x1b, 0x3b,
	0xe4, 0x36, 0xdc, 0x78, 0x0d, 0xbf, 0xeb, 0xb8, 0x3d, 0xdf, 0xac, 0x58, 0x5d, 0x58, 0x56, 0x81,
	0x20, 0x37, 0x61, 0x6b, 0xce, 0x2a, 0x9b, 0xed, 0xd3, 0x20, 0xb4, 0x5d, 0xd7, 0x0b, 0xec, 0xc0,
	0x91, 0x5d, 0xf8, 0x55, 0xd7, 0x94, 0x50, 0xc7, 0xfe, 0x8c, 0xe2, 0x24, 0xf8, 0xd2, 0x50, 0x77,
	0x15, 0xdb, 0xe6, 0x38, 0xc7, 0x06, 0xf6, 0xf1, 0xe4, 0x76, 0x27, 0xe9, 0x13, 0x21, 0xeb, 0xa3,
	0x7e, 0xfb, 0xca, 0x6c, 0x42, 0xa6, 0x8d, 0xaa, 0xbc, 0xf5, 0xb2, 0xa4, 0x7e, 0x0a, 0xd5, 0x7e,
	0x34, 0x8a, 0xfa, 0x49, 0xa1, 0x6e, 0x50, 0xfd, 0x6c, 0x41, 0x4e, 0xba, 0x01, 0x9b, 0x88, 0x91,
	0x8f, 0x00, 0xfa, 0x93, 0xdb, 0x2a, 0x6b, 0x66, 0xee, 0xa8, 0xe9, 0x5d, 0x66, 0x33, 0x92, 0x64,
	0x17, 0xaa, 0xfc, 0x79, 0xa1, 0x0c, 0x5c, 0x92, 0xc3, 0xc4, 0xe6, 0x39, 0x15, 0xc3, 0x56, 0xb8,
	0x5a, 0x58, 0x26, 0xac, 0xfb, 0xaa, 0x55, 0x74, 0x92, 0x1c, 0xe7, 0x59, 0x8b, 0x81, 0xa9, 0x11,
	0x9a, 0xe6, 0xe3, 0x4c, 0x3e, 0xd6, 0x5b, 0x50, 0xcf, 0xf8, 0x50, 0x14, 0x3c, 0x94, 0x63, 0x97,
	0xba, 0x19, 0xa0, 0xa0, 0x83, 0xa8, 0x38, 0xc2, 0x92, 0x1b, 0x88, 0x7e, 0x34, 0x50, 0x7c, 0x3d,
	0x50, 0x49, 0x04, 0xd9, 0x33, 0x3a, 0xdb, 0x1c, 0x47, 0xfe, 0xff, 0x85, 0xce, 0xaf, 0x8d, 0x89,
	0xd2, 0x69, 0x8a, 0x76, 0x70, 0x72, 0x8b, 0x0a, 0xae, 0xdb, 0xda, 0xa5, 0xe9, 0xdb, 0x37, 0x11,
	0xe4, 0x4c, 0x89, 0xcc, 0x1b, 0x50, 0x79, 0xc5, 0x80, 0x2d, 0xa8, 0x0f, 0xb1, 0x0f, 0x87, 0x23,
	0x91, 0xa4, 0xe5, 0x98, 0x03, 0x12, 0x3a, 0x40, 0xc4, 0xea, 0xc0, 0xa5, 0x33, 0x16, 0x60, 0x08,
	0xd1, 0x8a, 0x0f, 0xa1, 0xaa, 0xfb, 0x6f, 0x2e, 0x07, 0x94, 0xfa, 0xed, 0xc6, 0x39, 0x86, 0x48,
	0x8b, 0xd9, 0x44, 0xd2, 0xda, 0x84, 0x8b, 0xad, 0x8c, 0xc7, 0x3c, 0x2d, 0x92, 0x68, 0x50, 0x66,
	0xe3, 0x32, 0x6c, 0x4e, 0xc1, 0x49, 0xf0, 0xac, 0x5f, 0xcc, 0xc2, 0xd3, 0x3c, 0xfd, 0x10, 0x36,
	0xf2, 0xfc, 0x28, 0x1c, 0x65, 0xc9, 0x71, 0x54, 0xf0, 0xb0, 0x1c, 0x07, 0x57, 0xd9, 0x5a, 0x9e,
	0x1f, 0x1d, 0x28, 0x14, 0x5b, 0xc0, 0xe7, 0xb3, 0xdb, 0xa7, 0xd1, 0xbb, 0x03, 0x57, 0xe6, 0xb6,
	0x87, 0xf9, 0x51, 0x74, 0xfb, 0xee, 0x47, 0x5a, 0xcb, 0xe6, 0x19, 0x2d, 0xbe, 0x64, 0xed, 0xfc,
	0x6b, 0x11, 0x56, 0xf4, 0x97, 0x29, 0x8e, 0x2b, 0xad, 0x6e, 0x3b, 0x6c, 0xdb, 0x81, 0x1d, 0xf6,
	0x0e, 0xfc, 0x80, 0x51, 0xbb, 0x6b, 0x2e, 0x94, 0xb0, 0x4f, 0x7d, 0xdf, 0xf1, 0xdc, 0xb0, 0xd5,
	0xf1, 0x7c, 0x6a, 0x5e, 0xc0, 0xb9, 0x08, 0x61, 0x46, 0x3f, 0xa7, 0xad, 0xc0, 0x5c, 0x26, 0x75,
	0x58, 0x41, 0xda, 0xa5, 0x81, 0x59, 0xc3, 0x11, 0x47, 0x32, 0x7b, 0x2e, 0x4e, 0x39, 0x26, 0x94,
	0x4a, 0xa6, 0x1f, 0x6c, 0xfb, 0x34, 0x30, 0xeb, 0x64, 0x15, 0xaa, 0x08, 0xd3, 0x2f, 0x68, 0xcb,
	0x5c, 0x2d, 0x55, 0xda, 0x41, 0x60, 0xb7, 0xee, 0x99, 0x6b, 0x25, 0xb7, 0xe3, 0xed, 0xfb, 0xe6,
	0x3a, 0x0e, 0x32, 0x48, 0x05, 0xc1, 0xa3, 0x90, 0x51, 0xdf, 0xf9, 0x92, 0x9a, 0x1b, 0xe4, 0x12,
	0x98, 0x88, 0xe1, 0x68, 0x15, 0xee, 0x79, 0xec, 0xa1, 0xcd, 0xda, 0xa6, 0x89, 0xf3, 0x18, 0xa2,
	0x5d, 0x1a, 0x30, 0xa7, 0xe5, 0x87, 0x2d, 0xcf, 0xdd, 0x73, 0xf6, 0xcd, 0xcb, 0xe4, 0x2a, 0x6c,
	0x9e, 0xc5, 0x3b, 0x1d, 0xb4, 0xfd, 0x0a, 0xd9, 0x84, 0x0d, 0x64, 0xb4, 0x18, 0x6d, 0x87, 0xd4,
	0xf5, 0x7b, 0x8c, 0x9a, 0x5b, 0xa5, 0x6e, 0x3f, 0xf0, 0x98, 0xbd, 0x4f, 0xc3, 0x8e, 0xe3, 0x07,
	0xe6, 0xbb, 0xa5, 0xee, 0x12, 0xd5, 0xd2, 0x3b, 0xf3, 0x78, 0x9b, 0x76, 0x68, 0x40, 0xcd, 0xf7,
	0xca, 0x33, 0x0f, 0x28, 0x73, 0x0e, 0xee, 0x51, 0x66, 0x77, 0x94, 0xa2, 0x3b, 0xe4, 0x2d, 0xb8,
	0x3c, 0xc7, 0xd0, 0xba, 0x3e, 0x3c, 0x87, 0xa5, 0xd5, 0xdd, 0x25, 0xd7, 0xe0, 0xca, 0x1c, 0x4b,
	0x75, 0x52, 0x6a, 0x7e, 0x44, 0x2c, 0x68, 0xce, 0xf1, 0xb4, 0x87, 0xa5, 0xc7, 0xe6, 0xc7, 0x3b,
	0xdf, 0x2c, 0xc2, 0x8a, 0xfe, 0x03, 0x00, 0xc3, 0xdb, 0xf5, 0xf7, 0x65, 0xbe, 0xcd, 0x05, 0x74,
	0xb7, 0xa4, 0xc2, 0x36, 0xdd, 0xb3, 0x7b, 0x1d, 0x6c, 0xec, 0x9b, 0xb0, 0x31, 0x41, 0xfd, 0xa0,
	0x8d, 0xf3, 0xea, 0x59, 0xd1, 0x52, 0xf5, 0x02, 0x7a, 0x8a, 0xa8, 0xaa, 0x1b, 0x0c, 0x7a, 0xe0,
	0xb8, 0x3d, 0xfa, 0xaa, 0x0e, 0xca, 0xf0, 0xed, 0x29, 0x0f, 0xf7, 0x5c, 0x2c, 0xa6, 0x35, 0xa8,
	0xa9, 0xbd, 0xe8, 0xc9, 0x72, 0x49, 0x52, 0xc6, 0x3c, 0x66, 0xae, 0x60, 0x69, 0x21, 0x39, 0x29,
	0x2d, 0x24, 0xa6, 0xa5, 0xa5, 0xd5, 0xcb, 0xd2, 0x42, 0x05, 0x3d, 0xdf, 0xac, 0x97, 0xa0, 0xcc,
	0xa8, 0x06, 0xb7, 0x30, 0x47, 0xea, 0x14, 0x95, 0x23, 0x8d, 0xbf, 0x4b, 0xae, 0xc3, 0xd5, 0x57,
	0x71, 0x95, 0xa7, 0x1d, 0x4c, 0x06, 0x32, 0x67, 0xa2, 0xaa, 0xf7, 0xdd, 0xc1, 0x47, 0xe8, 0x5c,
	0x96, 0xda, 0xfa, 0x21, 0xbe, 0x64, 0x73, 0x7c, 0x95, 0x2c, 0xbc, 0x46, 0x8c, 0xfa, 0x18, 0xe1,
	0xbb, 0xd7, 0x2a, 0xa6, 0xb1, 0xf3, 0x17, 0x03, 0x36, 0xe6, 0xfe, 0x70, 0xc0, 0xb7, 0x7d, 0x32,
	0xb7, 0xab, 0x4b, 0xa6, 0xb6, 0xd9, 0xbe, 0x7c, 0x00, 0xaf, 0xc3, 0xd5, 0x29, 0x5a, 0xca, 0x1d,
	0x30, 0x2f, 0xf0, 0x4c, 0x83, 0x6c, 0xc1, 0xf5, 0x29, 0xb3, 0xfc, 0x2c, 0x69, 0x79, 0xae, 0x4b,
	0x5b, 0xf8, 0x09, 0x52, 0x41, 0xcb, 0x66, 0x77, 0x3b, 0x81, 0x83, 0xd5, 0x72, 0x8f, 0xb6, 0xee,
	0x87, 0x7b, 0xb6, 0xd3, 0xc1, 0x32, 0x5c, 0x9c, 0x17, 0x0a, 0x28, 0x73, 0xd1, 0x45, 0xca, 0x1e,
	0x50, 0xa6, 0x73, 0xb3, 0xb4, 0xc3, 0xd5, 0x3b, 0x3b, 0x79, 0xd0, 0xb0, 0x42, 0x65, 0x2a, 0x5a,
	0x9e, 0xdb, 0x76, 0xe4, 0xd6, 0x9e, 0x7b, 0xdf, 0xf5, 0x1e, 0xa2, 0xd1, 0xaf, 0xf2, 0xee, 0x51,
	0xbb, 0x13, 0xdc, 0x7b, 0x34, 0x33, 0x8c, 0xcc, 0xee, 0x2b, 0xb9, 0x95, 0x9d, 0x5f, 0xc3, 0xea,
	0xec, 0x2b, 0x40, 0x1a, 0x70, 0x69, 0x36, 0x5d, 0x14, 0x0f, 0xf1, 0xdc, 0x87, 0x2a, 0x30, 0xf3,
	0x9c, 0xae, 0xd7, 0x73, 0xd1, 0x6f, 0x03, 0x93, 0x79, 0x96, 0x59, 0xb2, 0x2a, 0x9f, 0x3d, 0xfc,
	0xf6, 0x45, 0x73, 0xe1, 0xbb, 0x17, 0xcd, 0x85, 0xef, 0x5f, 0x34, 0x8d, 0xaf, 0x4f, 0x9b, 0xc6,
	0x9f, 0x4e, 0x9b, 0xc6, 0x5f, 0x4f, 0x9b, 0xc6, 0xb7, 0xa7, 0x4d, 0xe3, 0x1f, 0xa7, 0x4d, 0xe3,
	0x9f, 0xa7, 0xcd, 0x85, 0xef, 0x4f, 0x9b, 0xc6, 0xef, 0x5f, 0x36, 0x17, 0xbe, 0x7d, 0xd9, 0x5c,
	0xf8, 0xee, 0x65, 0x73, 0xe1, 0xcb, 0x77, 0xa2, 0xec, 0x28, 0x2a, 0x76, 0x63, 0x7e, 0xfc, 0x81,
	0x7a, 0x23, 0xde, 0x97, 0x7f, 0x0a, 0x6a, 0xe2, 0x50, 0x8c, 0x1e, 0x3f, 0x5e, 0x96, 0xc8, 0x9d,
	0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0xa0, 0xb0, 0x00, 0xca, 0x35, 0x14, 0x00, 0x00,
}

func (x CmdType) String() string {
	s, ok := CmdType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MsgType) String() string {
	s, ok := MsgType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RejectionReason) String() string {
	s, ok := RejectionReason_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NodeCondition) String() string {
	s, ok := NodeCondition_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x StorageState) String() string {
	s, ok := StorageState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NodeInfoGetCmd_Kind) String() string {
	s, ok := NodeInfoGetCmd_Kind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ErrorMsg_Kind) String() string {
	s, ok := ErrorMsg_Kind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x StateMsg_Kind) String() string {
	s, ok := StateMsg_Kind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NodeExtInfo_ValueType) String() string {
	s, ok := NodeExtInfo_ValueType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NodeExtInfo_Operator) String() string {
	s, ok := NodeExtInfo_Operator_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NodeExtInfo_Target) String() string {
	s, ok := NodeExtInfo_Target_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Cmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Cmd)
	if !ok {
		that2, ok := that.(Cmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Sid != that1.Sid {
		return false
	}
	if this.Seq != that1.Seq {
		return false
	}
	if this.Completed != that1.Completed {
		return false
	}
	if !bytes.Equal(this.Payload, that1.Payload) {
		return false
	}
	return true
}
func (this *Msg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg)
	if !ok {
		that2, ok := that.(Msg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Sid != that1.Sid {
		return false
	}
	if this.Seq != that1.Seq {
		return false
	}
	if this.Completed != that1.Completed {
		return false
	}
	if !bytes.Equal(this.Payload, that1.Payload) {
		return false
	}
	return true
}
func (this *NodeInfoGetCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInfoGetCmd)
	if !ok {
		that2, ok := that.(NodeInfoGetCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	return true
}
func (this *SessionCloseCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SessionCloseCmd)
	if !ok {
		that2, ok := that.(SessionCloseCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Sid != that1.Sid {
		return false
	}
	return true
}
func (this *RejectCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RejectCmd)
	if !ok {
		that2, ok := that.(RejectCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *NetworkCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkCmd)
	if !ok {
		that2, ok := that.(NetworkCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.AbbotRequestBytes, that1.AbbotRequestBytes) {
		return false
	}
	return true
}
func (this *LogsCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogsCmd)
	if !ok {
		that2, ok := that.(LogsCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.Container != that1.Container {
		return false
	}
	if this.Follow != that1.Follow {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Since != that1.Since {
		return false
	}
	if this.TailLines != that1.TailLines {
		return false
	}
	if this.BytesLimit != that1.BytesLimit {
		return false
	}
	if this.Previous != that1.Previous {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	return true
}
func (this *ExecOrAttachCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecOrAttachCmd)
	if !ok {
		that2, ok := that.(ExecOrAttachCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.Container != that1.Container {
		return false
	}
	if this.Stdin != that1.Stdin {
		return false
	}
	if this.Stdout != that1.Stdout {
		return false
	}
	if this.Stderr != that1.Stderr {
		return false
	}
	if this.Tty != that1.Tty {
		return false
	}
	if len(this.Command) != len(that1.Command) {
		return false
	}
	for i := range this.Command {
		if this.Command[i] != that1.Command[i] {
			return false
		}
	}
	if len(this.Envs) != len(that1.Envs) {
		return false
	}
	for i := range this.Envs {
		if this.Envs[i] != that1.Envs[i] {
			return false
		}
	}
	return true
}
func (this *PortForwardCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortForwardCmd)
	if !ok {
		that2, ok := that.(PortForwardCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.Network != that1.Network {
		return false
	}
	if this.Host != that1.Host {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	return true
}
func (this *TerminalResizeCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TerminalResizeCmd)
	if !ok {
		that2, ok := that.(TerminalResizeCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Cols != that1.Cols {
		return false
	}
	if this.Rows != that1.Rows {
		return false
	}
	return true
}
func (this *MetricsConfigCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricsConfigCmd)
	if !ok {
		that2, ok := that.(MetricsConfigCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Collect) != len(that1.Collect) {
		return false
	}
	for i := range this.Collect {
		if this.Collect[i] != that1.Collect[i] {
			return false
		}
	}
	if len(this.ExtraArgs) != len(that1.ExtraArgs) {
		return false
	}
	for i := range this.ExtraArgs {
		if this.ExtraArgs[i] != that1.ExtraArgs[i] {
			return false
		}
	}
	return true
}
func (this *ErrorMsg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ErrorMsg)
	if !ok {
		that2, ok := that.(ErrorMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	return true
}
func (this *StateMsg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StateMsg)
	if !ok {
		that2, ok := that.(StateMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.DeviceId != that1.DeviceId {
		return false
	}
	return true
}
func (this *NetworkMsg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkMsg)
	if !ok {
		that2, ok := that.(NetworkMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.AbbotResponseBytes, that1.AbbotResponseBytes) {
		return false
	}
	return true
}
func (this *NodeSystemInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeSystemInfo)
	if !ok {
		that2, ok := that.(NodeSystemInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Os != that1.Os {
		return false
	}
	if this.OsImage != that1.OsImage {
		return false
	}
	if this.Arch != that1.Arch {
		return false
	}
	if this.KernelVersion != that1.KernelVersion {
		return false
	}
	if this.BootId != that1.BootId {
		return false
	}
	if this.MachineId != that1.MachineId {
		return false
	}
	if this.SystemUuid != that1.SystemUuid {
		return false
	}
	return true
}
func (this *NodeResources) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeResources)
	if !ok {
		that2, ok := that.(NodeResources)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CpuCount != that1.CpuCount {
		return false
	}
	if this.MemoryBytes != that1.MemoryBytes {
		return false
	}
	if this.StorageBytes != that1.StorageBytes {
		return false
	}
	return true
}
func (this *NodeConditions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeConditions)
	if !ok {
		that2, ok := that.(NodeConditions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ready != that1.Ready {
		return false
	}
	if this.Memory != that1.Memory {
		return false
	}
	if this.Disk != that1.Disk {
		return false
	}
	if this.Pid != that1.Pid {
		return false
	}
	if this.Network != that1.Network {
		return false
	}
	if this.Pod != that1.Pod {
		return false
	}
	return true
}
func (this *NodeExtInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeExtInfo)
	if !ok {
		that2, ok := that.(NodeExtInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.ValueType != that1.ValueType {
		return false
	}
	if this.Operator != that1.Operator {
		return false
	}
	if this.Target != that1.Target {
		return false
	}
	if this.TargetKey != that1.TargetKey {
		return false
	}
	return true
}
func (this *NodeStatusMsg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeStatusMsg)
	if !ok {
		that2, ok := that.(NodeStatusMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SystemInfo.Equal(that1.SystemInfo) {
		return false
	}
	if !this.Capacity.Equal(that1.Capacity) {
		return false
	}
	if !this.Conditions.Equal(that1.Conditions) {
		return false
	}
	if len(this.ExtInfo) != len(that1.ExtInfo) {
		return false
	}
	for i := range this.ExtInfo {
		if !this.ExtInfo[i].Equal(that1.ExtInfo[i]) {
			return false
		}
	}
	return true
}
func (this *StorageListCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageListCmd)
	if !ok {
		that2, ok := that.(StorageListCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *StorageEnsureCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageEnsureCmd)
	if !ok {
		that2, ok := that.(StorageEnsureCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RemotePath != that1.RemotePath {
		return false
	}
	if this.LocalPath != that1.LocalPath {
		return false
	}
	return true
}
func (this *StorageDeleteCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDeleteCmd)
	if !ok {
		that2, ok := that.(StorageDeleteCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RemotePath != that1.RemotePath {
		return false
	}
	if this.LocalPath != that1.LocalPath {
		return false
	}
	return true
}
func (this *StorageStatusMsg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageStatusMsg)
	if !ok {
		that2, ok := that.(StorageStatusMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.RemotePath != that1.RemotePath {
		return false
	}
	if this.MountPoint != that1.MountPoint {
		return false
	}
	return true
}
func (this *StorageStatusListMsg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageStatusListMsg)
	if !ok {
		that2, ok := that.(StorageStatusListMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Storages) != len(that1.Storages) {
		return false
	}
	for i := range this.Storages {
		if !this.Storages[i].Equal(that1.Storages[i]) {
			return false
		}
	}
	return true
}
func (this *CredentialListCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CredentialListCmd)
	if !ok {
		that2, ok := that.(CredentialListCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *CredentialDeleteCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CredentialDeleteCmd)
	if !ok {
		that2, ok := that.(CredentialDeleteCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *CredentialEnsureCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CredentialEnsureCmd)
	if !ok {
		that2, ok := that.(CredentialEnsureCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.SshPrivateKey, that1.SshPrivateKey) {
		return false
	}
	return true
}
func (this *CredentialStatusMsg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CredentialStatusMsg)
	if !ok {
		that2, ok := that.(CredentialStatusMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.SshPrivateKeySha256, that1.SshPrivateKeySha256) {
		return false
	}
	return true
}
func (this *Cmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&aranyagopb.Cmd{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Sid: "+fmt.Sprintf("%#v", this.Sid)+",\n")
	s = append(s, "Seq: "+fmt.Sprintf("%#v", this.Seq)+",\n")
	s = append(s, "Completed: "+fmt.Sprintf("%#v", this.Completed)+",\n")
	s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Msg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&aranyagopb.Msg{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Sid: "+fmt.Sprintf("%#v", this.Sid)+",\n")
	s = append(s, "Seq: "+fmt.Sprintf("%#v", this.Seq)+",\n")
	s = append(s, "Completed: "+fmt.Sprintf("%#v", this.Completed)+",\n")
	s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeInfoGetCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.NodeInfoGetCmd{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SessionCloseCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.SessionCloseCmd{")
	s = append(s, "Sid: "+fmt.Sprintf("%#v", this.Sid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RejectCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aranyagopb.RejectCmd{")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.NetworkCmd{")
	s = append(s, "AbbotRequestBytes: "+fmt.Sprintf("%#v", this.AbbotRequestBytes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LogsCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&aranyagopb.LogsCmd{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Container: "+fmt.Sprintf("%#v", this.Container)+",\n")
	s = append(s, "Follow: "+fmt.Sprintf("%#v", this.Follow)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Since: "+fmt.Sprintf("%#v", this.Since)+",\n")
	s = append(s, "TailLines: "+fmt.Sprintf("%#v", this.TailLines)+",\n")
	s = append(s, "BytesLimit: "+fmt.Sprintf("%#v", this.BytesLimit)+",\n")
	s = append(s, "Previous: "+fmt.Sprintf("%#v", this.Previous)+",\n")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecOrAttachCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&aranyagopb.ExecOrAttachCmd{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Container: "+fmt.Sprintf("%#v", this.Container)+",\n")
	s = append(s, "Stdin: "+fmt.Sprintf("%#v", this.Stdin)+",\n")
	s = append(s, "Stdout: "+fmt.Sprintf("%#v", this.Stdout)+",\n")
	s = append(s, "Stderr: "+fmt.Sprintf("%#v", this.Stderr)+",\n")
	s = append(s, "Tty: "+fmt.Sprintf("%#v", this.Tty)+",\n")
	s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	keysForEnvs := make([]string, 0, len(this.Envs))
	for k, _ := range this.Envs {
		keysForEnvs = append(keysForEnvs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEnvs)
	mapStringForEnvs := "map[string]string{"
	for _, k := range keysForEnvs {
		mapStringForEnvs += fmt.Sprintf("%#v: %#v,", k, this.Envs[k])
	}
	mapStringForEnvs += "}"
	if this.Envs != nil {
		s = append(s, "Envs: "+mapStringForEnvs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortForwardCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&aranyagopb.PortForwardCmd{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	s = append(s, "Host: "+fmt.Sprintf("%#v", this.Host)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TerminalResizeCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aranyagopb.TerminalResizeCmd{")
	s = append(s, "Cols: "+fmt.Sprintf("%#v", this.Cols)+",\n")
	s = append(s, "Rows: "+fmt.Sprintf("%#v", this.Rows)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricsConfigCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aranyagopb.MetricsConfigCmd{")
	s = append(s, "Collect: "+fmt.Sprintf("%#v", this.Collect)+",\n")
	s = append(s, "ExtraArgs: "+fmt.Sprintf("%#v", this.ExtraArgs)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ErrorMsg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&aranyagopb.ErrorMsg{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StateMsg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aranyagopb.StateMsg{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "DeviceId: "+fmt.Sprintf("%#v", this.DeviceId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkMsg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.NetworkMsg{")
	s = append(s, "AbbotResponseBytes: "+fmt.Sprintf("%#v", this.AbbotResponseBytes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeSystemInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&aranyagopb.NodeSystemInfo{")
	s = append(s, "Os: "+fmt.Sprintf("%#v", this.Os)+",\n")
	s = append(s, "OsImage: "+fmt.Sprintf("%#v", this.OsImage)+",\n")
	s = append(s, "Arch: "+fmt.Sprintf("%#v", this.Arch)+",\n")
	s = append(s, "KernelVersion: "+fmt.Sprintf("%#v", this.KernelVersion)+",\n")
	s = append(s, "BootId: "+fmt.Sprintf("%#v", this.BootId)+",\n")
	s = append(s, "MachineId: "+fmt.Sprintf("%#v", this.MachineId)+",\n")
	s = append(s, "SystemUuid: "+fmt.Sprintf("%#v", this.SystemUuid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeResources) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&aranyagopb.NodeResources{")
	s = append(s, "CpuCount: "+fmt.Sprintf("%#v", this.CpuCount)+",\n")
	s = append(s, "MemoryBytes: "+fmt.Sprintf("%#v", this.MemoryBytes)+",\n")
	s = append(s, "StorageBytes: "+fmt.Sprintf("%#v", this.StorageBytes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeConditions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&aranyagopb.NodeConditions{")
	s = append(s, "Ready: "+fmt.Sprintf("%#v", this.Ready)+",\n")
	s = append(s, "Memory: "+fmt.Sprintf("%#v", this.Memory)+",\n")
	s = append(s, "Disk: "+fmt.Sprintf("%#v", this.Disk)+",\n")
	s = append(s, "Pid: "+fmt.Sprintf("%#v", this.Pid)+",\n")
	s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	s = append(s, "Pod: "+fmt.Sprintf("%#v", this.Pod)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeExtInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&aranyagopb.NodeExtInfo{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "ValueType: "+fmt.Sprintf("%#v", this.ValueType)+",\n")
	s = append(s, "Operator: "+fmt.Sprintf("%#v", this.Operator)+",\n")
	s = append(s, "Target: "+fmt.Sprintf("%#v", this.Target)+",\n")
	s = append(s, "TargetKey: "+fmt.Sprintf("%#v", this.TargetKey)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeStatusMsg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&aranyagopb.NodeStatusMsg{")
	if this.SystemInfo != nil {
		s = append(s, "SystemInfo: "+fmt.Sprintf("%#v", this.SystemInfo)+",\n")
	}
	if this.Capacity != nil {
		s = append(s, "Capacity: "+fmt.Sprintf("%#v", this.Capacity)+",\n")
	}
	if this.Conditions != nil {
		s = append(s, "Conditions: "+fmt.Sprintf("%#v", this.Conditions)+",\n")
	}
	if this.ExtInfo != nil {
		s = append(s, "ExtInfo: "+fmt.Sprintf("%#v", this.ExtInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageListCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&aranyagopb.StorageListCmd{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageEnsureCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aranyagopb.StorageEnsureCmd{")
	s = append(s, "RemotePath: "+fmt.Sprintf("%#v", this.RemotePath)+",\n")
	s = append(s, "LocalPath: "+fmt.Sprintf("%#v", this.LocalPath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDeleteCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aranyagopb.StorageDeleteCmd{")
	s = append(s, "RemotePath: "+fmt.Sprintf("%#v", this.RemotePath)+",\n")
	s = append(s, "LocalPath: "+fmt.Sprintf("%#v", this.LocalPath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageStatusMsg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&aranyagopb.StorageStatusMsg{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "RemotePath: "+fmt.Sprintf("%#v", this.RemotePath)+",\n")
	s = append(s, "MountPoint: "+fmt.Sprintf("%#v", this.MountPoint)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageStatusListMsg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.StorageStatusListMsg{")
	if this.Storages != nil {
		s = append(s, "Storages: "+fmt.Sprintf("%#v", this.Storages)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CredentialListCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&aranyagopb.CredentialListCmd{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CredentialDeleteCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&aranyagopb.CredentialDeleteCmd{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CredentialEnsureCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.CredentialEnsureCmd{")
	s = append(s, "SshPrivateKey: "+fmt.Sprintf("%#v", this.SshPrivateKey)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CredentialStatusMsg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.CredentialStatusMsg{")
	s = append(s, "SshPrivateKeySha256: "+fmt.Sprintf("%#v", this.SshPrivateKeySha256)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringProto(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Cmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Completed {
		i--
		if m.Completed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Seq != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x18
	}
	if m.Sid != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x10
	}
	if m.Kind != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Msg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Msg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Completed {
		i--
		if m.Completed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Seq != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x18
	}
	if m.Sid != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x10
	}
	if m.Kind != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeInfoGetCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfoGetCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfoGetCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionCloseCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionCloseCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionCloseCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sid != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RejectCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RejectCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RejectCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Reason != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Reason))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetworkCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AbbotRequestBytes) > 0 {
		i -= len(m.AbbotRequestBytes)
		copy(dAtA[i:], m.AbbotRequestBytes)
		i = encodeVarintProto(dAtA, i, uint64(len(m.AbbotRequestBytes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogsCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogsCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogsCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Previous {
		i--
		if m.Previous {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.BytesLimit != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.BytesLimit))
		i--
		dAtA[i] = 0x38
	}
	if m.TailLines != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.TailLines))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Since) > 0 {
		i -= len(m.Since)
		copy(dAtA[i:], m.Since)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Since)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Timestamp {
		i--
		if m.Timestamp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Follow {
		i--
		if m.Follow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Container) > 0 {
		i -= len(m.Container)
		copy(dAtA[i:], m.Container)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Container)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PodUid) > 0 {
		i -= len(m.PodUid)
		copy(dAtA[i:], m.PodUid)
		i = encodeVarintProto(dAtA, i, uint64(len(m.PodUid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecOrAttachCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecOrAttachCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecOrAttachCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Envs) > 0 {
		for k := range m.Envs {
			v := m.Envs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintProto(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintProto(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintProto(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Command) > 0 {
		for iNdEx := len(m.Command) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Command[iNdEx])
			copy(dAtA[i:], m.Command[iNdEx])
			i = encodeVarintProto(dAtA, i, uint64(len(m.Command[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Tty {
		i--
		if m.Tty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Stderr {
		i--
		if m.Stderr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Stdout {
		i--
		if m.Stdout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Stdin {
		i--
		if m.Stdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Container) > 0 {
		i -= len(m.Container)
		copy(dAtA[i:], m.Container)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Container)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PodUid) > 0 {
		i -= len(m.PodUid)
		copy(dAtA[i:], m.PodUid)
		i = encodeVarintProto(dAtA, i, uint64(len(m.PodUid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PortForwardCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortForwardCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortForwardCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Network) > 0 {
		i -= len(m.Network)
		copy(dAtA[i:], m.Network)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Network)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PodUid) > 0 {
		i -= len(m.PodUid)
		copy(dAtA[i:], m.PodUid)
		i = encodeVarintProto(dAtA, i, uint64(len(m.PodUid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TerminalResizeCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TerminalResizeCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TerminalResizeCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rows != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Rows))
		i--
		dAtA[i] = 0x10
	}
	if m.Cols != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Cols))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MetricsConfigCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricsConfigCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricsConfigCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExtraArgs) > 0 {
		for iNdEx := len(m.ExtraArgs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExtraArgs[iNdEx])
			copy(dAtA[i:], m.ExtraArgs[iNdEx])
			i = encodeVarintProto(dAtA, i, uint64(len(m.ExtraArgs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Collect) > 0 {
		for iNdEx := len(m.Collect) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Collect[iNdEx])
			copy(dAtA[i:], m.Collect[iNdEx])
			i = encodeVarintProto(dAtA, i, uint64(len(m.Collect[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ErrorMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ErrorMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.Kind != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintProto(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Kind != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetworkMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AbbotResponseBytes) > 0 {
		i -= len(m.AbbotResponseBytes)
		copy(dAtA[i:], m.AbbotResponseBytes)
		i = encodeVarintProto(dAtA, i, uint64(len(m.AbbotResponseBytes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeSystemInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeSystemInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeSystemInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SystemUuid) > 0 {
		i -= len(m.SystemUuid)
		copy(dAtA[i:], m.SystemUuid)
		i = encodeVarintProto(dAtA, i, uint64(len(m.SystemUuid)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MachineId) > 0 {
		i -= len(m.MachineId)
		copy(dAtA[i:], m.MachineId)
		i = encodeVarintProto(dAtA, i, uint64(len(m.MachineId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.BootId) > 0 {
		i -= len(m.BootId)
		copy(dAtA[i:], m.BootId)
		i = encodeVarintProto(dAtA, i, uint64(len(m.BootId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.KernelVersion) > 0 {
		i -= len(m.KernelVersion)
		copy(dAtA[i:], m.KernelVersion)
		i = encodeVarintProto(dAtA, i, uint64(len(m.KernelVersion)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Arch) > 0 {
		i -= len(m.Arch)
		copy(dAtA[i:], m.Arch)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Arch)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OsImage) > 0 {
		i -= len(m.OsImage)
		copy(dAtA[i:], m.OsImage)
		i = encodeVarintProto(dAtA, i, uint64(len(m.OsImage)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Os) > 0 {
		i -= len(m.Os)
		copy(dAtA[i:], m.Os)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Os)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeResources) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeResources) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeResources) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StorageBytes != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.StorageBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.MemoryBytes != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.MemoryBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.CpuCount != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.CpuCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeConditions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeConditions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeConditions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pod != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Pod))
		i--
		dAtA[i] = 0x30
	}
	if m.Network != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Network))
		i--
		dAtA[i] = 0x28
	}
	if m.Pid != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x20
	}
	if m.Disk != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Disk))
		i--
		dAtA[i] = 0x18
	}
	if m.Memory != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x10
	}
	if m.Ready != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Ready))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeExtInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeExtInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeExtInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TargetKey) > 0 {
		i -= len(m.TargetKey)
		copy(dAtA[i:], m.TargetKey)
		i = encodeVarintProto(dAtA, i, uint64(len(m.TargetKey)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Target != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Target))
		i--
		dAtA[i] = 0x20
	}
	if m.Operator != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Operator))
		i--
		dAtA[i] = 0x18
	}
	if m.ValueType != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.ValueType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeStatusMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeStatusMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeStatusMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExtInfo) > 0 {
		for iNdEx := len(m.ExtInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExtInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProto(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Conditions != nil {
		{
			size, err := m.Conditions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProto(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Capacity != nil {
		{
			size, err := m.Capacity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProto(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SystemInfo != nil {
		{
			size, err := m.SystemInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProto(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageListCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageListCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageListCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *StorageEnsureCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageEnsureCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageEnsureCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LocalPath) > 0 {
		i -= len(m.LocalPath)
		copy(dAtA[i:], m.LocalPath)
		i = encodeVarintProto(dAtA, i, uint64(len(m.LocalPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RemotePath) > 0 {
		i -= len(m.RemotePath)
		copy(dAtA[i:], m.RemotePath)
		i = encodeVarintProto(dAtA, i, uint64(len(m.RemotePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageDeleteCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDeleteCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDeleteCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LocalPath) > 0 {
		i -= len(m.LocalPath)
		copy(dAtA[i:], m.LocalPath)
		i = encodeVarintProto(dAtA, i, uint64(len(m.LocalPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RemotePath) > 0 {
		i -= len(m.RemotePath)
		copy(dAtA[i:], m.RemotePath)
		i = encodeVarintProto(dAtA, i, uint64(len(m.RemotePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageStatusMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageStatusMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageStatusMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MountPoint) > 0 {
		i -= len(m.MountPoint)
		copy(dAtA[i:], m.MountPoint)
		i = encodeVarintProto(dAtA, i, uint64(len(m.MountPoint)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RemotePath) > 0 {
		i -= len(m.RemotePath)
		copy(dAtA[i:], m.RemotePath)
		i = encodeVarintProto(dAtA, i, uint64(len(m.RemotePath)))
		i--
		dAtA[i] = 0x12
	}
	if m.State != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StorageStatusListMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageStatusListMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageStatusListMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Storages) > 0 {
		for iNdEx := len(m.Storages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Storages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProto(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CredentialListCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CredentialListCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CredentialListCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CredentialDeleteCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CredentialDeleteCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CredentialDeleteCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CredentialEnsureCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CredentialEnsureCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CredentialEnsureCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SshPrivateKey) > 0 {
		i -= len(m.SshPrivateKey)
		copy(dAtA[i:], m.SshPrivateKey)
		i = encodeVarintProto(dAtA, i, uint64(len(m.SshPrivateKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CredentialStatusMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CredentialStatusMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CredentialStatusMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SshPrivateKeySha256) > 0 {
		i -= len(m.SshPrivateKeySha256)
		copy(dAtA[i:], m.SshPrivateKeySha256)
		i = encodeVarintProto(dAtA, i, uint64(len(m.SshPrivateKeySha256)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintProto(dAtA []byte, offset int, v uint64) int {
	offset -= sovProto(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Cmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovProto(uint64(m.Kind))
	}
	if m.Sid != 0 {
		n += 1 + sovProto(uint64(m.Sid))
	}
	if m.Seq != 0 {
		n += 1 + sovProto(uint64(m.Seq))
	}
	if m.Completed {
		n += 2
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *Msg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovProto(uint64(m.Kind))
	}
	if m.Sid != 0 {
		n += 1 + sovProto(uint64(m.Sid))
	}
	if m.Seq != 0 {
		n += 1 + sovProto(uint64(m.Seq))
	}
	if m.Completed {
		n += 2
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *NodeInfoGetCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovProto(uint64(m.Kind))
	}
	return n
}

func (m *SessionCloseCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sid != 0 {
		n += 1 + sovProto(uint64(m.Sid))
	}
	return n
}

func (m *RejectCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reason != 0 {
		n += 1 + sovProto(uint64(m.Reason))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *NetworkCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AbbotRequestBytes)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *LogsCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	if m.Follow {
		n += 2
	}
	if m.Timestamp {
		n += 2
	}
	l = len(m.Since)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	if m.TailLines != 0 {
		n += 1 + sovProto(uint64(m.TailLines))
	}
	if m.BytesLimit != 0 {
		n += 1 + sovProto(uint64(m.BytesLimit))
	}
	if m.Previous {
		n += 2
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *ExecOrAttachCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	if m.Stdin {
		n += 2
	}
	if m.Stdout {
		n += 2
	}
	if m.Stderr {
		n += 2
	}
	if m.Tty {
		n += 2
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovProto(uint64(l))
		}
	}
	if len(m.Envs) > 0 {
		for k, v := range m.Envs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovProto(uint64(len(k))) + 1 + len(v) + sovProto(uint64(len(v)))
			n += mapEntrySize + 1 + sovProto(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PortForwardCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovProto(uint64(m.Port))
	}
	return n
}

func (m *TerminalResizeCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cols != 0 {
		n += 1 + sovProto(uint64(m.Cols))
	}
	if m.Rows != 0 {
		n += 1 + sovProto(uint64(m.Rows))
	}
	return n
}

func (m *MetricsConfigCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Collect) > 0 {
		for _, s := range m.Collect {
			l = len(s)
			n += 1 + l + sovProto(uint64(l))
		}
	}
	if len(m.ExtraArgs) > 0 {
		for _, s := range m.ExtraArgs {
			l = len(s)
			n += 1 + l + sovProto(uint64(l))
		}
	}
	return n
}

func (m *ErrorMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovProto(uint64(m.Kind))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovProto(uint64(m.Code))
	}
	return n
}

func (m *StateMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovProto(uint64(m.Kind))
	}
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *NetworkMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AbbotResponseBytes)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *NodeSystemInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Os)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.OsImage)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.Arch)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.KernelVersion)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.BootId)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.MachineId)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.SystemUuid)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *NodeResources) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuCount != 0 {
		n += 1 + sovProto(uint64(m.CpuCount))
	}
	if m.MemoryBytes != 0 {
		n += 1 + sovProto(uint64(m.MemoryBytes))
	}
	if m.StorageBytes != 0 {
		n += 1 + sovProto(uint64(m.StorageBytes))
	}
	return n
}

func (m *NodeConditions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ready != 0 {
		n += 1 + sovProto(uint64(m.Ready))
	}
	if m.Memory != 0 {
		n += 1 + sovProto(uint64(m.Memory))
	}
	if m.Disk != 0 {
		n += 1 + sovProto(uint64(m.Disk))
	}
	if m.Pid != 0 {
		n += 1 + sovProto(uint64(m.Pid))
	}
	if m.Network != 0 {
		n += 1 + sovProto(uint64(m.Network))
	}
	if m.Pod != 0 {
		n += 1 + sovProto(uint64(m.Pod))
	}
	return n
}

func (m *NodeExtInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	if m.ValueType != 0 {
		n += 1 + sovProto(uint64(m.ValueType))
	}
	if m.Operator != 0 {
		n += 1 + sovProto(uint64(m.Operator))
	}
	if m.Target != 0 {
		n += 1 + sovProto(uint64(m.Target))
	}
	l = len(m.TargetKey)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *NodeStatusMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SystemInfo != nil {
		l = m.SystemInfo.Size()
		n += 1 + l + sovProto(uint64(l))
	}
	if m.Capacity != nil {
		l = m.Capacity.Size()
		n += 1 + l + sovProto(uint64(l))
	}
	if m.Conditions != nil {
		l = m.Conditions.Size()
		n += 1 + l + sovProto(uint64(l))
	}
	if len(m.ExtInfo) > 0 {
		for _, e := range m.ExtInfo {
			l = e.Size()
			n += 1 + l + sovProto(uint64(l))
		}
	}
	return n
}

func (m *StorageListCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *StorageEnsureCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RemotePath)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.LocalPath)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *StorageDeleteCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RemotePath)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.LocalPath)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *StorageStatusMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovProto(uint64(m.State))
	}
	l = len(m.RemotePath)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.MountPoint)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *StorageStatusListMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Storages) > 0 {
		for _, e := range m.Storages {
			l = e.Size()
			n += 1 + l + sovProto(uint64(l))
		}
	}
	return n
}

func (m *CredentialListCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CredentialDeleteCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CredentialEnsureCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SshPrivateKey)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *CredentialStatusMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SshPrivateKeySha256)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func sovProto(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProto(x uint64) (n int) {
	return sovProto(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Cmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Cmd{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Sid:` + fmt.Sprintf("%v", this.Sid) + `,`,
		`Seq:` + fmt.Sprintf("%v", this.Seq) + `,`,
		`Completed:` + fmt.Sprintf("%v", this.Completed) + `,`,
		`Payload:` + fmt.Sprintf("%v", this.Payload) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Msg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Msg{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Sid:` + fmt.Sprintf("%v", this.Sid) + `,`,
		`Seq:` + fmt.Sprintf("%v", this.Seq) + `,`,
		`Completed:` + fmt.Sprintf("%v", this.Completed) + `,`,
		`Payload:` + fmt.Sprintf("%v", this.Payload) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInfoGetCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInfoGetCmd{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SessionCloseCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SessionCloseCmd{`,
		`Sid:` + fmt.Sprintf("%v", this.Sid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RejectCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RejectCmd{`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkCmd{`,
		`AbbotRequestBytes:` + fmt.Sprintf("%v", this.AbbotRequestBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LogsCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LogsCmd{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Container:` + fmt.Sprintf("%v", this.Container) + `,`,
		`Follow:` + fmt.Sprintf("%v", this.Follow) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Since:` + fmt.Sprintf("%v", this.Since) + `,`,
		`TailLines:` + fmt.Sprintf("%v", this.TailLines) + `,`,
		`BytesLimit:` + fmt.Sprintf("%v", this.BytesLimit) + `,`,
		`Previous:` + fmt.Sprintf("%v", this.Previous) + `,`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExecOrAttachCmd) String() string {
	if this == nil {
		return "nil"
	}
	keysForEnvs := make([]string, 0, len(this.Envs))
	for k, _ := range this.Envs {
		keysForEnvs = append(keysForEnvs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEnvs)
	mapStringForEnvs := "map[string]string{"
	for _, k := range keysForEnvs {
		mapStringForEnvs += fmt.Sprintf("%v: %v,", k, this.Envs[k])
	}
	mapStringForEnvs += "}"
	s := strings.Join([]string{`&ExecOrAttachCmd{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Container:` + fmt.Sprintf("%v", this.Container) + `,`,
		`Stdin:` + fmt.Sprintf("%v", this.Stdin) + `,`,
		`Stdout:` + fmt.Sprintf("%v", this.Stdout) + `,`,
		`Stderr:` + fmt.Sprintf("%v", this.Stderr) + `,`,
		`Tty:` + fmt.Sprintf("%v", this.Tty) + `,`,
		`Command:` + fmt.Sprintf("%v", this.Command) + `,`,
		`Envs:` + mapStringForEnvs + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortForwardCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortForwardCmd{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Network:` + fmt.Sprintf("%v", this.Network) + `,`,
		`Host:` + fmt.Sprintf("%v", this.Host) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TerminalResizeCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TerminalResizeCmd{`,
		`Cols:` + fmt.Sprintf("%v", this.Cols) + `,`,
		`Rows:` + fmt.Sprintf("%v", this.Rows) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricsConfigCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricsConfigCmd{`,
		`Collect:` + fmt.Sprintf("%v", this.Collect) + `,`,
		`ExtraArgs:` + fmt.Sprintf("%v", this.ExtraArgs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ErrorMsg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ErrorMsg{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StateMsg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StateMsg{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`DeviceId:` + fmt.Sprintf("%v", this.DeviceId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkMsg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkMsg{`,
		`AbbotResponseBytes:` + fmt.Sprintf("%v", this.AbbotResponseBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeSystemInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeSystemInfo{`,
		`Os:` + fmt.Sprintf("%v", this.Os) + `,`,
		`OsImage:` + fmt.Sprintf("%v", this.OsImage) + `,`,
		`Arch:` + fmt.Sprintf("%v", this.Arch) + `,`,
		`KernelVersion:` + fmt.Sprintf("%v", this.KernelVersion) + `,`,
		`BootId:` + fmt.Sprintf("%v", this.BootId) + `,`,
		`MachineId:` + fmt.Sprintf("%v", this.MachineId) + `,`,
		`SystemUuid:` + fmt.Sprintf("%v", this.SystemUuid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeResources) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeResources{`,
		`CpuCount:` + fmt.Sprintf("%v", this.CpuCount) + `,`,
		`MemoryBytes:` + fmt.Sprintf("%v", this.MemoryBytes) + `,`,
		`StorageBytes:` + fmt.Sprintf("%v", this.StorageBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeConditions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeConditions{`,
		`Ready:` + fmt.Sprintf("%v", this.Ready) + `,`,
		`Memory:` + fmt.Sprintf("%v", this.Memory) + `,`,
		`Disk:` + fmt.Sprintf("%v", this.Disk) + `,`,
		`Pid:` + fmt.Sprintf("%v", this.Pid) + `,`,
		`Network:` + fmt.Sprintf("%v", this.Network) + `,`,
		`Pod:` + fmt.Sprintf("%v", this.Pod) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeExtInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeExtInfo{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`ValueType:` + fmt.Sprintf("%v", this.ValueType) + `,`,
		`Operator:` + fmt.Sprintf("%v", this.Operator) + `,`,
		`Target:` + fmt.Sprintf("%v", this.Target) + `,`,
		`TargetKey:` + fmt.Sprintf("%v", this.TargetKey) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeStatusMsg) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForExtInfo := "[]*NodeExtInfo{"
	for _, f := range this.ExtInfo {
		repeatedStringForExtInfo += strings.Replace(f.String(), "NodeExtInfo", "NodeExtInfo", 1) + ","
	}
	repeatedStringForExtInfo += "}"
	s := strings.Join([]string{`&NodeStatusMsg{`,
		`SystemInfo:` + strings.Replace(this.SystemInfo.String(), "NodeSystemInfo", "NodeSystemInfo", 1) + `,`,
		`Capacity:` + strings.Replace(this.Capacity.String(), "NodeResources", "NodeResources", 1) + `,`,
		`Conditions:` + strings.Replace(this.Conditions.String(), "NodeConditions", "NodeConditions", 1) + `,`,
		`ExtInfo:` + repeatedStringForExtInfo + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageListCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageListCmd{`,
		`}`,
	}, "")
	return s
}
func (this *StorageEnsureCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageEnsureCmd{`,
		`RemotePath:` + fmt.Sprintf("%v", this.RemotePath) + `,`,
		`LocalPath:` + fmt.Sprintf("%v", this.LocalPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDeleteCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDeleteCmd{`,
		`RemotePath:` + fmt.Sprintf("%v", this.RemotePath) + `,`,
		`LocalPath:` + fmt.Sprintf("%v", this.LocalPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageStatusMsg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageStatusMsg{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`RemotePath:` + fmt.Sprintf("%v", this.RemotePath) + `,`,
		`MountPoint:` + fmt.Sprintf("%v", this.MountPoint) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageStatusListMsg) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForStorages := "[]*StorageStatusMsg{"
	for _, f := range this.Storages {
		repeatedStringForStorages += strings.Replace(f.String(), "StorageStatusMsg", "StorageStatusMsg", 1) + ","
	}
	repeatedStringForStorages += "}"
	s := strings.Join([]string{`&StorageStatusListMsg{`,
		`Storages:` + repeatedStringForStorages + `,`,
		`}`,
	}, "")
	return s
}
func (this *CredentialListCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CredentialListCmd{`,
		`}`,
	}, "")
	return s
}
func (this *CredentialDeleteCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CredentialDeleteCmd{`,
		`}`,
	}, "")
	return s
}
func (this *CredentialEnsureCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CredentialEnsureCmd{`,
		`SshPrivateKey:` + fmt.Sprintf("%v", this.SshPrivateKey) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CredentialStatusMsg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CredentialStatusMsg{`,
		`SshPrivateKeySha256:` + fmt.Sprintf("%v", this.SshPrivateKeySha256) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringProto(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Cmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= CmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Completed = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Msg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Msg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Msg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= MsgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Completed = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfoGetCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfoGetCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfoGetCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= NodeInfoGetCmd_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionCloseCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionCloseCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionCloseCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RejectCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RejectCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RejectCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= RejectionReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbbotRequestBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbbotRequestBytes = append(m.AbbotRequestBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.AbbotRequestBytes == nil {
				m.AbbotRequestBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogsCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogsCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogsCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Follow = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timestamp = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Since", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Since = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TailLines", wireType)
			}
			m.TailLines = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TailLines |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesLimit", wireType)
			}
			m.BytesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Previous", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Previous = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecOrAttachCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecOrAttachCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecOrAttachCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stdin = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stdout = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stderr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stderr = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tty = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Envs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Envs == nil {
				m.Envs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProto
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProto
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProto
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthProto
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProto
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProto
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthProto
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProto(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthProto
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Envs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortForwardCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortForwardCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortForwardCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TerminalResizeCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TerminalResizeCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TerminalResizeCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			m.Cols = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cols |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			m.Rows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rows |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricsConfigCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricsConfigCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricsConfigCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collect = append(m.Collect, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraArgs = append(m.ExtraArgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= ErrorMsg_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= StateMsg_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbbotResponseBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbbotResponseBytes = append(m.AbbotResponseBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.AbbotResponseBytes == nil {
				m.AbbotResponseBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeSystemInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeSystemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeSystemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Os = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OsImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BootId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BootId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MachineId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeResources) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeResources: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeResources: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCount", wireType)
			}
			m.CpuCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryBytes", wireType)
			}
			m.MemoryBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageBytes", wireType)
			}
			m.StorageBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeConditions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeConditions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeConditions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ready", wireType)
			}
			m.Ready = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ready |= NodeCondition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= NodeCondition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			m.Disk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Disk |= NodeCondition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= NodeCondition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			m.Network = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Network |= NodeCondition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pod", wireType)
			}
			m.Pod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pod |= NodeCondition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeExtInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeExtInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeExtInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueType", wireType)
			}
			m.ValueType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValueType |= NodeExtInfo_ValueType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			m.Operator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operator |= NodeExtInfo_Operator(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= NodeExtInfo_Target(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeStatusMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeStatusMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeStatusMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SystemInfo == nil {
				m.SystemInfo = &NodeSystemInfo{}
			}
			if err := m.SystemInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Capacity == nil {
				m.Capacity = &NodeResources{}
			}
			if err := m.Capacity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conditions == nil {
				m.Conditions = &NodeConditions{}
			}
			if err := m.Conditions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtInfo = append(m.ExtInfo, &NodeExtInfo{})
			if err := m.ExtInfo[len(m.ExtInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageListCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageListCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageListCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageEnsureCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageEnsureCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageEnsureCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemotePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDeleteCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDeleteCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDeleteCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemotePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageStatusMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageStatusMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageStatusMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= StorageState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemotePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageStatusListMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageStatusListMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageStatusListMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storages = append(m.Storages, &StorageStatusMsg{})
			if err := m.Storages[len(m.Storages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CredentialListCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CredentialListCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CredentialListCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CredentialDeleteCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CredentialDeleteCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CredentialDeleteCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CredentialEnsureCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CredentialEnsureCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CredentialEnsureCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshPrivateKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshPrivateKey = append(m.SshPrivateKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SshPrivateKey == nil {
				m.SshPrivateKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CredentialStatusMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CredentialStatusMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CredentialStatusMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshPrivateKeySha256", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshPrivateKeySha256 = append(m.SshPrivateKeySha256[:0], dAtA[iNdEx:postIndex]...)
			if m.SshPrivateKeySha256 == nil {
				m.SshPrivateKeySha256 = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProto(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProto
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProto
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProto
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProto
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProto
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProto
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProto        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProto          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProto = fmt.Errorf("proto: unexpected end of group")
)
