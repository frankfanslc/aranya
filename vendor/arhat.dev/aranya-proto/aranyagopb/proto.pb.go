// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto.proto

package aranyagopb

import (
	bytes "bytes"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Kind int32

const (
	EMPTY Kind = 0
	// if kind name contains _DATA_, the message body is raw day
	// not the encoded protobuf bytes
	MSG_DATA_DEFAULT  Kind = 1
	MSG_DATA_STDOUT   Kind = 1
	MSG_DATA_METRICS  Kind = 1
	MSG_DATA_STDERR   Kind = 2
	CMD_DATA_UPSTREAM Kind = 3
	CMD_REJECT        Kind = 10
	CMD_SESSION_CLOSE Kind = 11
	// basic pod operations (frequently used with kubectl)
	CMD_POD_CTR_EXEC       Kind = 12
	CMD_POD_CTR_ATTACH     Kind = 13
	CMD_POD_CTR_LOGS       Kind = 14
	CMD_POD_CTR_TTY_RESIZE Kind = 15
	CMD_POD_PORT_FORWARD   Kind = 16
	// node operations
	CMD_NODE_INFO_GET Kind = 17
	// metrics operations
	CMD_METRICS_CONFIG  Kind = 21
	CMD_METRICS_COLLECT Kind = 22
	// network operations
	CMD_NET_UPDATE_POD_NET Kind = 25
	// credentials operations
	CMD_CRED_ENSURE Kind = 31
	// container image / application bundle operations
	CMD_IMAGE_LIST   Kind = 41
	CMD_IMAGE_ENSURE Kind = 42
	CMD_IMAGE_DELETE Kind = 43
	// storage operations (remote csi)
	CMD_STORAGE_LIST   Kind = 51
	CMD_STORAGE_ENSURE Kind = 52
	CMD_STORAGE_DELETE Kind = 53
	// pod container provision
	CMD_POD_LIST   Kind = 61
	CMD_POD_ENSURE Kind = 62
	CMD_POD_DELETE Kind = 63
	// device operations
	CMD_DEVICE_LIST         Kind = 71
	CMD_DEVICE_ENSURE       Kind = 72
	CMD_DEVICE_DELETE       Kind = 73
	MSG_DONE                Kind = 100
	MSG_STATE               Kind = 101
	MSG_ERROR               Kind = 102
	MSG_NODE_STATUS         Kind = 111
	MSG_NETWORK_STATUS      Kind = 121
	MSG_CRED_STATUS         Kind = 131
	MSG_IMAGE_STATUS        Kind = 141
	MSG_IMAGE_STATUS_LIST   Kind = 142
	MSG_STORAGE_STATUS      Kind = 151
	MSG_STORAGE_STATUS_LIST Kind = 152
	MSG_POD_STATUS          Kind = 161
	MSG_POD_STATUS_LIST     Kind = 162
	MSG_DEVICE_STATUS       Kind = 171
	MSG_DEVICE_STATUS_LIST  Kind = 172
)

var Kind_name = map[int32]string{
	0: "EMPTY",
	1: "MSG_DATA_DEFAULT",
	// Duplicate value: 1: "MSG_DATA_STDOUT",
	// Duplicate value: 1: "MSG_DATA_METRICS",
	2:   "MSG_DATA_STDERR",
	3:   "CMD_DATA_UPSTREAM",
	10:  "CMD_REJECT",
	11:  "CMD_SESSION_CLOSE",
	12:  "CMD_POD_CTR_EXEC",
	13:  "CMD_POD_CTR_ATTACH",
	14:  "CMD_POD_CTR_LOGS",
	15:  "CMD_POD_CTR_TTY_RESIZE",
	16:  "CMD_POD_PORT_FORWARD",
	17:  "CMD_NODE_INFO_GET",
	21:  "CMD_METRICS_CONFIG",
	22:  "CMD_METRICS_COLLECT",
	25:  "CMD_NET_UPDATE_POD_NET",
	31:  "CMD_CRED_ENSURE",
	41:  "CMD_IMAGE_LIST",
	42:  "CMD_IMAGE_ENSURE",
	43:  "CMD_IMAGE_DELETE",
	51:  "CMD_STORAGE_LIST",
	52:  "CMD_STORAGE_ENSURE",
	53:  "CMD_STORAGE_DELETE",
	61:  "CMD_POD_LIST",
	62:  "CMD_POD_ENSURE",
	63:  "CMD_POD_DELETE",
	71:  "CMD_DEVICE_LIST",
	72:  "CMD_DEVICE_ENSURE",
	73:  "CMD_DEVICE_DELETE",
	100: "MSG_DONE",
	101: "MSG_STATE",
	102: "MSG_ERROR",
	111: "MSG_NODE_STATUS",
	121: "MSG_NETWORK_STATUS",
	131: "MSG_CRED_STATUS",
	141: "MSG_IMAGE_STATUS",
	142: "MSG_IMAGE_STATUS_LIST",
	151: "MSG_STORAGE_STATUS",
	152: "MSG_STORAGE_STATUS_LIST",
	161: "MSG_POD_STATUS",
	162: "MSG_POD_STATUS_LIST",
	171: "MSG_DEVICE_STATUS",
	172: "MSG_DEVICE_STATUS_LIST",
}

var Kind_value = map[string]int32{
	"EMPTY":                   0,
	"MSG_DATA_DEFAULT":        1,
	"MSG_DATA_STDOUT":         1,
	"MSG_DATA_METRICS":        1,
	"MSG_DATA_STDERR":         2,
	"CMD_DATA_UPSTREAM":       3,
	"CMD_REJECT":              10,
	"CMD_SESSION_CLOSE":       11,
	"CMD_POD_CTR_EXEC":        12,
	"CMD_POD_CTR_ATTACH":      13,
	"CMD_POD_CTR_LOGS":        14,
	"CMD_POD_CTR_TTY_RESIZE":  15,
	"CMD_POD_PORT_FORWARD":    16,
	"CMD_NODE_INFO_GET":       17,
	"CMD_METRICS_CONFIG":      21,
	"CMD_METRICS_COLLECT":     22,
	"CMD_NET_UPDATE_POD_NET":  25,
	"CMD_CRED_ENSURE":         31,
	"CMD_IMAGE_LIST":          41,
	"CMD_IMAGE_ENSURE":        42,
	"CMD_IMAGE_DELETE":        43,
	"CMD_STORAGE_LIST":        51,
	"CMD_STORAGE_ENSURE":      52,
	"CMD_STORAGE_DELETE":      53,
	"CMD_POD_LIST":            61,
	"CMD_POD_ENSURE":          62,
	"CMD_POD_DELETE":          63,
	"CMD_DEVICE_LIST":         71,
	"CMD_DEVICE_ENSURE":       72,
	"CMD_DEVICE_DELETE":       73,
	"MSG_DONE":                100,
	"MSG_STATE":               101,
	"MSG_ERROR":               102,
	"MSG_NODE_STATUS":         111,
	"MSG_NETWORK_STATUS":      121,
	"MSG_CRED_STATUS":         131,
	"MSG_IMAGE_STATUS":        141,
	"MSG_IMAGE_STATUS_LIST":   142,
	"MSG_STORAGE_STATUS":      151,
	"MSG_STORAGE_STATUS_LIST": 152,
	"MSG_POD_STATUS":          161,
	"MSG_POD_STATUS_LIST":     162,
	"MSG_DEVICE_STATUS":       171,
	"MSG_DEVICE_STATUS_LIST":  172,
}

func (Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{0}
}

type NodeInfoGetCmd_Kind int32

const (
	NODE_INFO_DYN NodeInfoGetCmd_Kind = 0
	NODE_INFO_ALL NodeInfoGetCmd_Kind = 1
)

var NodeInfoGetCmd_Kind_name = map[int32]string{
	0: "NODE_INFO_DYN",
	1: "NODE_INFO_ALL",
}

var NodeInfoGetCmd_Kind_value = map[string]int32{
	"NODE_INFO_DYN": 0,
	"NODE_INFO_ALL": 1,
}

func (NodeInfoGetCmd_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{4, 0}
}

type RejectCmd_Reason int32

const (
	_INVALID_REJECTION_REASON        RejectCmd_Reason = 0
	REJECTION_ALREADY_CONNECTED      RejectCmd_Reason = 1
	REJECTION_POD_STATUS_SYNC_ERROR  RejectCmd_Reason = 2
	REJECTION_NODE_STATUS_SYNC_ERROR RejectCmd_Reason = 3
	REJECTION_NETWORK_UPDATE_FAILURE RejectCmd_Reason = 4
	REJECTION_CREDENTIAL_FAILURE     RejectCmd_Reason = 5
	REJECTION_INTERNAL_SERVER_ERROR  RejectCmd_Reason = 6
	REJECTION_INVALID_PROTO          RejectCmd_Reason = 7
)

var RejectCmd_Reason_name = map[int32]string{
	0: "_INVALID_REJECTION_REASON",
	1: "REJECTION_ALREADY_CONNECTED",
	2: "REJECTION_POD_STATUS_SYNC_ERROR",
	3: "REJECTION_NODE_STATUS_SYNC_ERROR",
	4: "REJECTION_NETWORK_UPDATE_FAILURE",
	5: "REJECTION_CREDENTIAL_FAILURE",
	6: "REJECTION_INTERNAL_SERVER_ERROR",
	7: "REJECTION_INVALID_PROTO",
}

var RejectCmd_Reason_value = map[string]int32{
	"_INVALID_REJECTION_REASON":        0,
	"REJECTION_ALREADY_CONNECTED":      1,
	"REJECTION_POD_STATUS_SYNC_ERROR":  2,
	"REJECTION_NODE_STATUS_SYNC_ERROR": 3,
	"REJECTION_NETWORK_UPDATE_FAILURE": 4,
	"REJECTION_CREDENTIAL_FAILURE":     5,
	"REJECTION_INTERNAL_SERVER_ERROR":  6,
	"REJECTION_INVALID_PROTO":          7,
}

func (RejectCmd_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{6, 0}
}

type ErrorMsg_Kind int32

const (
	// ERR_COMMON means Error happened, but we don't know what to do,
	// report as failure and retry later.
	ERR_COMMON ErrorMsg_Kind = 0
	// ERR_NOT_FOUND means something not found but may be expected by
	// the scheduler, aranya should schedule according task or ignore.
	ERR_NOT_FOUND ErrorMsg_Kind = 1
	// ERR_ALREADY_EXISTS means something expected by the scheduler already
	// exists in agent, agent only report this error when it's sure the
	// existing object is the same with the one expected by the scheduler,
	// otherwise it should report ERR_NOT_FOUND.
	ERR_ALREADY_EXISTS ErrorMsg_Kind = 2
	// ERR_NOT_SUPPORTED means Cmd not supported by the agent,
	// aranya should ignore this error and cancel all future
	// job.
	ERR_NOT_SUPPORTED ErrorMsg_Kind = 3
	// ERR_TIMEOUT only happen in connectivity server,
	// right after the session is timed out
	ERR_TIMEOUT ErrorMsg_Kind = 4
)

var ErrorMsg_Kind_name = map[int32]string{
	0: "ERR_COMMON",
	1: "ERR_NOT_FOUND",
	2: "ERR_ALREADY_EXISTS",
	3: "ERR_NOT_SUPPORTED",
	4: "ERR_TIMEOUT",
}

var ErrorMsg_Kind_value = map[string]int32{
	"ERR_COMMON":         0,
	"ERR_NOT_FOUND":      1,
	"ERR_ALREADY_EXISTS": 2,
	"ERR_NOT_SUPPORTED":  3,
	"ERR_TIMEOUT":        4,
}

func (ErrorMsg_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{11, 0}
}

type StateMsg_Kind int32

const (
	_INVALID_STATE StateMsg_Kind = 0
	STATE_ONLINE   StateMsg_Kind = 1
	STATE_OFFLINE  StateMsg_Kind = 2
)

var StateMsg_Kind_name = map[int32]string{
	0: "_INVALID_STATE",
	1: "STATE_ONLINE",
	2: "STATE_OFFLINE",
}

var StateMsg_Kind_value = map[string]int32{
	"_INVALID_STATE": 0,
	"STATE_ONLINE":   1,
	"STATE_OFFLINE":  2,
}

func (StateMsg_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{12, 0}
}

type Empty struct {
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type Header struct {
	Kind Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=aranya.Kind" json:"kind,omitempty"`
	// session id used by Cmd/Msg
	Sid uint64 `protobuf:"varint,2,opt,name=sid,proto3" json:"sid,omitempty"`
	// sequence in the session, to ensure ordered data
	// if the session contains multiple Cmd/Msg,
	// seq keeps increasing
	Seq uint64 `protobuf:"varint,3,opt,name=seq,proto3" json:"seq,omitempty"`
	// mark this Msg is the last message in the session
	Completed bool `protobuf:"varint,4,opt,name=completed,proto3" json:"completed,omitempty"`
	// sub sequence in the session, which is used to multiplex the
	// session
	//  e.g. aranya starts a session with container exec
	//       arhat executed the command with output but command exited
	//          with code 1
	//       arhat should report this error along with the output, then
	//          it just upload the output with sub_seq=0, and report the
	//          error with sub_seq=1
	SubSeq uint64 `protobuf:"varint,5,opt,name=sub_seq,json=subSeq,proto3" json:"sub_seq,omitempty"`
}

func (m *Header) Reset()      { *m = Header{} }
func (*Header) ProtoMessage() {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{1}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

func (m *Header) GetKind() Kind {
	if m != nil {
		return m.Kind
	}
	return EMPTY
}

func (m *Header) GetSid() uint64 {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *Header) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *Header) GetCompleted() bool {
	if m != nil {
		return m.Completed
	}
	return false
}

func (m *Header) GetSubSeq() uint64 {
	if m != nil {
		return m.SubSeq
	}
	return 0
}

type Cmd struct {
	Header *Header `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Body   []byte  `protobuf:"bytes,11,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *Cmd) Reset()      { *m = Cmd{} }
func (*Cmd) ProtoMessage() {}
func (*Cmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{2}
}
func (m *Cmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cmd.Merge(m, src)
}
func (m *Cmd) XXX_Size() int {
	return m.Size()
}
func (m *Cmd) XXX_DiscardUnknown() {
	xxx_messageInfo_Cmd.DiscardUnknown(m)
}

var xxx_messageInfo_Cmd proto.InternalMessageInfo

func (m *Cmd) GetHeader() *Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Cmd) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type Msg struct {
	Header *Header `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// online_id of the agent
	OnlineId string `protobuf:"bytes,4,opt,name=online_id,json=onlineId,proto3" json:"online_id,omitempty"`
	// body of encoded XxxMsg or raw data bytes
	Body []byte `protobuf:"bytes,11,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *Msg) Reset()      { *m = Msg{} }
func (*Msg) ProtoMessage() {}
func (*Msg) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{3}
}
func (m *Msg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Msg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Msg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Msg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Msg.Merge(m, src)
}
func (m *Msg) XXX_Size() int {
	return m.Size()
}
func (m *Msg) XXX_DiscardUnknown() {
	xxx_messageInfo_Msg.DiscardUnknown(m)
}

var xxx_messageInfo_Msg proto.InternalMessageInfo

func (m *Msg) GetHeader() *Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Msg) GetOnlineId() string {
	if m != nil {
		return m.OnlineId
	}
	return ""
}

func (m *Msg) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type NodeInfoGetCmd struct {
	Kind NodeInfoGetCmd_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=aranya.NodeInfoGetCmd_Kind" json:"kind,omitempty"`
}

func (m *NodeInfoGetCmd) Reset()      { *m = NodeInfoGetCmd{} }
func (*NodeInfoGetCmd) ProtoMessage() {}
func (*NodeInfoGetCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{4}
}
func (m *NodeInfoGetCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfoGetCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfoGetCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfoGetCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfoGetCmd.Merge(m, src)
}
func (m *NodeInfoGetCmd) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfoGetCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfoGetCmd.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfoGetCmd proto.InternalMessageInfo

func (m *NodeInfoGetCmd) GetKind() NodeInfoGetCmd_Kind {
	if m != nil {
		return m.Kind
	}
	return NODE_INFO_DYN
}

type SessionCloseCmd struct {
	Sid uint64 `protobuf:"varint,1,opt,name=sid,proto3" json:"sid,omitempty"`
}

func (m *SessionCloseCmd) Reset()      { *m = SessionCloseCmd{} }
func (*SessionCloseCmd) ProtoMessage() {}
func (*SessionCloseCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{5}
}
func (m *SessionCloseCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionCloseCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionCloseCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionCloseCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionCloseCmd.Merge(m, src)
}
func (m *SessionCloseCmd) XXX_Size() int {
	return m.Size()
}
func (m *SessionCloseCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionCloseCmd.DiscardUnknown(m)
}

var xxx_messageInfo_SessionCloseCmd proto.InternalMessageInfo

func (m *SessionCloseCmd) GetSid() uint64 {
	if m != nil {
		return m.Sid
	}
	return 0
}

type RejectCmd struct {
	Reason  RejectCmd_Reason `protobuf:"varint,1,opt,name=reason,proto3,enum=aranya.RejectCmd_Reason" json:"reason,omitempty"`
	Message string           `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *RejectCmd) Reset()      { *m = RejectCmd{} }
func (*RejectCmd) ProtoMessage() {}
func (*RejectCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{6}
}
func (m *RejectCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RejectCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RejectCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RejectCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RejectCmd.Merge(m, src)
}
func (m *RejectCmd) XXX_Size() int {
	return m.Size()
}
func (m *RejectCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_RejectCmd.DiscardUnknown(m)
}

var xxx_messageInfo_RejectCmd proto.InternalMessageInfo

func (m *RejectCmd) GetReason() RejectCmd_Reason {
	if m != nil {
		return m.Reason
	}
	return _INVALID_REJECTION_REASON
}

func (m *RejectCmd) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ContainerLogsCmd struct {
	PodUid     string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	Container  string `protobuf:"bytes,2,opt,name=container,proto3" json:"container,omitempty"`
	Follow     bool   `protobuf:"varint,3,opt,name=follow,proto3" json:"follow,omitempty"`
	Timestamp  bool   `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Since      string `protobuf:"bytes,5,opt,name=since,proto3" json:"since,omitempty"`
	TailLines  int64  `protobuf:"varint,6,opt,name=tail_lines,json=tailLines,proto3" json:"tail_lines,omitempty"`
	BytesLimit int64  `protobuf:"varint,7,opt,name=bytes_limit,json=bytesLimit,proto3" json:"bytes_limit,omitempty"`
	Previous   bool   `protobuf:"varint,8,opt,name=previous,proto3" json:"previous,omitempty"`
	// host log path
	Path string `protobuf:"bytes,9,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *ContainerLogsCmd) Reset()      { *m = ContainerLogsCmd{} }
func (*ContainerLogsCmd) ProtoMessage() {}
func (*ContainerLogsCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{7}
}
func (m *ContainerLogsCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerLogsCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerLogsCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerLogsCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerLogsCmd.Merge(m, src)
}
func (m *ContainerLogsCmd) XXX_Size() int {
	return m.Size()
}
func (m *ContainerLogsCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerLogsCmd.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerLogsCmd proto.InternalMessageInfo

func (m *ContainerLogsCmd) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *ContainerLogsCmd) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *ContainerLogsCmd) GetFollow() bool {
	if m != nil {
		return m.Follow
	}
	return false
}

func (m *ContainerLogsCmd) GetTimestamp() bool {
	if m != nil {
		return m.Timestamp
	}
	return false
}

func (m *ContainerLogsCmd) GetSince() string {
	if m != nil {
		return m.Since
	}
	return ""
}

func (m *ContainerLogsCmd) GetTailLines() int64 {
	if m != nil {
		return m.TailLines
	}
	return 0
}

func (m *ContainerLogsCmd) GetBytesLimit() int64 {
	if m != nil {
		return m.BytesLimit
	}
	return 0
}

func (m *ContainerLogsCmd) GetPrevious() bool {
	if m != nil {
		return m.Previous
	}
	return false
}

func (m *ContainerLogsCmd) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Pod Exec/Attach Cmd
type ContainerExecOrAttachCmd struct {
	PodUid    string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	Container string `protobuf:"bytes,2,opt,name=container,proto3" json:"container,omitempty"`
	Stdin     bool   `protobuf:"varint,3,opt,name=stdin,proto3" json:"stdin,omitempty"`
	Stdout    bool   `protobuf:"varint,4,opt,name=stdout,proto3" json:"stdout,omitempty"`
	Stderr    bool   `protobuf:"varint,5,opt,name=stderr,proto3" json:"stderr,omitempty"`
	Tty       bool   `protobuf:"varint,6,opt,name=tty,proto3" json:"tty,omitempty"`
	// command is empty when used for container attach
	Command []string `protobuf:"bytes,7,rep,name=command,proto3" json:"command,omitempty"`
	// environment variables when used with virtual host container image
	// values are resolved by aranya
	Envs map[string]string `protobuf:"bytes,8,rep,name=envs,proto3" json:"envs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ContainerExecOrAttachCmd) Reset()      { *m = ContainerExecOrAttachCmd{} }
func (*ContainerExecOrAttachCmd) ProtoMessage() {}
func (*ContainerExecOrAttachCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{8}
}
func (m *ContainerExecOrAttachCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerExecOrAttachCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerExecOrAttachCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerExecOrAttachCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerExecOrAttachCmd.Merge(m, src)
}
func (m *ContainerExecOrAttachCmd) XXX_Size() int {
	return m.Size()
}
func (m *ContainerExecOrAttachCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerExecOrAttachCmd.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerExecOrAttachCmd proto.InternalMessageInfo

func (m *ContainerExecOrAttachCmd) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *ContainerExecOrAttachCmd) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *ContainerExecOrAttachCmd) GetStdin() bool {
	if m != nil {
		return m.Stdin
	}
	return false
}

func (m *ContainerExecOrAttachCmd) GetStdout() bool {
	if m != nil {
		return m.Stdout
	}
	return false
}

func (m *ContainerExecOrAttachCmd) GetStderr() bool {
	if m != nil {
		return m.Stderr
	}
	return false
}

func (m *ContainerExecOrAttachCmd) GetTty() bool {
	if m != nil {
		return m.Tty
	}
	return false
}

func (m *ContainerExecOrAttachCmd) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ContainerExecOrAttachCmd) GetEnvs() map[string]string {
	if m != nil {
		return m.Envs
	}
	return nil
}

type PodPortForwardCmd struct {
	PodUid   string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	Port     int32  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	Protocol string `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty"`
}

func (m *PodPortForwardCmd) Reset()      { *m = PodPortForwardCmd{} }
func (*PodPortForwardCmd) ProtoMessage() {}
func (*PodPortForwardCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{9}
}
func (m *PodPortForwardCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodPortForwardCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodPortForwardCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodPortForwardCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodPortForwardCmd.Merge(m, src)
}
func (m *PodPortForwardCmd) XXX_Size() int {
	return m.Size()
}
func (m *PodPortForwardCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_PodPortForwardCmd.DiscardUnknown(m)
}

var xxx_messageInfo_PodPortForwardCmd proto.InternalMessageInfo

func (m *PodPortForwardCmd) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *PodPortForwardCmd) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *PodPortForwardCmd) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

type ContainerTerminalResizeCmd struct {
	Cols uint32 `protobuf:"varint,1,opt,name=cols,proto3" json:"cols,omitempty"`
	Rows uint32 `protobuf:"varint,2,opt,name=rows,proto3" json:"rows,omitempty"`
}

func (m *ContainerTerminalResizeCmd) Reset()      { *m = ContainerTerminalResizeCmd{} }
func (*ContainerTerminalResizeCmd) ProtoMessage() {}
func (*ContainerTerminalResizeCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{10}
}
func (m *ContainerTerminalResizeCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerTerminalResizeCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerTerminalResizeCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerTerminalResizeCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerTerminalResizeCmd.Merge(m, src)
}
func (m *ContainerTerminalResizeCmd) XXX_Size() int {
	return m.Size()
}
func (m *ContainerTerminalResizeCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerTerminalResizeCmd.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerTerminalResizeCmd proto.InternalMessageInfo

func (m *ContainerTerminalResizeCmd) GetCols() uint32 {
	if m != nil {
		return m.Cols
	}
	return 0
}

func (m *ContainerTerminalResizeCmd) GetRows() uint32 {
	if m != nil {
		return m.Rows
	}
	return 0
}

// Error infomation
type ErrorMsg struct {
	Kind ErrorMsg_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=aranya.ErrorMsg_Kind" json:"kind,omitempty"`
	// Human readable error description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// error code may be used for:
	//  - exit code of command execution
	//  - ...TBD
	Code int64 `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *ErrorMsg) Reset()      { *m = ErrorMsg{} }
func (*ErrorMsg) ProtoMessage() {}
func (*ErrorMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{11}
}
func (m *ErrorMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrorMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ErrorMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ErrorMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrorMsg.Merge(m, src)
}
func (m *ErrorMsg) XXX_Size() int {
	return m.Size()
}
func (m *ErrorMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrorMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ErrorMsg proto.InternalMessageInfo

func (m *ErrorMsg) GetKind() ErrorMsg_Kind {
	if m != nil {
		return m.Kind
	}
	return ERR_COMMON
}

func (m *ErrorMsg) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ErrorMsg) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

// State of agent, online/offline
type StateMsg struct {
	Kind     StateMsg_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=aranya.StateMsg_Kind" json:"kind,omitempty"`
	DeviceId string        `protobuf:"bytes,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
}

func (m *StateMsg) Reset()      { *m = StateMsg{} }
func (*StateMsg) ProtoMessage() {}
func (*StateMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{12}
}
func (m *StateMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMsg.Merge(m, src)
}
func (m *StateMsg) XXX_Size() int {
	return m.Size()
}
func (m *StateMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMsg.DiscardUnknown(m)
}

var xxx_messageInfo_StateMsg proto.InternalMessageInfo

func (m *StateMsg) GetKind() StateMsg_Kind {
	if m != nil {
		return m.Kind
	}
	return _INVALID_STATE
}

func (m *StateMsg) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func init() {
	proto.RegisterEnum("aranya.Kind", Kind_name, Kind_value)
	proto.RegisterEnum("aranya.NodeInfoGetCmd_Kind", NodeInfoGetCmd_Kind_name, NodeInfoGetCmd_Kind_value)
	proto.RegisterEnum("aranya.RejectCmd_Reason", RejectCmd_Reason_name, RejectCmd_Reason_value)
	proto.RegisterEnum("aranya.ErrorMsg_Kind", ErrorMsg_Kind_name, ErrorMsg_Kind_value)
	proto.RegisterEnum("aranya.StateMsg_Kind", StateMsg_Kind_name, StateMsg_Kind_value)
	proto.RegisterType((*Empty)(nil), "aranya.Empty")
	proto.RegisterType((*Header)(nil), "aranya.Header")
	proto.RegisterType((*Cmd)(nil), "aranya.Cmd")
	proto.RegisterType((*Msg)(nil), "aranya.Msg")
	proto.RegisterType((*NodeInfoGetCmd)(nil), "aranya.NodeInfoGetCmd")
	proto.RegisterType((*SessionCloseCmd)(nil), "aranya.SessionCloseCmd")
	proto.RegisterType((*RejectCmd)(nil), "aranya.RejectCmd")
	proto.RegisterType((*ContainerLogsCmd)(nil), "aranya.ContainerLogsCmd")
	proto.RegisterType((*ContainerExecOrAttachCmd)(nil), "aranya.ContainerExecOrAttachCmd")
	proto.RegisterMapType((map[string]string)(nil), "aranya.ContainerExecOrAttachCmd.EnvsEntry")
	proto.RegisterType((*PodPortForwardCmd)(nil), "aranya.PodPortForwardCmd")
	proto.RegisterType((*ContainerTerminalResizeCmd)(nil), "aranya.ContainerTerminalResizeCmd")
	proto.RegisterType((*ErrorMsg)(nil), "aranya.ErrorMsg")
	proto.RegisterType((*StateMsg)(nil), "aranya.StateMsg")
}

func init() { proto.RegisterFile("proto.proto", fileDescriptor_2fcc84b9998d60d8) }

var fileDescriptor_2fcc84b9998d60d8 = []byte{
	// 1576 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x96, 0xcf, 0x8f, 0xe3, 0x48,
	0x15, 0xc7, 0xe3, 0x24, 0x9d, 0x38, 0xaf, 0x7f, 0x4c, 0x75, 0xcd, 0x74, 0x77, 0xb6, 0x7b, 0x36,
	0x13, 0xbc, 0x08, 0xf5, 0x0e, 0xd0, 0x8b, 0x66, 0x41, 0x20, 0x24, 0x76, 0x65, 0x92, 0x4a, 0x8f,
	0x59, 0xc7, 0x8e, 0xca, 0xce, 0xcc, 0xf6, 0x0a, 0x61, 0xb9, 0xe3, 0x9a, 0x19, 0xb3, 0x89, 0x2b,
	0x63, 0xbb, 0x7b, 0x68, 0x4e, 0x2b, 0xa1, 0x3d, 0x82, 0x90, 0x38, 0xc0, 0x85, 0x03, 0x9c, 0x90,
	0xe0, 0x4f, 0xe0, 0x0f, 0xe0, 0x38, 0x27, 0xb4, 0x47, 0xa6, 0xe7, 0xc2, 0x71, 0x6f, 0x5c, 0x51,
	0x95, 0xcb, 0xe9, 0xa4, 0x1b, 0x46, 0x48, 0x5c, 0xa2, 0x7a, 0x9f, 0x7a, 0xe5, 0xf7, 0xde, 0xb7,
	0xaa, 0x5e, 0x05, 0xd6, 0xe7, 0x29, 0xcf, 0xf9, 0x91, 0xfc, 0xc5, 0x8d, 0x30, 0x0d, 0x93, 0x8b,
	0xd0, 0x68, 0xc2, 0x1a, 0x99, 0xcd, 0xf3, 0x0b, 0xe3, 0x73, 0x0d, 0x1a, 0x0f, 0x59, 0x18, 0xb1,
	0x14, 0x77, 0xa1, 0xfe, 0x69, 0x9c, 0x44, 0x6d, 0xad, 0xab, 0x1d, 0x6e, 0x3d, 0xd8, 0x38, 0x2a,
	0x5c, 0x8f, 0x3e, 0x8a, 0x93, 0x88, 0xca, 0x19, 0x8c, 0xa0, 0x96, 0xc5, 0x51, 0xbb, 0xda, 0xd5,
	0x0e, 0xeb, 0x54, 0x0c, 0x25, 0x61, 0xcf, 0xdb, 0x35, 0x45, 0xd8, 0x73, 0x7c, 0x17, 0x5a, 0x13,
	0x3e, 0x9b, 0x4f, 0x59, 0xce, 0xa2, 0x76, 0xbd, 0xab, 0x1d, 0xea, 0xf4, 0x0a, 0xe0, 0x3d, 0x68,
	0x66, 0x67, 0xa7, 0x81, 0x58, 0xb3, 0x26, 0xd7, 0x34, 0xb2, 0xb3, 0x53, 0x8f, 0x3d, 0x37, 0x4c,
	0xa8, 0xf5, 0x66, 0x11, 0xfe, 0x1a, 0x34, 0x9e, 0xc9, 0x6c, 0x64, 0x16, 0xeb, 0x0f, 0xb6, 0xca,
	0x2c, 0x8a, 0x1c, 0xa9, 0x9a, 0xc5, 0x18, 0xea, 0xa7, 0x3c, 0xba, 0x68, 0xaf, 0x77, 0xb5, 0xc3,
	0x0d, 0x2a, 0xc7, 0xc6, 0x4f, 0xa0, 0x36, 0xcc, 0x9e, 0xfe, 0xcf, 0x9f, 0x38, 0x80, 0x16, 0x4f,
	0xa6, 0x71, 0xc2, 0x82, 0xb8, 0x48, 0xb4, 0x45, 0xf5, 0x02, 0x58, 0xd1, 0x7f, 0xfc, 0x3e, 0x87,
	0x2d, 0x87, 0x47, 0xcc, 0x4a, 0x9e, 0xf0, 0x63, 0x96, 0x8b, 0x6c, 0xdf, 0x5b, 0x51, 0xec, 0xa0,
	0x0c, 0xb4, 0xea, 0xb5, 0x24, 0xa0, 0xf1, 0x0d, 0xa8, 0x0b, 0x0b, 0x6f, 0xc3, 0xa6, 0xe3, 0xf6,
	0x49, 0x60, 0x39, 0x03, 0x37, 0xe8, 0x9f, 0x38, 0xa8, 0xb2, 0x8a, 0x4c, 0xdb, 0x46, 0x9a, 0xf1,
	0x0e, 0xdc, 0xf2, 0x58, 0x96, 0xc5, 0x3c, 0xe9, 0x4d, 0x79, 0xc6, 0x44, 0x44, 0xb5, 0x03, 0xda,
	0x62, 0x07, 0x8c, 0x7f, 0x55, 0xa1, 0x45, 0xd9, 0x4f, 0xd9, 0x44, 0x66, 0xf4, 0x2d, 0x68, 0xa4,
	0x2c, 0xcc, 0x78, 0xa2, 0x72, 0x6a, 0x97, 0x39, 0x2d, 0x5c, 0x8e, 0xa8, 0x9c, 0xa7, 0xca, 0x0f,
	0xb7, 0xa1, 0x39, 0x63, 0x59, 0x16, 0x3e, 0x65, 0x72, 0x5f, 0x5b, 0xb4, 0x34, 0x8d, 0xdf, 0x57,
	0xa1, 0x51, 0x38, 0xe3, 0xb7, 0xe1, 0xad, 0xc0, 0x72, 0x1e, 0x99, 0xb6, 0xd5, 0x0f, 0x28, 0xf9,
	0x11, 0xe9, 0xf9, 0x96, 0xeb, 0x04, 0x94, 0x98, 0x9e, 0x2b, 0x72, 0xbf, 0x07, 0x07, 0x57, 0xd4,
	0xb4, 0x29, 0x31, 0xfb, 0x27, 0x41, 0xcf, 0x75, 0x1c, 0xd2, 0xf3, 0x49, 0x1f, 0x69, 0xf8, 0x1d,
	0xb8, 0x77, 0xe5, 0x30, 0x72, 0xfb, 0x81, 0xe7, 0x9b, 0xfe, 0xd8, 0x0b, 0xbc, 0x13, 0xa7, 0x17,
	0x10, 0x4a, 0x5d, 0x8a, 0xaa, 0xf8, 0xab, 0xd0, 0xbd, 0x72, 0x92, 0x5a, 0xdc, 0xf4, 0xaa, 0x5d,
	0xf3, 0x22, 0xfe, 0x63, 0x97, 0x7e, 0x14, 0x8c, 0x47, 0x7d, 0xd3, 0x27, 0xc1, 0xc0, 0xb4, 0xec,
	0x31, 0x25, 0xa8, 0x8e, 0xbb, 0x70, 0xf7, 0xca, 0xab, 0x47, 0x49, 0x9f, 0x38, 0xbe, 0x65, 0xda,
	0x0b, 0x8f, 0xb5, 0xd5, 0x94, 0x2c, 0xc7, 0x27, 0xd4, 0x31, 0xed, 0xc0, 0x23, 0xf4, 0x11, 0xa1,
	0x2a, 0x58, 0x03, 0x1f, 0xc0, 0xde, 0xb2, 0x53, 0x21, 0xc0, 0x88, 0xba, 0xbe, 0x8b, 0x9a, 0xc6,
	0xe7, 0x55, 0x40, 0x3d, 0x9e, 0xe4, 0x61, 0x9c, 0xb0, 0xd4, 0xe6, 0x4f, 0x33, 0xb1, 0x01, 0x7b,
	0xd0, 0x9c, 0xf3, 0x28, 0x38, 0x53, 0x9b, 0xd4, 0xa2, 0x8d, 0x39, 0x8f, 0xc6, 0x71, 0x54, 0xdc,
	0x0b, 0xe5, 0xac, 0x94, 0xbe, 0x02, 0x78, 0x17, 0x1a, 0x4f, 0xf8, 0x74, 0xca, 0x5f, 0xc8, 0xab,
	0xa4, 0x53, 0x65, 0x89, 0x55, 0x79, 0x3c, 0x63, 0x59, 0x1e, 0xce, 0xe6, 0xe5, 0x6d, 0x5a, 0x00,
	0x7c, 0x07, 0xd6, 0xb2, 0x38, 0x99, 0x30, 0x79, 0x97, 0x5a, 0xb4, 0x30, 0xf0, 0xdb, 0x00, 0x79,
	0x18, 0x4f, 0x03, 0x71, 0x94, 0xb3, 0x76, 0xa3, 0xab, 0x1d, 0xd6, 0x68, 0x4b, 0x10, 0x5b, 0x00,
	0x7c, 0x0f, 0xd6, 0x4f, 0x2f, 0x72, 0x96, 0x05, 0xd3, 0x78, 0x16, 0xe7, 0xed, 0xa6, 0x9c, 0x07,
	0x89, 0x6c, 0x41, 0xf0, 0x3e, 0xe8, 0xf3, 0x94, 0x9d, 0xc7, 0xfc, 0x2c, 0x6b, 0xeb, 0x32, 0xe4,
	0xc2, 0x16, 0xf7, 0x62, 0x1e, 0xe6, 0xcf, 0xda, 0x2d, 0x19, 0x50, 0x8e, 0x8d, 0xbf, 0x56, 0xa1,
	0xbd, 0xd0, 0x81, 0xfc, 0x8c, 0x4d, 0xdc, 0xd4, 0xcc, 0xf3, 0x70, 0xf2, 0xec, 0xff, 0xd0, 0x43,
	0x54, 0x96, 0x47, 0x71, 0xa2, 0xe4, 0x28, 0x0c, 0xa1, 0x52, 0x96, 0x47, 0xfc, 0x2c, 0x57, 0x52,
	0x28, 0x4b, 0x71, 0x96, 0xa6, 0x52, 0x88, 0x82, 0xb3, 0x34, 0x15, 0xb7, 0x25, 0xcf, 0x2f, 0xa4,
	0x04, 0x3a, 0x15, 0x43, 0x71, 0xda, 0x27, 0x7c, 0x36, 0x0b, 0x93, 0xa8, 0xdd, 0xec, 0xd6, 0xc4,
	0x69, 0x57, 0x26, 0xfe, 0x00, 0xea, 0x2c, 0x39, 0x17, 0x15, 0xd7, 0x0e, 0xd7, 0x1f, 0xdc, 0x2f,
	0xef, 0xcd, 0x7f, 0x2b, 0xec, 0x88, 0x24, 0xe7, 0x19, 0x49, 0xf2, 0xf4, 0x82, 0xca, 0x75, 0xfb,
	0xdf, 0x85, 0xd6, 0x02, 0x89, 0xc0, 0x9f, 0xb2, 0x0b, 0x55, 0xb1, 0x18, 0x8a, 0x82, 0xce, 0xc3,
	0xe9, 0x59, 0x79, 0xc9, 0x0a, 0xe3, 0xfb, 0xd5, 0xef, 0x69, 0xc6, 0x8f, 0x61, 0x7b, 0xc4, 0xa3,
	0x11, 0x4f, 0xf3, 0x01, 0x4f, 0x5f, 0x84, 0x69, 0xf4, 0x46, 0xd9, 0xc4, 0x06, 0xf0, 0x34, 0x97,
	0x9f, 0x59, 0xa3, 0x72, 0x5c, 0x6c, 0x18, 0xcf, 0xf9, 0x84, 0x4f, 0xa5, 0x5e, 0x2d, 0xba, 0xb0,
	0x8d, 0x3e, 0xec, 0x2f, 0x4a, 0xf0, 0x59, 0x3a, 0x8b, 0x93, 0x70, 0x4a, 0x59, 0x16, 0xff, 0x5c,
	0xb6, 0x13, 0x0c, 0xf5, 0x09, 0x9f, 0x66, 0x32, 0xc6, 0x26, 0x95, 0x63, 0xc1, 0x52, 0xfe, 0x22,
	0x93, 0x11, 0x36, 0xa9, 0x1c, 0x1b, 0x7f, 0xd7, 0x40, 0x27, 0x69, 0xca, 0x53, 0xd1, 0x60, 0xdf,
	0x5d, 0xe9, 0x7a, 0x3b, 0xa5, 0x52, 0xe5, 0xfc, 0xf2, 0x83, 0xd1, 0x85, 0xf5, 0x88, 0x65, 0x93,
	0x34, 0x9e, 0xe7, 0x31, 0x4f, 0x54, 0xed, 0xcb, 0xa8, 0xc8, 0x20, 0x62, 0x32, 0xef, 0x1a, 0x95,
	0x63, 0x23, 0x56, 0x5d, 0x72, 0x0b, 0x80, 0x50, 0x1a, 0xf4, 0xdc, 0xe1, 0xd0, 0x55, 0x2d, 0x52,
	0xd8, 0x8e, 0xeb, 0x07, 0x03, 0x77, 0xec, 0x88, 0xc6, 0xb2, 0x0b, 0x58, 0xa0, 0xb2, 0xe7, 0x90,
	0x8f, 0x2d, 0xcf, 0xf7, 0x50, 0x15, 0xef, 0xc0, 0x76, 0xe9, 0xea, 0x8d, 0x47, 0x23, 0x97, 0x8a,
	0x3e, 0x54, 0xc3, 0xb7, 0x60, 0x5d, 0x60, 0xdf, 0x1a, 0x12, 0x77, 0xec, 0xa3, 0xba, 0xf1, 0x1b,
	0x0d, 0x74, 0x2f, 0x0f, 0x73, 0xf6, 0x86, 0xc2, 0xca, 0xf9, 0xe5, 0xc2, 0x0e, 0xa0, 0x15, 0xb1,
	0xf3, 0x78, 0x22, 0x1f, 0x8f, 0xa2, 0x2c, 0xbd, 0x00, 0x56, 0x64, 0x7c, 0xa8, 0xf2, 0xc7, 0xb0,
	0xb5, 0x68, 0x1a, 0xa2, 0x95, 0x11, 0x54, 0xc1, 0x08, 0x36, 0xe4, 0x30, 0x70, 0x1d, 0xdb, 0x72,
	0x08, 0xd2, 0x44, 0x55, 0x8a, 0x0c, 0x06, 0x12, 0x55, 0xef, 0x7f, 0xa6, 0xab, 0x2f, 0xb4, 0x60,
	0x8d, 0x0c, 0x47, 0xfe, 0x09, 0xaa, 0xe0, 0x3b, 0x80, 0x86, 0xde, 0x71, 0xd0, 0x37, 0x7d, 0x33,
	0xe8, 0x93, 0x81, 0x39, 0xb6, 0x7d, 0xa4, 0xe1, 0xdb, 0x70, 0x6b, 0x41, 0x3d, 0xbf, 0x2f, 0x8a,
	0xd2, 0x56, 0x5c, 0x87, 0xc4, 0xa7, 0x56, 0xcf, 0xbb, 0xe9, 0x4a, 0x28, 0x2d, 0x74, 0xea, 0x0d,
	0xfb, 0x05, 0x1c, 0x8f, 0x3c, 0x9f, 0x12, 0x73, 0x88, 0x6a, 0x42, 0x79, 0x81, 0x8b, 0xde, 0x87,
	0xa0, 0x74, 0xf3, 0x88, 0xe7, 0xc9, 0x86, 0x6a, 0xbb, 0x1e, 0x41, 0xeb, 0x22, 0x90, 0xc0, 0xa2,
	0xa1, 0xf7, 0x7c, 0x1a, 0x90, 0x8f, 0x49, 0x0f, 0x6d, 0x88, 0x3d, 0x59, 0xa6, 0xa6, 0xef, 0x9b,
	0xbd, 0x87, 0x68, 0xf3, 0xba, 0xb7, 0xed, 0x1e, 0x7b, 0x68, 0x0b, 0xef, 0xc3, 0xee, 0x32, 0xf5,
	0xfd, 0x93, 0x80, 0x12, 0xcf, 0xfa, 0x84, 0xa0, 0x5b, 0xb8, 0x0d, 0x77, 0xca, 0x39, 0xb1, 0x85,
	0xc1, 0xc0, 0xa5, 0x8f, 0x4d, 0xda, 0x47, 0xa8, 0x4c, 0xe8, 0xea, 0xc5, 0x3c, 0x26, 0x3e, 0xda,
	0x2e, 0x43, 0xab, 0xa2, 0xc5, 0x13, 0x34, 0xb0, 0x8e, 0xd1, 0x0e, 0xde, 0x83, 0xdb, 0xab, 0xdc,
	0xb6, 0x45, 0x61, 0xbb, 0x65, 0x74, 0x87, 0xf8, 0xe5, 0x1b, 0x22, 0x82, 0x39, 0xc4, 0x47, 0x6f,
	0x09, 0xc1, 0xc4, 0x9c, 0x78, 0x3d, 0x02, 0xe2, 0x78, 0xe2, 0xd9, 0xb8, 0x27, 0xf6, 0x54, 0x40,
	0x6b, 0x68, 0x1e, 0x93, 0xc0, 0xb6, 0x3c, 0x1f, 0xbd, 0x5b, 0x16, 0x56, 0x30, 0xe5, 0x79, 0x7f,
	0x95, 0xf6, 0x89, 0x4d, 0x7c, 0x82, 0xbe, 0x5e, 0x52, 0xcf, 0x77, 0xe9, 0xe2, 0x0b, 0xef, 0x97,
	0x79, 0x97, 0x54, 0x7d, 0xe3, 0xdb, 0xd7, 0xb9, 0xfa, 0xca, 0x77, 0xc4, 0x29, 0x2a, 0x85, 0x91,
	0x5f, 0xf8, 0x41, 0x99, 0x97, 0x20, 0x6a, 0xf5, 0x07, 0xcb, 0x4c, 0xad, 0xfc, 0xb0, 0x2c, 0xaa,
	0x4f, 0x1e, 0x59, 0x3d, 0x15, 0xfe, 0x78, 0x71, 0x0a, 0x0a, 0xa8, 0xd6, 0x3f, 0xbc, 0x86, 0xd5,
	0x27, 0x2c, 0xbc, 0x01, 0xba, 0x3c, 0x48, 0xae, 0x43, 0x50, 0x84, 0x37, 0xa1, 0x25, 0xac, 0xe2,
	0x7c, 0xb3, 0xd2, 0x2c, 0x1e, 0xd0, 0x27, 0xe5, 0xa1, 0x5b, 0x7a, 0xcd, 0x11, 0x17, 0x55, 0x49,
	0xa8, 0x1e, 0x6f, 0xc5, 0x45, 0x8f, 0x94, 0xce, 0x52, 0x70, 0x05, 0x7f, 0xa1, 0xe1, 0x9d, 0xe2,
	0x34, 0x17, 0x3a, 0x2a, 0xfc, 0x4b, 0x0d, 0xef, 0xc3, 0xce, 0x75, 0x5c, 0x94, 0xf3, 0x2b, 0x0d,
	0xef, 0x15, 0x01, 0x4a, 0xd9, 0xd4, 0xa2, 0xdf, 0x6a, 0xf8, 0x2e, 0xec, 0xdd, 0x9c, 0x28, 0x96,
	0xfd, 0x4e, 0xdc, 0x90, 0x2d, 0x31, 0x7b, 0xf5, 0xff, 0x04, 0xfd, 0x41, 0xc3, 0x6d, 0xb8, 0xbd,
	0x0a, 0x0b, 0xf7, 0x3f, 0x8a, 0xde, 0xb3, 0x2d, 0x75, 0x28, 0xe4, 0x51, 0x2b, 0xfe, 0xac, 0xe1,
	0x03, 0xd8, 0xbd, 0xc1, 0x8b, 0x45, 0x7f, 0xd1, 0xf6, 0xab, 0x48, 0x33, 0xea, 0x7a, 0x1d, 0xd5,
	0x8d, 0xba, 0xbe, 0x86, 0xd6, 0x8c, 0xba, 0xde, 0x40, 0x0d, 0xa3, 0xae, 0x37, 0x51, 0xd3, 0xa8,
	0xeb, 0x3a, 0xd2, 0x8d, 0xba, 0xde, 0x42, 0xad, 0x1f, 0x3e, 0x7e, 0xf9, 0xaa, 0x53, 0xf9, 0xe2,
	0x55, 0xa7, 0xf2, 0xe5, 0xab, 0x8e, 0xf6, 0xd9, 0x65, 0x47, 0xfb, 0xd3, 0x65, 0x47, 0xfb, 0xdb,
	0x65, 0x47, 0x7b, 0x79, 0xd9, 0xd1, 0xfe, 0x71, 0xd9, 0xd1, 0xfe, 0x79, 0xd9, 0xa9, 0x7c, 0x79,
	0xd9, 0xd1, 0x7e, 0xfd, 0xba, 0x53, 0x79, 0xf9, 0xba, 0x53, 0xf9, 0xe2, 0x75, 0xa7, 0xf2, 0xc9,
	0x57, 0xc2, 0xf4, 0x59, 0x98, 0x1f, 0x45, 0xec, 0xfc, 0xbd, 0xa2, 0x79, 0x7d, 0x53, 0x3e, 0x04,
	0xca, 0x78, 0xca, 0xe7, 0xa7, 0xa7, 0x0d, 0x49, 0xde, 0xff, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x4a, 0xcc, 0x82, 0x89, 0x17, 0x0c, 0x00, 0x00,
}

func (x Kind) String() string {
	s, ok := Kind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NodeInfoGetCmd_Kind) String() string {
	s, ok := NodeInfoGetCmd_Kind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RejectCmd_Reason) String() string {
	s, ok := RejectCmd_Reason_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ErrorMsg_Kind) String() string {
	s, ok := ErrorMsg_Kind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x StateMsg_Kind) String() string {
	s, ok := StateMsg_Kind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Header) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Header)
	if !ok {
		that2, ok := that.(Header)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Sid != that1.Sid {
		return false
	}
	if this.Seq != that1.Seq {
		return false
	}
	if this.Completed != that1.Completed {
		return false
	}
	if this.SubSeq != that1.SubSeq {
		return false
	}
	return true
}
func (this *Cmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Cmd)
	if !ok {
		that2, ok := that.(Cmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Header.Equal(that1.Header) {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	return true
}
func (this *Msg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg)
	if !ok {
		that2, ok := that.(Msg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Header.Equal(that1.Header) {
		return false
	}
	if this.OnlineId != that1.OnlineId {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	return true
}
func (this *NodeInfoGetCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInfoGetCmd)
	if !ok {
		that2, ok := that.(NodeInfoGetCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	return true
}
func (this *SessionCloseCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SessionCloseCmd)
	if !ok {
		that2, ok := that.(SessionCloseCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Sid != that1.Sid {
		return false
	}
	return true
}
func (this *RejectCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RejectCmd)
	if !ok {
		that2, ok := that.(RejectCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *ContainerLogsCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerLogsCmd)
	if !ok {
		that2, ok := that.(ContainerLogsCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.Container != that1.Container {
		return false
	}
	if this.Follow != that1.Follow {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Since != that1.Since {
		return false
	}
	if this.TailLines != that1.TailLines {
		return false
	}
	if this.BytesLimit != that1.BytesLimit {
		return false
	}
	if this.Previous != that1.Previous {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	return true
}
func (this *ContainerExecOrAttachCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerExecOrAttachCmd)
	if !ok {
		that2, ok := that.(ContainerExecOrAttachCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.Container != that1.Container {
		return false
	}
	if this.Stdin != that1.Stdin {
		return false
	}
	if this.Stdout != that1.Stdout {
		return false
	}
	if this.Stderr != that1.Stderr {
		return false
	}
	if this.Tty != that1.Tty {
		return false
	}
	if len(this.Command) != len(that1.Command) {
		return false
	}
	for i := range this.Command {
		if this.Command[i] != that1.Command[i] {
			return false
		}
	}
	if len(this.Envs) != len(that1.Envs) {
		return false
	}
	for i := range this.Envs {
		if this.Envs[i] != that1.Envs[i] {
			return false
		}
	}
	return true
}
func (this *PodPortForwardCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodPortForwardCmd)
	if !ok {
		that2, ok := that.(PodPortForwardCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	return true
}
func (this *ContainerTerminalResizeCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerTerminalResizeCmd)
	if !ok {
		that2, ok := that.(ContainerTerminalResizeCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Cols != that1.Cols {
		return false
	}
	if this.Rows != that1.Rows {
		return false
	}
	return true
}
func (this *ErrorMsg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ErrorMsg)
	if !ok {
		that2, ok := that.(ErrorMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	return true
}
func (this *StateMsg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StateMsg)
	if !ok {
		that2, ok := that.(StateMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.DeviceId != that1.DeviceId {
		return false
	}
	return true
}
func (this *Empty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&aranyagopb.Empty{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Header) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&aranyagopb.Header{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Sid: "+fmt.Sprintf("%#v", this.Sid)+",\n")
	s = append(s, "Seq: "+fmt.Sprintf("%#v", this.Seq)+",\n")
	s = append(s, "Completed: "+fmt.Sprintf("%#v", this.Completed)+",\n")
	s = append(s, "SubSeq: "+fmt.Sprintf("%#v", this.SubSeq)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Cmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aranyagopb.Cmd{")
	if this.Header != nil {
		s = append(s, "Header: "+fmt.Sprintf("%#v", this.Header)+",\n")
	}
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Msg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&aranyagopb.Msg{")
	if this.Header != nil {
		s = append(s, "Header: "+fmt.Sprintf("%#v", this.Header)+",\n")
	}
	s = append(s, "OnlineId: "+fmt.Sprintf("%#v", this.OnlineId)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeInfoGetCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.NodeInfoGetCmd{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SessionCloseCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.SessionCloseCmd{")
	s = append(s, "Sid: "+fmt.Sprintf("%#v", this.Sid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RejectCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aranyagopb.RejectCmd{")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerLogsCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&aranyagopb.ContainerLogsCmd{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Container: "+fmt.Sprintf("%#v", this.Container)+",\n")
	s = append(s, "Follow: "+fmt.Sprintf("%#v", this.Follow)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Since: "+fmt.Sprintf("%#v", this.Since)+",\n")
	s = append(s, "TailLines: "+fmt.Sprintf("%#v", this.TailLines)+",\n")
	s = append(s, "BytesLimit: "+fmt.Sprintf("%#v", this.BytesLimit)+",\n")
	s = append(s, "Previous: "+fmt.Sprintf("%#v", this.Previous)+",\n")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerExecOrAttachCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&aranyagopb.ContainerExecOrAttachCmd{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Container: "+fmt.Sprintf("%#v", this.Container)+",\n")
	s = append(s, "Stdin: "+fmt.Sprintf("%#v", this.Stdin)+",\n")
	s = append(s, "Stdout: "+fmt.Sprintf("%#v", this.Stdout)+",\n")
	s = append(s, "Stderr: "+fmt.Sprintf("%#v", this.Stderr)+",\n")
	s = append(s, "Tty: "+fmt.Sprintf("%#v", this.Tty)+",\n")
	s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	keysForEnvs := make([]string, 0, len(this.Envs))
	for k, _ := range this.Envs {
		keysForEnvs = append(keysForEnvs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEnvs)
	mapStringForEnvs := "map[string]string{"
	for _, k := range keysForEnvs {
		mapStringForEnvs += fmt.Sprintf("%#v: %#v,", k, this.Envs[k])
	}
	mapStringForEnvs += "}"
	if this.Envs != nil {
		s = append(s, "Envs: "+mapStringForEnvs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodPortForwardCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&aranyagopb.PodPortForwardCmd{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerTerminalResizeCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aranyagopb.ContainerTerminalResizeCmd{")
	s = append(s, "Cols: "+fmt.Sprintf("%#v", this.Cols)+",\n")
	s = append(s, "Rows: "+fmt.Sprintf("%#v", this.Rows)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ErrorMsg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&aranyagopb.ErrorMsg{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StateMsg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aranyagopb.StateMsg{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "DeviceId: "+fmt.Sprintf("%#v", this.DeviceId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringProto(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubSeq != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.SubSeq))
		i--
		dAtA[i] = 0x28
	}
	if m.Completed {
		i--
		if m.Completed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Seq != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x18
	}
	if m.Sid != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x10
	}
	if m.Kind != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Cmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProto(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Msg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Msg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.OnlineId) > 0 {
		i -= len(m.OnlineId)
		copy(dAtA[i:], m.OnlineId)
		i = encodeVarintProto(dAtA, i, uint64(len(m.OnlineId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProto(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeInfoGetCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfoGetCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfoGetCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionCloseCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionCloseCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionCloseCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sid != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RejectCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RejectCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RejectCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Reason != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Reason))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContainerLogsCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerLogsCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerLogsCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Previous {
		i--
		if m.Previous {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.BytesLimit != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.BytesLimit))
		i--
		dAtA[i] = 0x38
	}
	if m.TailLines != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.TailLines))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Since) > 0 {
		i -= len(m.Since)
		copy(dAtA[i:], m.Since)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Since)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Timestamp {
		i--
		if m.Timestamp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Follow {
		i--
		if m.Follow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Container) > 0 {
		i -= len(m.Container)
		copy(dAtA[i:], m.Container)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Container)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PodUid) > 0 {
		i -= len(m.PodUid)
		copy(dAtA[i:], m.PodUid)
		i = encodeVarintProto(dAtA, i, uint64(len(m.PodUid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerExecOrAttachCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerExecOrAttachCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerExecOrAttachCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Envs) > 0 {
		for k := range m.Envs {
			v := m.Envs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintProto(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintProto(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintProto(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Command) > 0 {
		for iNdEx := len(m.Command) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Command[iNdEx])
			copy(dAtA[i:], m.Command[iNdEx])
			i = encodeVarintProto(dAtA, i, uint64(len(m.Command[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Tty {
		i--
		if m.Tty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Stderr {
		i--
		if m.Stderr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Stdout {
		i--
		if m.Stdout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Stdin {
		i--
		if m.Stdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Container) > 0 {
		i -= len(m.Container)
		copy(dAtA[i:], m.Container)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Container)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PodUid) > 0 {
		i -= len(m.PodUid)
		copy(dAtA[i:], m.PodUid)
		i = encodeVarintProto(dAtA, i, uint64(len(m.PodUid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PodPortForwardCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodPortForwardCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodPortForwardCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Port != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PodUid) > 0 {
		i -= len(m.PodUid)
		copy(dAtA[i:], m.PodUid)
		i = encodeVarintProto(dAtA, i, uint64(len(m.PodUid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerTerminalResizeCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerTerminalResizeCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerTerminalResizeCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rows != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Rows))
		i--
		dAtA[i] = 0x10
	}
	if m.Cols != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Cols))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ErrorMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ErrorMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.Kind != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintProto(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Kind != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintProto(dAtA []byte, offset int, v uint64) int {
	offset -= sovProto(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovProto(uint64(m.Kind))
	}
	if m.Sid != 0 {
		n += 1 + sovProto(uint64(m.Sid))
	}
	if m.Seq != 0 {
		n += 1 + sovProto(uint64(m.Seq))
	}
	if m.Completed {
		n += 2
	}
	if m.SubSeq != 0 {
		n += 1 + sovProto(uint64(m.SubSeq))
	}
	return n
}

func (m *Cmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *Msg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.OnlineId)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *NodeInfoGetCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovProto(uint64(m.Kind))
	}
	return n
}

func (m *SessionCloseCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sid != 0 {
		n += 1 + sovProto(uint64(m.Sid))
	}
	return n
}

func (m *RejectCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reason != 0 {
		n += 1 + sovProto(uint64(m.Reason))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *ContainerLogsCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	if m.Follow {
		n += 2
	}
	if m.Timestamp {
		n += 2
	}
	l = len(m.Since)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	if m.TailLines != 0 {
		n += 1 + sovProto(uint64(m.TailLines))
	}
	if m.BytesLimit != 0 {
		n += 1 + sovProto(uint64(m.BytesLimit))
	}
	if m.Previous {
		n += 2
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *ContainerExecOrAttachCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	if m.Stdin {
		n += 2
	}
	if m.Stdout {
		n += 2
	}
	if m.Stderr {
		n += 2
	}
	if m.Tty {
		n += 2
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovProto(uint64(l))
		}
	}
	if len(m.Envs) > 0 {
		for k, v := range m.Envs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovProto(uint64(len(k))) + 1 + len(v) + sovProto(uint64(len(v)))
			n += mapEntrySize + 1 + sovProto(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PodPortForwardCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovProto(uint64(m.Port))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *ContainerTerminalResizeCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cols != 0 {
		n += 1 + sovProto(uint64(m.Cols))
	}
	if m.Rows != 0 {
		n += 1 + sovProto(uint64(m.Rows))
	}
	return n
}

func (m *ErrorMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovProto(uint64(m.Kind))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovProto(uint64(m.Code))
	}
	return n
}

func (m *StateMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovProto(uint64(m.Kind))
	}
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func sovProto(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProto(x uint64) (n int) {
	return sovProto(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`}`,
	}, "")
	return s
}
func (this *Header) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Header{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Sid:` + fmt.Sprintf("%v", this.Sid) + `,`,
		`Seq:` + fmt.Sprintf("%v", this.Seq) + `,`,
		`Completed:` + fmt.Sprintf("%v", this.Completed) + `,`,
		`SubSeq:` + fmt.Sprintf("%v", this.SubSeq) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Cmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Cmd{`,
		`Header:` + strings.Replace(this.Header.String(), "Header", "Header", 1) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Msg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Msg{`,
		`Header:` + strings.Replace(this.Header.String(), "Header", "Header", 1) + `,`,
		`OnlineId:` + fmt.Sprintf("%v", this.OnlineId) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInfoGetCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInfoGetCmd{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SessionCloseCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SessionCloseCmd{`,
		`Sid:` + fmt.Sprintf("%v", this.Sid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RejectCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RejectCmd{`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerLogsCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerLogsCmd{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Container:` + fmt.Sprintf("%v", this.Container) + `,`,
		`Follow:` + fmt.Sprintf("%v", this.Follow) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Since:` + fmt.Sprintf("%v", this.Since) + `,`,
		`TailLines:` + fmt.Sprintf("%v", this.TailLines) + `,`,
		`BytesLimit:` + fmt.Sprintf("%v", this.BytesLimit) + `,`,
		`Previous:` + fmt.Sprintf("%v", this.Previous) + `,`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerExecOrAttachCmd) String() string {
	if this == nil {
		return "nil"
	}
	keysForEnvs := make([]string, 0, len(this.Envs))
	for k, _ := range this.Envs {
		keysForEnvs = append(keysForEnvs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEnvs)
	mapStringForEnvs := "map[string]string{"
	for _, k := range keysForEnvs {
		mapStringForEnvs += fmt.Sprintf("%v: %v,", k, this.Envs[k])
	}
	mapStringForEnvs += "}"
	s := strings.Join([]string{`&ContainerExecOrAttachCmd{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Container:` + fmt.Sprintf("%v", this.Container) + `,`,
		`Stdin:` + fmt.Sprintf("%v", this.Stdin) + `,`,
		`Stdout:` + fmt.Sprintf("%v", this.Stdout) + `,`,
		`Stderr:` + fmt.Sprintf("%v", this.Stderr) + `,`,
		`Tty:` + fmt.Sprintf("%v", this.Tty) + `,`,
		`Command:` + fmt.Sprintf("%v", this.Command) + `,`,
		`Envs:` + mapStringForEnvs + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodPortForwardCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodPortForwardCmd{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerTerminalResizeCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerTerminalResizeCmd{`,
		`Cols:` + fmt.Sprintf("%v", this.Cols) + `,`,
		`Rows:` + fmt.Sprintf("%v", this.Rows) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ErrorMsg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ErrorMsg{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StateMsg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StateMsg{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`DeviceId:` + fmt.Sprintf("%v", this.DeviceId) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringProto(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Completed = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubSeq", wireType)
			}
			m.SubSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubSeq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Msg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Msg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Msg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnlineId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfoGetCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfoGetCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfoGetCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= NodeInfoGetCmd_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionCloseCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionCloseCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionCloseCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RejectCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RejectCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RejectCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= RejectCmd_Reason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerLogsCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerLogsCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerLogsCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Follow = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timestamp = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Since", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Since = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TailLines", wireType)
			}
			m.TailLines = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TailLines |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesLimit", wireType)
			}
			m.BytesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Previous", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Previous = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerExecOrAttachCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerExecOrAttachCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerExecOrAttachCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stdin = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stdout = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stderr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stderr = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tty = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Envs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Envs == nil {
				m.Envs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProto
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProto
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProto
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthProto
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProto
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProto
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthProto
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProto(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthProto
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Envs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodPortForwardCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodPortForwardCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodPortForwardCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerTerminalResizeCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerTerminalResizeCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerTerminalResizeCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			m.Cols = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cols |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			m.Rows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rows |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= ErrorMsg_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= StateMsg_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProto(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProto
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProto
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProto
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProto
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProto
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProto
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProto        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProto          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProto = fmt.Errorf("proto: unexpected end of group")
)
