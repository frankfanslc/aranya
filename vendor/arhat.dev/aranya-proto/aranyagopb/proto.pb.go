// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto.proto

package aranyagopb

import (
	bytes "bytes"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CmdType int32

const (
	// 0-4: raw data related cmd
	CMD_DATA_UPSTREAM CmdType = 0
	CMD_SESSION_CLOSE CmdType = 5
	CMD_REJECT        CmdType = 6
	// 11-19: node operations
	CMD_NODE_INFO_GET CmdType = 11
	CMD_EXEC          CmdType = 12
	CMD_ATTACH        CmdType = 13
	CMD_LOGS          CmdType = 14
	CMD_TTY_RESIZE    CmdType = 15
	CMD_PORT_FORWARD  CmdType = 16
	// 21-29: metrics operations
	CMD_METRICS_CONFIG  CmdType = 21
	CMD_METRICS_COLLECT CmdType = 22
	// 31-39: credentials operations
	CMD_CRED_ENSURE CmdType = 31
	// 41-49: container image / application bundle operations
	CMD_IMAGE_LIST   CmdType = 41
	CMD_IMAGE_ENSURE CmdType = 42
	CMD_IMAGE_DELETE CmdType = 43
	// 51-59: storage operations (remote csi)
	CMD_STORAGE_LIST   CmdType = 51
	CMD_STORAGE_ENSURE CmdType = 52
	CMD_STORAGE_DELETE CmdType = 53
	// 61-69: pod container provision
	CMD_POD_LIST   CmdType = 61
	CMD_POD_ENSURE CmdType = 62
	CMD_POD_DELETE CmdType = 63
	// 71-79: device operations
	CMD_DEVICE_LIST            CmdType = 71
	CMD_DEVICE_ENSURE          CmdType = 72
	CMD_DEVICE_DELETE          CmdType = 73
	CMD_DEVICE_OPERATE         CmdType = 74
	CMD_DEVICE_COLLECT_METRICS CmdType = 75
	// 81-89: network operations, both container and host
	CMD_CTR_NET_LIST   CmdType = 81
	CMD_CTR_NET_ENSURE CmdType = 82
	CMD_CTR_NET_DELETE CmdType = 83
	CMD_HOST_NET_LIST  CmdType = 84
)

var CmdType_name = map[int32]string{
	0:  "CMD_DATA_UPSTREAM",
	5:  "CMD_SESSION_CLOSE",
	6:  "CMD_REJECT",
	11: "CMD_NODE_INFO_GET",
	12: "CMD_EXEC",
	13: "CMD_ATTACH",
	14: "CMD_LOGS",
	15: "CMD_TTY_RESIZE",
	16: "CMD_PORT_FORWARD",
	21: "CMD_METRICS_CONFIG",
	22: "CMD_METRICS_COLLECT",
	31: "CMD_CRED_ENSURE",
	41: "CMD_IMAGE_LIST",
	42: "CMD_IMAGE_ENSURE",
	43: "CMD_IMAGE_DELETE",
	51: "CMD_STORAGE_LIST",
	52: "CMD_STORAGE_ENSURE",
	53: "CMD_STORAGE_DELETE",
	61: "CMD_POD_LIST",
	62: "CMD_POD_ENSURE",
	63: "CMD_POD_DELETE",
	71: "CMD_DEVICE_LIST",
	72: "CMD_DEVICE_ENSURE",
	73: "CMD_DEVICE_DELETE",
	74: "CMD_DEVICE_OPERATE",
	75: "CMD_DEVICE_COLLECT_METRICS",
	81: "CMD_CTR_NET_LIST",
	82: "CMD_CTR_NET_ENSURE",
	83: "CMD_CTR_NET_DELETE",
	84: "CMD_HOST_NET_LIST",
}

var CmdType_value = map[string]int32{
	"CMD_DATA_UPSTREAM":          0,
	"CMD_SESSION_CLOSE":          5,
	"CMD_REJECT":                 6,
	"CMD_NODE_INFO_GET":          11,
	"CMD_EXEC":                   12,
	"CMD_ATTACH":                 13,
	"CMD_LOGS":                   14,
	"CMD_TTY_RESIZE":             15,
	"CMD_PORT_FORWARD":           16,
	"CMD_METRICS_CONFIG":         21,
	"CMD_METRICS_COLLECT":        22,
	"CMD_CRED_ENSURE":            31,
	"CMD_IMAGE_LIST":             41,
	"CMD_IMAGE_ENSURE":           42,
	"CMD_IMAGE_DELETE":           43,
	"CMD_STORAGE_LIST":           51,
	"CMD_STORAGE_ENSURE":         52,
	"CMD_STORAGE_DELETE":         53,
	"CMD_POD_LIST":               61,
	"CMD_POD_ENSURE":             62,
	"CMD_POD_DELETE":             63,
	"CMD_DEVICE_LIST":            71,
	"CMD_DEVICE_ENSURE":          72,
	"CMD_DEVICE_DELETE":          73,
	"CMD_DEVICE_OPERATE":         74,
	"CMD_DEVICE_COLLECT_METRICS": 75,
	"CMD_CTR_NET_LIST":           81,
	"CMD_CTR_NET_ENSURE":         82,
	"CMD_CTR_NET_DELETE":         83,
	"CMD_HOST_NET_LIST":          84,
}

func (CmdType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{0}
}

type MsgType int32

const (
	MSG_DATA         MsgType = 0
	MSG_DATA_DEFAULT MsgType = 0
	MSG_DATA_STDOUT  MsgType = 0
	MSG_DATA_METRICS MsgType = 0
	MSG_DATA_STDERR  MsgType = 1
	MSG_DONE         MsgType = 5
	MSG_STATE        MsgType = 6
	MSG_ERROR        MsgType = 7
	// 11-19: node msgs
	MSG_NODE_STATUS MsgType = 11
	// 31-39: credential msgs
	MSG_CRED_STATUS MsgType = 31
	// 41-49: image msgs
	MSG_IMAGE_STATUS      MsgType = 41
	MSG_IMAGE_STATUS_LIST MsgType = 42
	// 51-59: storage msgs
	MSG_STORAGE_STATUS      MsgType = 51
	MSG_STORAGE_STATUS_LIST MsgType = 52
	// 61-69: pod msgs
	MSG_POD_STATUS      MsgType = 61
	MSG_POD_STATUS_LIST MsgType = 62
	// 71-79: device msgs
	MSG_DEVICE_STATUS           MsgType = 71
	MSG_DEVICE_STATUS_LIST      MsgType = 72
	MSG_DEVICE_OPERATION_RESULT MsgType = 73
	// 81-89: network msgs
	MSG_CTR_NET_STATUS      MsgType = 81
	MSG_CTR_NET_STATUS_LIST MsgType = 82
	MSG_HOST_NET_STATUS     MsgType = 83
)

var MsgType_name = map[int32]string{
	0: "MSG_DATA",
	// Duplicate value: 0: "MSG_DATA_DEFAULT",
	// Duplicate value: 0: "MSG_DATA_STDOUT",
	// Duplicate value: 0: "MSG_DATA_METRICS",
	1:  "MSG_DATA_STDERR",
	5:  "MSG_DONE",
	6:  "MSG_STATE",
	7:  "MSG_ERROR",
	11: "MSG_NODE_STATUS",
	31: "MSG_CRED_STATUS",
	41: "MSG_IMAGE_STATUS",
	42: "MSG_IMAGE_STATUS_LIST",
	51: "MSG_STORAGE_STATUS",
	52: "MSG_STORAGE_STATUS_LIST",
	61: "MSG_POD_STATUS",
	62: "MSG_POD_STATUS_LIST",
	71: "MSG_DEVICE_STATUS",
	72: "MSG_DEVICE_STATUS_LIST",
	73: "MSG_DEVICE_OPERATION_RESULT",
	81: "MSG_CTR_NET_STATUS",
	82: "MSG_CTR_NET_STATUS_LIST",
	83: "MSG_HOST_NET_STATUS",
}

var MsgType_value = map[string]int32{
	"MSG_DATA":                    0,
	"MSG_DATA_DEFAULT":            0,
	"MSG_DATA_STDOUT":             0,
	"MSG_DATA_METRICS":            0,
	"MSG_DATA_STDERR":             1,
	"MSG_DONE":                    5,
	"MSG_STATE":                   6,
	"MSG_ERROR":                   7,
	"MSG_NODE_STATUS":             11,
	"MSG_CRED_STATUS":             31,
	"MSG_IMAGE_STATUS":            41,
	"MSG_IMAGE_STATUS_LIST":       42,
	"MSG_STORAGE_STATUS":          51,
	"MSG_STORAGE_STATUS_LIST":     52,
	"MSG_POD_STATUS":              61,
	"MSG_POD_STATUS_LIST":         62,
	"MSG_DEVICE_STATUS":           71,
	"MSG_DEVICE_STATUS_LIST":      72,
	"MSG_DEVICE_OPERATION_RESULT": 73,
	"MSG_CTR_NET_STATUS":          81,
	"MSG_CTR_NET_STATUS_LIST":     82,
	"MSG_HOST_NET_STATUS":         83,
}

func (MsgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{1}
}

type RejectionReason int32

const (
	_INVALID_REJECTION_REASON       RejectionReason = 0
	REJECTION_INVALID_PROTO         RejectionReason = 1
	REJECTION_ALREADY_CONNECTED     RejectionReason = 2
	REJECTION_INITIAL_CHECK_FAILURE RejectionReason = 3
	REJECTION_INTERNAL_SERVER_ERROR RejectionReason = 4
)

var RejectionReason_name = map[int32]string{
	0: "_INVALID_REJECTION_REASON",
	1: "REJECTION_INVALID_PROTO",
	2: "REJECTION_ALREADY_CONNECTED",
	3: "REJECTION_INITIAL_CHECK_FAILURE",
	4: "REJECTION_INTERNAL_SERVER_ERROR",
}

var RejectionReason_value = map[string]int32{
	"_INVALID_REJECTION_REASON":       0,
	"REJECTION_INVALID_PROTO":         1,
	"REJECTION_ALREADY_CONNECTED":     2,
	"REJECTION_INITIAL_CHECK_FAILURE": 3,
	"REJECTION_INTERNAL_SERVER_ERROR": 4,
}

func (RejectionReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{2}
}

type NodeInfoGetCmd_Kind int32

const (
	NODE_INFO_DYN NodeInfoGetCmd_Kind = 0
	NODE_INFO_ALL NodeInfoGetCmd_Kind = 1
)

var NodeInfoGetCmd_Kind_name = map[int32]string{
	0: "NODE_INFO_DYN",
	1: "NODE_INFO_ALL",
}

var NodeInfoGetCmd_Kind_value = map[string]int32{
	"NODE_INFO_DYN": 0,
	"NODE_INFO_ALL": 1,
}

func (NodeInfoGetCmd_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{3, 0}
}

type ErrorMsg_Kind int32

const (
	// ERR_COMMON means Error happened, but we don't know what to do,
	// report as failure and retry later.
	ERR_COMMON ErrorMsg_Kind = 0
	// ERR_NOT_FOUND means something not found but may be expected by
	// the scheduler, aranya should schedule according task or ignore.
	ERR_NOT_FOUND ErrorMsg_Kind = 1
	// ERR_ALREADY_EXISTS means something expected by the scheduler already
	// exists in agent, agent only report this error when it's sure the
	// existing object is the same with the one expected by the scheduler,
	// otherwise it should report ERR_NOT_FOUND.
	ERR_ALREADY_EXISTS ErrorMsg_Kind = 2
	// ERR_NOT_SUPPORTED means Cmd not supported by the agent,
	// aranya should ignore this error and cancel all future
	// job.
	ERR_NOT_SUPPORTED ErrorMsg_Kind = 3
	// ERR_TIMEOUT only happens in connectivity server,
	// right after the session is timed out
	ERR_TIMEOUT ErrorMsg_Kind = 4
)

var ErrorMsg_Kind_name = map[int32]string{
	0: "ERR_COMMON",
	1: "ERR_NOT_FOUND",
	2: "ERR_ALREADY_EXISTS",
	3: "ERR_NOT_SUPPORTED",
	4: "ERR_TIMEOUT",
}

var ErrorMsg_Kind_value = map[string]int32{
	"ERR_COMMON":         0,
	"ERR_NOT_FOUND":      1,
	"ERR_ALREADY_EXISTS": 2,
	"ERR_NOT_SUPPORTED":  3,
	"ERR_TIMEOUT":        4,
}

func (ErrorMsg_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{10, 0}
}

type StateMsg_Kind int32

const (
	_INVALID_STATE StateMsg_Kind = 0
	STATE_ONLINE   StateMsg_Kind = 1
	STATE_OFFLINE  StateMsg_Kind = 2
)

var StateMsg_Kind_name = map[int32]string{
	0: "_INVALID_STATE",
	1: "STATE_ONLINE",
	2: "STATE_OFFLINE",
}

var StateMsg_Kind_value = map[string]int32{
	"_INVALID_STATE": 0,
	"STATE_ONLINE":   1,
	"STATE_OFFLINE":  2,
}

func (StateMsg_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{11, 0}
}

type Empty struct {
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type Cmd struct {
	Kind CmdType `protobuf:"varint,1,opt,name=kind,proto3,enum=aranya.CmdType" json:"kind,omitempty"`
	// session id
	Sid uint64 `protobuf:"varint,2,opt,name=sid,proto3" json:"sid,omitempty"`
	// sequence in the session, to ensure ordered data
	Seq uint64 `protobuf:"varint,3,opt,name=seq,proto3" json:"seq,omitempty"`
	// mark this Cmd is the last piece in the session
	Completed bool `protobuf:"varint,4,opt,name=completed,proto3" json:"completed,omitempty"`
	// body of encoded XxxCmd or raw data bytes
	Body []byte `protobuf:"bytes,11,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *Cmd) Reset()      { *m = Cmd{} }
func (*Cmd) ProtoMessage() {}
func (*Cmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{1}
}
func (m *Cmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cmd.Merge(m, src)
}
func (m *Cmd) XXX_Size() int {
	return m.Size()
}
func (m *Cmd) XXX_DiscardUnknown() {
	xxx_messageInfo_Cmd.DiscardUnknown(m)
}

var xxx_messageInfo_Cmd proto.InternalMessageInfo

func (m *Cmd) GetKind() CmdType {
	if m != nil {
		return m.Kind
	}
	return CMD_DATA_UPSTREAM
}

func (m *Cmd) GetSid() uint64 {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *Cmd) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *Cmd) GetCompleted() bool {
	if m != nil {
		return m.Completed
	}
	return false
}

func (m *Cmd) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type Msg struct {
	Kind MsgType `protobuf:"varint,1,opt,name=kind,proto3,enum=aranya.MsgType" json:"kind,omitempty"`
	// session id
	Sid uint64 `protobuf:"varint,2,opt,name=sid,proto3" json:"sid,omitempty"`
	// sequence in the session, to ensure ordered data
	Seq uint64 `protobuf:"varint,3,opt,name=seq,proto3" json:"seq,omitempty"`
	// mark this Msg is the last piece in the session
	Completed bool `protobuf:"varint,4,opt,name=completed,proto3" json:"completed,omitempty"`
	// body of encoded XxxMsg or raw data bytes
	Body []byte `protobuf:"bytes,11,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *Msg) Reset()      { *m = Msg{} }
func (*Msg) ProtoMessage() {}
func (*Msg) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{2}
}
func (m *Msg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Msg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Msg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Msg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Msg.Merge(m, src)
}
func (m *Msg) XXX_Size() int {
	return m.Size()
}
func (m *Msg) XXX_DiscardUnknown() {
	xxx_messageInfo_Msg.DiscardUnknown(m)
}

var xxx_messageInfo_Msg proto.InternalMessageInfo

func (m *Msg) GetKind() MsgType {
	if m != nil {
		return m.Kind
	}
	return MSG_DATA
}

func (m *Msg) GetSid() uint64 {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *Msg) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *Msg) GetCompleted() bool {
	if m != nil {
		return m.Completed
	}
	return false
}

func (m *Msg) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type NodeInfoGetCmd struct {
	Kind NodeInfoGetCmd_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=aranya.NodeInfoGetCmd_Kind" json:"kind,omitempty"`
}

func (m *NodeInfoGetCmd) Reset()      { *m = NodeInfoGetCmd{} }
func (*NodeInfoGetCmd) ProtoMessage() {}
func (*NodeInfoGetCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{3}
}
func (m *NodeInfoGetCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfoGetCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfoGetCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfoGetCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfoGetCmd.Merge(m, src)
}
func (m *NodeInfoGetCmd) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfoGetCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfoGetCmd.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfoGetCmd proto.InternalMessageInfo

func (m *NodeInfoGetCmd) GetKind() NodeInfoGetCmd_Kind {
	if m != nil {
		return m.Kind
	}
	return NODE_INFO_DYN
}

type SessionCloseCmd struct {
	Sid uint64 `protobuf:"varint,1,opt,name=sid,proto3" json:"sid,omitempty"`
}

func (m *SessionCloseCmd) Reset()      { *m = SessionCloseCmd{} }
func (*SessionCloseCmd) ProtoMessage() {}
func (*SessionCloseCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{4}
}
func (m *SessionCloseCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionCloseCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionCloseCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionCloseCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionCloseCmd.Merge(m, src)
}
func (m *SessionCloseCmd) XXX_Size() int {
	return m.Size()
}
func (m *SessionCloseCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionCloseCmd.DiscardUnknown(m)
}

var xxx_messageInfo_SessionCloseCmd proto.InternalMessageInfo

func (m *SessionCloseCmd) GetSid() uint64 {
	if m != nil {
		return m.Sid
	}
	return 0
}

type RejectCmd struct {
	Reason  RejectionReason `protobuf:"varint,1,opt,name=reason,proto3,enum=aranya.RejectionReason" json:"reason,omitempty"`
	Message string          `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *RejectCmd) Reset()      { *m = RejectCmd{} }
func (*RejectCmd) ProtoMessage() {}
func (*RejectCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{5}
}
func (m *RejectCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RejectCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RejectCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RejectCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RejectCmd.Merge(m, src)
}
func (m *RejectCmd) XXX_Size() int {
	return m.Size()
}
func (m *RejectCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_RejectCmd.DiscardUnknown(m)
}

var xxx_messageInfo_RejectCmd proto.InternalMessageInfo

func (m *RejectCmd) GetReason() RejectionReason {
	if m != nil {
		return m.Reason
	}
	return _INVALID_REJECTION_REASON
}

func (m *RejectCmd) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type LogsCmd struct {
	PodUid     string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	Container  string `protobuf:"bytes,2,opt,name=container,proto3" json:"container,omitempty"`
	Follow     bool   `protobuf:"varint,3,opt,name=follow,proto3" json:"follow,omitempty"`
	Timestamp  bool   `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Since      string `protobuf:"bytes,5,opt,name=since,proto3" json:"since,omitempty"`
	TailLines  int64  `protobuf:"varint,6,opt,name=tail_lines,json=tailLines,proto3" json:"tail_lines,omitempty"`
	BytesLimit int64  `protobuf:"varint,7,opt,name=bytes_limit,json=bytesLimit,proto3" json:"bytes_limit,omitempty"`
	Previous   bool   `protobuf:"varint,8,opt,name=previous,proto3" json:"previous,omitempty"`
	// host log path
	Path string `protobuf:"bytes,9,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *LogsCmd) Reset()      { *m = LogsCmd{} }
func (*LogsCmd) ProtoMessage() {}
func (*LogsCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{6}
}
func (m *LogsCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogsCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogsCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogsCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogsCmd.Merge(m, src)
}
func (m *LogsCmd) XXX_Size() int {
	return m.Size()
}
func (m *LogsCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_LogsCmd.DiscardUnknown(m)
}

var xxx_messageInfo_LogsCmd proto.InternalMessageInfo

func (m *LogsCmd) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *LogsCmd) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *LogsCmd) GetFollow() bool {
	if m != nil {
		return m.Follow
	}
	return false
}

func (m *LogsCmd) GetTimestamp() bool {
	if m != nil {
		return m.Timestamp
	}
	return false
}

func (m *LogsCmd) GetSince() string {
	if m != nil {
		return m.Since
	}
	return ""
}

func (m *LogsCmd) GetTailLines() int64 {
	if m != nil {
		return m.TailLines
	}
	return 0
}

func (m *LogsCmd) GetBytesLimit() int64 {
	if m != nil {
		return m.BytesLimit
	}
	return 0
}

func (m *LogsCmd) GetPrevious() bool {
	if m != nil {
		return m.Previous
	}
	return false
}

func (m *LogsCmd) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Exec/Attach Cmd
type ExecOrAttachCmd struct {
	PodUid    string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	Container string `protobuf:"bytes,2,opt,name=container,proto3" json:"container,omitempty"`
	Stdin     bool   `protobuf:"varint,3,opt,name=stdin,proto3" json:"stdin,omitempty"`
	Stdout    bool   `protobuf:"varint,4,opt,name=stdout,proto3" json:"stdout,omitempty"`
	Stderr    bool   `protobuf:"varint,5,opt,name=stderr,proto3" json:"stderr,omitempty"`
	Tty       bool   `protobuf:"varint,6,opt,name=tty,proto3" json:"tty,omitempty"`
	// command is empty when used for container attach
	Command []string `protobuf:"bytes,7,rep,name=command,proto3" json:"command,omitempty"`
	// environment variables when used with virtual host container image
	// values are resolved by aranya
	Envs map[string]string `protobuf:"bytes,8,rep,name=envs,proto3" json:"envs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ExecOrAttachCmd) Reset()      { *m = ExecOrAttachCmd{} }
func (*ExecOrAttachCmd) ProtoMessage() {}
func (*ExecOrAttachCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{7}
}
func (m *ExecOrAttachCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecOrAttachCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecOrAttachCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecOrAttachCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecOrAttachCmd.Merge(m, src)
}
func (m *ExecOrAttachCmd) XXX_Size() int {
	return m.Size()
}
func (m *ExecOrAttachCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecOrAttachCmd.DiscardUnknown(m)
}

var xxx_messageInfo_ExecOrAttachCmd proto.InternalMessageInfo

func (m *ExecOrAttachCmd) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *ExecOrAttachCmd) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *ExecOrAttachCmd) GetStdin() bool {
	if m != nil {
		return m.Stdin
	}
	return false
}

func (m *ExecOrAttachCmd) GetStdout() bool {
	if m != nil {
		return m.Stdout
	}
	return false
}

func (m *ExecOrAttachCmd) GetStderr() bool {
	if m != nil {
		return m.Stderr
	}
	return false
}

func (m *ExecOrAttachCmd) GetTty() bool {
	if m != nil {
		return m.Tty
	}
	return false
}

func (m *ExecOrAttachCmd) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ExecOrAttachCmd) GetEnvs() map[string]string {
	if m != nil {
		return m.Envs
	}
	return nil
}

type PortForwardCmd struct {
	PodUid   string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	Port     int32  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	Protocol string `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty"`
}

func (m *PortForwardCmd) Reset()      { *m = PortForwardCmd{} }
func (*PortForwardCmd) ProtoMessage() {}
func (*PortForwardCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{8}
}
func (m *PortForwardCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortForwardCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortForwardCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortForwardCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortForwardCmd.Merge(m, src)
}
func (m *PortForwardCmd) XXX_Size() int {
	return m.Size()
}
func (m *PortForwardCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_PortForwardCmd.DiscardUnknown(m)
}

var xxx_messageInfo_PortForwardCmd proto.InternalMessageInfo

func (m *PortForwardCmd) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *PortForwardCmd) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *PortForwardCmd) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

type TerminalResizeCmd struct {
	Cols uint32 `protobuf:"varint,1,opt,name=cols,proto3" json:"cols,omitempty"`
	Rows uint32 `protobuf:"varint,2,opt,name=rows,proto3" json:"rows,omitempty"`
}

func (m *TerminalResizeCmd) Reset()      { *m = TerminalResizeCmd{} }
func (*TerminalResizeCmd) ProtoMessage() {}
func (*TerminalResizeCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{9}
}
func (m *TerminalResizeCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TerminalResizeCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TerminalResizeCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TerminalResizeCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TerminalResizeCmd.Merge(m, src)
}
func (m *TerminalResizeCmd) XXX_Size() int {
	return m.Size()
}
func (m *TerminalResizeCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_TerminalResizeCmd.DiscardUnknown(m)
}

var xxx_messageInfo_TerminalResizeCmd proto.InternalMessageInfo

func (m *TerminalResizeCmd) GetCols() uint32 {
	if m != nil {
		return m.Cols
	}
	return 0
}

func (m *TerminalResizeCmd) GetRows() uint32 {
	if m != nil {
		return m.Rows
	}
	return 0
}

// Error infomation
type ErrorMsg struct {
	Kind ErrorMsg_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=aranya.ErrorMsg_Kind" json:"kind,omitempty"`
	// Human readable error description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// error code may be used for:
	//  - exit code of command execution
	//  - ...TBD
	Code int64 `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *ErrorMsg) Reset()      { *m = ErrorMsg{} }
func (*ErrorMsg) ProtoMessage() {}
func (*ErrorMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{10}
}
func (m *ErrorMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrorMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ErrorMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ErrorMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrorMsg.Merge(m, src)
}
func (m *ErrorMsg) XXX_Size() int {
	return m.Size()
}
func (m *ErrorMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrorMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ErrorMsg proto.InternalMessageInfo

func (m *ErrorMsg) GetKind() ErrorMsg_Kind {
	if m != nil {
		return m.Kind
	}
	return ERR_COMMON
}

func (m *ErrorMsg) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ErrorMsg) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

// State of agent, online/offline
type StateMsg struct {
	Kind     StateMsg_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=aranya.StateMsg_Kind" json:"kind,omitempty"`
	DeviceId string        `protobuf:"bytes,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
}

func (m *StateMsg) Reset()      { *m = StateMsg{} }
func (*StateMsg) ProtoMessage() {}
func (*StateMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fcc84b9998d60d8, []int{11}
}
func (m *StateMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMsg.Merge(m, src)
}
func (m *StateMsg) XXX_Size() int {
	return m.Size()
}
func (m *StateMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMsg.DiscardUnknown(m)
}

var xxx_messageInfo_StateMsg proto.InternalMessageInfo

func (m *StateMsg) GetKind() StateMsg_Kind {
	if m != nil {
		return m.Kind
	}
	return _INVALID_STATE
}

func (m *StateMsg) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func init() {
	proto.RegisterEnum("aranya.CmdType", CmdType_name, CmdType_value)
	proto.RegisterEnum("aranya.MsgType", MsgType_name, MsgType_value)
	proto.RegisterEnum("aranya.RejectionReason", RejectionReason_name, RejectionReason_value)
	proto.RegisterEnum("aranya.NodeInfoGetCmd_Kind", NodeInfoGetCmd_Kind_name, NodeInfoGetCmd_Kind_value)
	proto.RegisterEnum("aranya.ErrorMsg_Kind", ErrorMsg_Kind_name, ErrorMsg_Kind_value)
	proto.RegisterEnum("aranya.StateMsg_Kind", StateMsg_Kind_name, StateMsg_Kind_value)
	proto.RegisterType((*Empty)(nil), "aranya.Empty")
	proto.RegisterType((*Cmd)(nil), "aranya.Cmd")
	proto.RegisterType((*Msg)(nil), "aranya.Msg")
	proto.RegisterType((*NodeInfoGetCmd)(nil), "aranya.NodeInfoGetCmd")
	proto.RegisterType((*SessionCloseCmd)(nil), "aranya.SessionCloseCmd")
	proto.RegisterType((*RejectCmd)(nil), "aranya.RejectCmd")
	proto.RegisterType((*LogsCmd)(nil), "aranya.LogsCmd")
	proto.RegisterType((*ExecOrAttachCmd)(nil), "aranya.ExecOrAttachCmd")
	proto.RegisterMapType((map[string]string)(nil), "aranya.ExecOrAttachCmd.EnvsEntry")
	proto.RegisterType((*PortForwardCmd)(nil), "aranya.PortForwardCmd")
	proto.RegisterType((*TerminalResizeCmd)(nil), "aranya.TerminalResizeCmd")
	proto.RegisterType((*ErrorMsg)(nil), "aranya.ErrorMsg")
	proto.RegisterType((*StateMsg)(nil), "aranya.StateMsg")
}

func init() { proto.RegisterFile("proto.proto", fileDescriptor_2fcc84b9998d60d8) }

var fileDescriptor_2fcc84b9998d60d8 = []byte{
	// 1469 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x96, 0x4d, 0x73, 0xd3, 0x46,
	0x1f, 0xc0, 0xad, 0xd8, 0xf1, 0xcb, 0x3a, 0x2f, 0xcb, 0x42, 0x12, 0x93, 0x3c, 0x38, 0xc1, 0x5c,
	0x42, 0x9e, 0xe7, 0x09, 0x33, 0xbc, 0x4c, 0x3b, 0xed, 0x00, 0xa3, 0x4a, 0x6b, 0x47, 0x20, 0x4b,
	0x61, 0x25, 0x07, 0xc2, 0x45, 0xa3, 0x58, 0x4b, 0x50, 0xb1, 0x25, 0x23, 0x29, 0xa1, 0xee, 0x89,
	0x8f, 0xd0, 0x69, 0xbf, 0x44, 0xa7, 0x9f, 0xa0, 0x1f, 0xa1, 0x47, 0x4e, 0x1d, 0x8e, 0x25, 0x5c,
	0x7a, 0xe4, 0x03, 0x70, 0xe8, 0xec, 0x6a, 0xd7, 0x89, 0xc3, 0x94, 0x4b, 0xa7, 0x17, 0xcf, 0xfe,
	0x7f, 0xfb, 0xdf, 0xff, 0xfb, 0xae, 0x0c, 0xea, 0xa3, 0x24, 0xce, 0xe2, 0x6d, 0xfe, 0x8b, 0xca,
	0x7e, 0xe2, 0x47, 0x63, 0xbf, 0x55, 0x01, 0xb3, 0x78, 0x38, 0xca, 0xc6, 0xad, 0xd7, 0x0a, 0x28,
	0x6a, 0xc3, 0x00, 0x5d, 0x03, 0xa5, 0x17, 0x61, 0x14, 0x34, 0x94, 0x0d, 0x65, 0x73, 0xe1, 0xe6,
	0xe2, 0x76, 0xae, 0xb7, 0xad, 0x0d, 0x03, 0x77, 0x3c, 0xa2, 0x84, 0x6f, 0x22, 0x08, 0x8a, 0x69,
	0x18, 0x34, 0x66, 0x36, 0x94, 0xcd, 0x12, 0x61, 0x4b, 0x4e, 0xe8, 0xcb, 0x46, 0x51, 0x10, 0xfa,
	0x12, 0xfd, 0x07, 0xd4, 0xfa, 0xf1, 0x70, 0x34, 0xa0, 0x19, 0x0d, 0x1a, 0xa5, 0x0d, 0x65, 0xb3,
	0x4a, 0x4e, 0x01, 0x42, 0xa0, 0x74, 0x10, 0x07, 0xe3, 0x46, 0x7d, 0x43, 0xd9, 0x9c, 0x23, 0x7c,
	0xcd, 0x43, 0xe8, 0xa6, 0x87, 0x7f, 0x17, 0x42, 0x37, 0x3d, 0xfc, 0xd7, 0x43, 0x88, 0xc1, 0x82,
	0x15, 0x07, 0xd4, 0x88, 0x9e, 0xc5, 0x1d, 0x9a, 0xb1, 0x7a, 0xdc, 0x98, 0x0a, 0x66, 0x4d, 0x06,
	0x33, 0xad, 0xb5, 0xfd, 0x30, 0x8c, 0x82, 0x3c, 0xb0, 0xd6, 0xff, 0x40, 0x89, 0x49, 0xe8, 0x02,
	0x98, 0xb7, 0x6c, 0x1d, 0x7b, 0x86, 0xd5, 0xb6, 0x3d, 0x7d, 0xdf, 0x82, 0x85, 0x69, 0xa4, 0x9a,
	0x26, 0x54, 0x5a, 0xd7, 0xc0, 0xa2, 0x43, 0xd3, 0x34, 0x8c, 0x23, 0x6d, 0x10, 0xa7, 0x94, 0x79,
	0x14, 0x99, 0x29, 0x93, 0xcc, 0x5a, 0x7b, 0xa0, 0x46, 0xe8, 0xb7, 0xb4, 0x2f, 0x02, 0x2a, 0x27,
	0xd4, 0x4f, 0xe3, 0x48, 0x84, 0xb4, 0x22, 0x43, 0xca, 0x55, 0xc2, 0x38, 0x22, 0x7c, 0x9b, 0x08,
	0x35, 0xd4, 0x00, 0x95, 0x21, 0x4d, 0x53, 0xff, 0x90, 0xf2, 0x6a, 0xd5, 0x88, 0x14, 0x5b, 0x1f,
	0x15, 0x50, 0x31, 0xe3, 0xc3, 0x94, 0x99, 0x5d, 0x01, 0x95, 0x51, 0x1c, 0x78, 0x47, 0xc2, 0x73,
	0x8d, 0x94, 0x47, 0x71, 0xd0, 0x0b, 0x83, 0xbc, 0x88, 0x51, 0xe6, 0x87, 0x11, 0x4d, 0x84, 0x81,
	0x53, 0x80, 0x96, 0x41, 0xf9, 0x59, 0x3c, 0x18, 0xc4, 0xaf, 0x78, 0xdd, 0xab, 0x44, 0x48, 0xec,
	0x54, 0x16, 0x0e, 0x69, 0x9a, 0xf9, 0xc3, 0x91, 0x2c, 0xfd, 0x04, 0xa0, 0x4b, 0x60, 0x36, 0x0d,
	0xa3, 0x3e, 0x6d, 0xcc, 0x72, 0x7b, 0xb9, 0x80, 0xae, 0x00, 0x90, 0xf9, 0xe1, 0xc0, 0x1b, 0x84,
	0x11, 0x4d, 0x1b, 0xe5, 0x0d, 0x65, 0xb3, 0x48, 0x6a, 0x8c, 0x98, 0x0c, 0xa0, 0x75, 0x50, 0x3f,
	0x18, 0x67, 0x34, 0xf5, 0x06, 0xe1, 0x30, 0xcc, 0x1a, 0x15, 0xbe, 0x0f, 0x38, 0x32, 0x19, 0x41,
	0xab, 0xa0, 0x3a, 0x4a, 0xe8, 0x71, 0x18, 0x1f, 0xa5, 0x8d, 0x2a, 0x77, 0x39, 0x91, 0x59, 0xb3,
	0x47, 0x7e, 0xf6, 0xbc, 0x51, 0xe3, 0x0e, 0xf9, 0xba, 0xf5, 0xcb, 0x0c, 0x58, 0xc4, 0xdf, 0xd1,
	0xbe, 0x9d, 0xa8, 0x59, 0xe6, 0xf7, 0x9f, 0xff, 0x83, 0x32, 0xb0, 0x84, 0xb2, 0x20, 0x8c, 0x44,
	0x15, 0x72, 0x81, 0x15, 0x27, 0xcd, 0x82, 0xf8, 0x28, 0x13, 0x15, 0x10, 0x92, 0xe0, 0x34, 0x49,
	0x78, 0xfe, 0x39, 0xa7, 0x49, 0xc2, 0x3a, 0x9f, 0x65, 0x63, 0x9e, 0x79, 0x95, 0xb0, 0x25, 0xeb,
	0x5d, 0x3f, 0x1e, 0x0e, 0xfd, 0x28, 0x68, 0x54, 0x36, 0x8a, 0xac, 0x77, 0x42, 0x44, 0x77, 0x40,
	0x89, 0x46, 0xc7, 0x2c, 0xd1, 0xe2, 0x66, 0xfd, 0xe6, 0x55, 0x39, 0x04, 0xe7, 0xf2, 0xd9, 0xc6,
	0xd1, 0x71, 0x8a, 0xa3, 0x2c, 0x19, 0x13, 0xae, 0xbe, 0xfa, 0x05, 0xa8, 0x4d, 0x10, 0xf3, 0xf7,
	0x82, 0x8e, 0x45, 0xa2, 0x6c, 0xc9, 0xf2, 0x38, 0xf6, 0x07, 0x47, 0x72, 0x52, 0x72, 0xe1, 0xab,
	0x99, 0x2f, 0x95, 0xd6, 0x3e, 0x58, 0xd8, 0x8d, 0x93, 0xac, 0x1d, 0x27, 0xaf, 0xfc, 0x24, 0xf8,
	0x6c, 0xa9, 0x58, 0xad, 0xe3, 0x24, 0xe3, 0x36, 0x66, 0x09, 0x5f, 0xe7, 0xbd, 0x89, 0xb3, 0xb8,
	0x1f, 0x0f, 0x78, 0x8d, 0x6a, 0x64, 0x22, 0xb7, 0xbe, 0x06, 0x17, 0x5c, 0x9a, 0x0c, 0xc3, 0xc8,
	0x1f, 0x10, 0x9a, 0x86, 0xdf, 0xf3, 0x5b, 0x80, 0x40, 0xa9, 0x1f, 0x0f, 0x52, 0x6e, 0x7a, 0x9e,
	0xf0, 0x35, 0x63, 0x49, 0xfc, 0x2a, 0xe5, 0x86, 0xe7, 0x09, 0x5f, 0xb7, 0x7e, 0x57, 0x40, 0x15,
	0x27, 0x49, 0x9c, 0xb0, 0x97, 0xe3, 0xfa, 0xd4, 0x65, 0x5d, 0x9a, 0x14, 0x45, 0xec, 0x9f, 0xb9,
	0xa6, 0x68, 0x03, 0xd4, 0x03, 0x9a, 0xf6, 0x93, 0x70, 0xc4, 0xae, 0x8c, 0xc8, 0xf7, 0x2c, 0xca,
	0x23, 0x08, 0x28, 0x0f, 0xb7, 0x48, 0xf8, 0xba, 0x15, 0x8a, 0xcb, 0xbd, 0x00, 0x00, 0x26, 0xc4,
	0xd3, 0xec, 0x6e, 0xd7, 0x16, 0x37, 0x9b, 0xc9, 0x96, 0xed, 0x7a, 0x6d, 0xbb, 0x67, 0xe9, 0x50,
	0x41, 0xcb, 0x00, 0x31, 0xa4, 0x9a, 0x04, 0xab, 0xfa, 0xbe, 0x87, 0x9f, 0x18, 0x8e, 0xeb, 0xc0,
	0x19, 0xb4, 0x04, 0x2e, 0x48, 0x55, 0xa7, 0xb7, 0xbb, 0x6b, 0x13, 0x17, 0xeb, 0xb0, 0x88, 0x16,
	0x41, 0x9d, 0x61, 0xd7, 0xe8, 0x62, 0xbb, 0xe7, 0xc2, 0x52, 0xeb, 0x27, 0x05, 0x54, 0x9d, 0xcc,
	0xcf, 0xe8, 0x67, 0x12, 0x93, 0xfb, 0x67, 0x13, 0x5b, 0x03, 0xb5, 0x80, 0x1e, 0x87, 0x7d, 0xea,
	0x89, 0xe7, 0xb1, 0x46, 0xaa, 0x39, 0x30, 0x82, 0xd6, 0x7d, 0x11, 0x3f, 0x02, 0x0b, 0x9e, 0x61,
	0xed, 0xa9, 0xa6, 0xa1, 0x7b, 0x8e, 0xab, 0xba, 0x18, 0x16, 0x10, 0x04, 0x73, 0x7c, 0xe9, 0xd9,
	0x96, 0x69, 0x58, 0x18, 0x2a, 0x2c, 0x2b, 0x41, 0xda, 0x6d, 0x8e, 0x66, 0xb6, 0x7e, 0x9c, 0x05,
	0x15, 0xf1, 0x2d, 0x60, 0x99, 0x68, 0x5d, 0xdd, 0xd3, 0x55, 0x57, 0xf5, 0x7a, 0xbb, 0x8e, 0x4b,
	0xb0, 0xda, 0x85, 0x05, 0x89, 0x1d, 0xec, 0x38, 0x86, 0x6d, 0x79, 0x9a, 0x69, 0x3b, 0x18, 0xce,
	0xb2, 0x92, 0x31, 0x4c, 0xf0, 0x03, 0xac, 0xb9, 0xb0, 0x2c, 0xd5, 0x4e, 0x1f, 0xc4, 0x0e, 0x76,
	0x61, 0x1d, 0xcd, 0x81, 0x2a, 0xc3, 0xf8, 0x09, 0xd6, 0xe0, 0x9c, 0x3c, 0xa4, 0xba, 0xae, 0xaa,
	0xed, 0xc0, 0x79, 0xb9, 0x6b, 0xda, 0x1d, 0x07, 0x2e, 0xb0, 0x2c, 0x98, 0xe4, 0xba, 0xfb, 0x1e,
	0xc1, 0x8e, 0xf1, 0x14, 0xc3, 0x45, 0x74, 0x09, 0x40, 0xc6, 0x58, 0x5d, 0xbd, 0xb6, 0x4d, 0x1e,
	0xab, 0x44, 0x87, 0x90, 0x35, 0x83, 0xd1, 0x2e, 0x76, 0x89, 0xa1, 0x39, 0x9e, 0x66, 0x5b, 0x6d,
	0xa3, 0x03, 0x97, 0xd0, 0x0a, 0xb8, 0x38, 0xcd, 0x4d, 0x93, 0x45, 0xb7, 0x8c, 0x2e, 0x82, 0x45,
	0xb6, 0xa1, 0x11, 0xac, 0x7b, 0xd8, 0x72, 0x7a, 0x04, 0xc3, 0x75, 0xe9, 0xcf, 0xe8, 0xaa, 0x1d,
	0xec, 0x99, 0x86, 0xe3, 0xc2, 0xeb, 0xd2, 0x5f, 0xce, 0x84, 0xe6, 0xd6, 0x34, 0xd5, 0xb1, 0x89,
	0x5d, 0x0c, 0xff, 0x2b, 0xa9, 0xe3, 0xda, 0x64, 0x62, 0xe1, 0x96, 0x8c, 0x4d, 0x52, 0x61, 0xe3,
	0xf6, 0x79, 0x2e, 0xac, 0xdc, 0x61, 0x7d, 0xca, 0x33, 0xd4, 0x73, 0x0b, 0x77, 0x65, 0x5c, 0x8c,
	0x88, 0xd3, 0xf7, 0xce, 0x32, 0x71, 0xf2, 0xbe, 0x4c, 0x4a, 0xc7, 0x7b, 0x86, 0x26, 0xdc, 0x77,
	0x26, 0x5d, 0xcc, 0xa1, 0x38, 0xbf, 0x73, 0x0e, 0x0b, 0x13, 0x86, 0x0c, 0x4a, 0x60, 0x7b, 0x17,
	0x13, 0x36, 0x3c, 0x0f, 0x50, 0x13, 0xac, 0x9e, 0xe1, 0xa2, 0x8e, 0xb2, 0xae, 0xf0, 0xa1, 0x4c,
	0x5d, 0x73, 0x89, 0x67, 0x61, 0x37, 0xf7, 0xfd, 0x48, 0x5a, 0x93, 0x54, 0x38, 0x27, 0xe7, 0xb9,
	0xf0, 0xee, 0xc8, 0xa0, 0x76, 0x6c, 0xc7, 0x3d, 0x35, 0xe3, 0x6e, 0x7d, 0x2c, 0x82, 0x8a, 0xf8,
	0x77, 0xc0, 0x26, 0xa4, 0xeb, 0x74, 0xf8, 0x50, 0xc2, 0x02, 0x73, 0x2b, 0x25, 0x4f, 0xc7, 0x6d,
	0xb5, 0x67, 0xba, 0xb0, 0xc0, 0xea, 0x30, 0xa1, 0x8e, 0xab, 0xb3, 0xfb, 0x36, 0xad, 0x2a, 0xe3,
	0xfe, 0x44, 0x15, 0x13, 0x02, 0x95, 0x89, 0x0f, 0xdb, 0x62, 0x83, 0x3d, 0x0f, 0x6a, 0x4c, 0xca,
	0xaf, 0x51, 0x59, 0x8a, 0x98, 0x10, 0x9b, 0xc0, 0x8a, 0x34, 0xc0, 0xc7, 0x9c, 0xa9, 0xf4, 0x1c,
	0x58, 0x97, 0x90, 0x4f, 0x97, 0x80, 0xeb, 0x32, 0x80, 0x7c, 0x66, 0x04, 0xbd, 0x8e, 0x2e, 0x83,
	0xa5, 0xf3, 0x34, 0x4f, 0x7b, 0x8b, 0x55, 0x29, 0x77, 0x9c, 0x0f, 0x88, 0x38, 0x72, 0x0b, 0xad,
	0x81, 0x95, 0x4f, 0x79, 0x7e, 0xe8, 0x36, 0x9b, 0x0b, 0xb6, 0xc9, 0xe6, 0x42, 0x1c, 0xb8, 0xcb,
	0x6e, 0xc1, 0x34, 0xcb, 0x95, 0xef, 0xb1, 0x7a, 0xf3, 0x44, 0xf3, 0xae, 0x0a, 0xfd, 0x0e, 0x5a,
	0x05, 0xcb, 0x9f, 0xe0, 0xfc, 0xc8, 0x0e, 0x5a, 0x07, 0x6b, 0x67, 0xf6, 0xf2, 0x01, 0x61, 0xcf,
	0x00, 0xc1, 0x0e, 0x2b, 0xbe, 0x21, 0xa3, 0x96, 0xbd, 0x15, 0x46, 0x1f, 0xc9, 0xa8, 0xa7, 0x79,
	0x6e, 0x95, 0xc8, 0x08, 0x27, 0x8d, 0x17, 0xa7, 0x9c, 0xd5, 0x19, 0xa8, 0x6c, 0xfd, 0xaa, 0x80,
	0xc5, 0x73, 0x7f, 0x7e, 0xd0, 0x15, 0x70, 0x79, 0xf2, 0xc0, 0xe5, 0x4f, 0x4e, 0x1e, 0x84, 0xea,
	0xf0, 0xf7, 0x7a, 0x0d, 0xac, 0x9c, 0x52, 0xa9, 0xb7, 0x4b, 0x6c, 0xd7, 0x86, 0x0a, 0x4b, 0xe1,
	0x74, 0x53, 0xbe, 0xdf, 0x9a, 0x6d, 0x59, 0x58, 0x63, 0x6f, 0xf5, 0x0c, 0xba, 0x06, 0xd6, 0xcf,
	0x9e, 0x36, 0x5c, 0x43, 0x35, 0x3d, 0x6d, 0x07, 0x6b, 0x0f, 0xbd, 0xb6, 0x6a, 0x98, 0x6c, 0x86,
	0x8b, 0xe7, 0x95, 0x5c, 0x4c, 0x2c, 0xd5, 0xf4, 0x1c, 0x4c, 0xf6, 0x30, 0x11, 0xd3, 0x51, 0xfa,
	0xe6, 0xf1, 0x9b, 0x77, 0xcd, 0xc2, 0xdb, 0x77, 0xcd, 0xc2, 0x87, 0x77, 0x4d, 0xe5, 0xf5, 0x49,
	0x53, 0xf9, 0xf9, 0xa4, 0xa9, 0xfc, 0x76, 0xd2, 0x54, 0xde, 0x9c, 0x34, 0x95, 0x3f, 0x4e, 0x9a,
	0xca, 0x9f, 0x27, 0xcd, 0xc2, 0x87, 0x93, 0xa6, 0xf2, 0xc3, 0xfb, 0x66, 0xe1, 0xcd, 0xfb, 0x66,
	0xe1, 0xed, 0xfb, 0x66, 0xe1, 0xe9, 0x55, 0x3f, 0x79, 0xee, 0x67, 0xdb, 0x01, 0x3d, 0xbe, 0x91,
	0x7f, 0x08, 0xfe, 0xcf, 0xbf, 0xa5, 0x42, 0x38, 0x8c, 0x47, 0x07, 0x07, 0x65, 0x4e, 0x6e, 0xfd,
	0x15, 0x00, 0x00, 0xff, 0xff, 0x1c, 0xe0, 0x1d, 0x8d, 0xf5, 0x0b, 0x00, 0x00,
}

func (x CmdType) String() string {
	s, ok := CmdType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MsgType) String() string {
	s, ok := MsgType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RejectionReason) String() string {
	s, ok := RejectionReason_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NodeInfoGetCmd_Kind) String() string {
	s, ok := NodeInfoGetCmd_Kind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ErrorMsg_Kind) String() string {
	s, ok := ErrorMsg_Kind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x StateMsg_Kind) String() string {
	s, ok := StateMsg_Kind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Cmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Cmd)
	if !ok {
		that2, ok := that.(Cmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Sid != that1.Sid {
		return false
	}
	if this.Seq != that1.Seq {
		return false
	}
	if this.Completed != that1.Completed {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	return true
}
func (this *Msg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg)
	if !ok {
		that2, ok := that.(Msg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Sid != that1.Sid {
		return false
	}
	if this.Seq != that1.Seq {
		return false
	}
	if this.Completed != that1.Completed {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	return true
}
func (this *NodeInfoGetCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInfoGetCmd)
	if !ok {
		that2, ok := that.(NodeInfoGetCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	return true
}
func (this *SessionCloseCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SessionCloseCmd)
	if !ok {
		that2, ok := that.(SessionCloseCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Sid != that1.Sid {
		return false
	}
	return true
}
func (this *RejectCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RejectCmd)
	if !ok {
		that2, ok := that.(RejectCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *LogsCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogsCmd)
	if !ok {
		that2, ok := that.(LogsCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.Container != that1.Container {
		return false
	}
	if this.Follow != that1.Follow {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Since != that1.Since {
		return false
	}
	if this.TailLines != that1.TailLines {
		return false
	}
	if this.BytesLimit != that1.BytesLimit {
		return false
	}
	if this.Previous != that1.Previous {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	return true
}
func (this *ExecOrAttachCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecOrAttachCmd)
	if !ok {
		that2, ok := that.(ExecOrAttachCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.Container != that1.Container {
		return false
	}
	if this.Stdin != that1.Stdin {
		return false
	}
	if this.Stdout != that1.Stdout {
		return false
	}
	if this.Stderr != that1.Stderr {
		return false
	}
	if this.Tty != that1.Tty {
		return false
	}
	if len(this.Command) != len(that1.Command) {
		return false
	}
	for i := range this.Command {
		if this.Command[i] != that1.Command[i] {
			return false
		}
	}
	if len(this.Envs) != len(that1.Envs) {
		return false
	}
	for i := range this.Envs {
		if this.Envs[i] != that1.Envs[i] {
			return false
		}
	}
	return true
}
func (this *PortForwardCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortForwardCmd)
	if !ok {
		that2, ok := that.(PortForwardCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	return true
}
func (this *TerminalResizeCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TerminalResizeCmd)
	if !ok {
		that2, ok := that.(TerminalResizeCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Cols != that1.Cols {
		return false
	}
	if this.Rows != that1.Rows {
		return false
	}
	return true
}
func (this *ErrorMsg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ErrorMsg)
	if !ok {
		that2, ok := that.(ErrorMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	return true
}
func (this *StateMsg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StateMsg)
	if !ok {
		that2, ok := that.(StateMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.DeviceId != that1.DeviceId {
		return false
	}
	return true
}
func (this *Empty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&aranyagopb.Empty{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Cmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&aranyagopb.Cmd{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Sid: "+fmt.Sprintf("%#v", this.Sid)+",\n")
	s = append(s, "Seq: "+fmt.Sprintf("%#v", this.Seq)+",\n")
	s = append(s, "Completed: "+fmt.Sprintf("%#v", this.Completed)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Msg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&aranyagopb.Msg{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Sid: "+fmt.Sprintf("%#v", this.Sid)+",\n")
	s = append(s, "Seq: "+fmt.Sprintf("%#v", this.Seq)+",\n")
	s = append(s, "Completed: "+fmt.Sprintf("%#v", this.Completed)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeInfoGetCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.NodeInfoGetCmd{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SessionCloseCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.SessionCloseCmd{")
	s = append(s, "Sid: "+fmt.Sprintf("%#v", this.Sid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RejectCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aranyagopb.RejectCmd{")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LogsCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&aranyagopb.LogsCmd{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Container: "+fmt.Sprintf("%#v", this.Container)+",\n")
	s = append(s, "Follow: "+fmt.Sprintf("%#v", this.Follow)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Since: "+fmt.Sprintf("%#v", this.Since)+",\n")
	s = append(s, "TailLines: "+fmt.Sprintf("%#v", this.TailLines)+",\n")
	s = append(s, "BytesLimit: "+fmt.Sprintf("%#v", this.BytesLimit)+",\n")
	s = append(s, "Previous: "+fmt.Sprintf("%#v", this.Previous)+",\n")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecOrAttachCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&aranyagopb.ExecOrAttachCmd{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Container: "+fmt.Sprintf("%#v", this.Container)+",\n")
	s = append(s, "Stdin: "+fmt.Sprintf("%#v", this.Stdin)+",\n")
	s = append(s, "Stdout: "+fmt.Sprintf("%#v", this.Stdout)+",\n")
	s = append(s, "Stderr: "+fmt.Sprintf("%#v", this.Stderr)+",\n")
	s = append(s, "Tty: "+fmt.Sprintf("%#v", this.Tty)+",\n")
	s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	keysForEnvs := make([]string, 0, len(this.Envs))
	for k, _ := range this.Envs {
		keysForEnvs = append(keysForEnvs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEnvs)
	mapStringForEnvs := "map[string]string{"
	for _, k := range keysForEnvs {
		mapStringForEnvs += fmt.Sprintf("%#v: %#v,", k, this.Envs[k])
	}
	mapStringForEnvs += "}"
	if this.Envs != nil {
		s = append(s, "Envs: "+mapStringForEnvs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortForwardCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&aranyagopb.PortForwardCmd{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TerminalResizeCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aranyagopb.TerminalResizeCmd{")
	s = append(s, "Cols: "+fmt.Sprintf("%#v", this.Cols)+",\n")
	s = append(s, "Rows: "+fmt.Sprintf("%#v", this.Rows)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ErrorMsg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&aranyagopb.ErrorMsg{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StateMsg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aranyagopb.StateMsg{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "DeviceId: "+fmt.Sprintf("%#v", this.DeviceId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringProto(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Cmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Completed {
		i--
		if m.Completed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Seq != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x18
	}
	if m.Sid != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x10
	}
	if m.Kind != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Msg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Msg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Completed {
		i--
		if m.Completed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Seq != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x18
	}
	if m.Sid != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x10
	}
	if m.Kind != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeInfoGetCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfoGetCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfoGetCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionCloseCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionCloseCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionCloseCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sid != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RejectCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RejectCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RejectCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Reason != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Reason))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogsCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogsCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogsCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Previous {
		i--
		if m.Previous {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.BytesLimit != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.BytesLimit))
		i--
		dAtA[i] = 0x38
	}
	if m.TailLines != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.TailLines))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Since) > 0 {
		i -= len(m.Since)
		copy(dAtA[i:], m.Since)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Since)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Timestamp {
		i--
		if m.Timestamp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Follow {
		i--
		if m.Follow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Container) > 0 {
		i -= len(m.Container)
		copy(dAtA[i:], m.Container)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Container)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PodUid) > 0 {
		i -= len(m.PodUid)
		copy(dAtA[i:], m.PodUid)
		i = encodeVarintProto(dAtA, i, uint64(len(m.PodUid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecOrAttachCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecOrAttachCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecOrAttachCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Envs) > 0 {
		for k := range m.Envs {
			v := m.Envs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintProto(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintProto(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintProto(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Command) > 0 {
		for iNdEx := len(m.Command) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Command[iNdEx])
			copy(dAtA[i:], m.Command[iNdEx])
			i = encodeVarintProto(dAtA, i, uint64(len(m.Command[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Tty {
		i--
		if m.Tty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Stderr {
		i--
		if m.Stderr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Stdout {
		i--
		if m.Stdout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Stdin {
		i--
		if m.Stdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Container) > 0 {
		i -= len(m.Container)
		copy(dAtA[i:], m.Container)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Container)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PodUid) > 0 {
		i -= len(m.PodUid)
		copy(dAtA[i:], m.PodUid)
		i = encodeVarintProto(dAtA, i, uint64(len(m.PodUid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PortForwardCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortForwardCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortForwardCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Port != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PodUid) > 0 {
		i -= len(m.PodUid)
		copy(dAtA[i:], m.PodUid)
		i = encodeVarintProto(dAtA, i, uint64(len(m.PodUid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TerminalResizeCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TerminalResizeCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TerminalResizeCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rows != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Rows))
		i--
		dAtA[i] = 0x10
	}
	if m.Cols != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Cols))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ErrorMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ErrorMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProto(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.Kind != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintProto(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Kind != 0 {
		i = encodeVarintProto(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintProto(dAtA []byte, offset int, v uint64) int {
	offset -= sovProto(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Cmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovProto(uint64(m.Kind))
	}
	if m.Sid != 0 {
		n += 1 + sovProto(uint64(m.Sid))
	}
	if m.Seq != 0 {
		n += 1 + sovProto(uint64(m.Seq))
	}
	if m.Completed {
		n += 2
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *Msg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovProto(uint64(m.Kind))
	}
	if m.Sid != 0 {
		n += 1 + sovProto(uint64(m.Sid))
	}
	if m.Seq != 0 {
		n += 1 + sovProto(uint64(m.Seq))
	}
	if m.Completed {
		n += 2
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *NodeInfoGetCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovProto(uint64(m.Kind))
	}
	return n
}

func (m *SessionCloseCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sid != 0 {
		n += 1 + sovProto(uint64(m.Sid))
	}
	return n
}

func (m *RejectCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reason != 0 {
		n += 1 + sovProto(uint64(m.Reason))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *LogsCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	if m.Follow {
		n += 2
	}
	if m.Timestamp {
		n += 2
	}
	l = len(m.Since)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	if m.TailLines != 0 {
		n += 1 + sovProto(uint64(m.TailLines))
	}
	if m.BytesLimit != 0 {
		n += 1 + sovProto(uint64(m.BytesLimit))
	}
	if m.Previous {
		n += 2
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *ExecOrAttachCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	if m.Stdin {
		n += 2
	}
	if m.Stdout {
		n += 2
	}
	if m.Stderr {
		n += 2
	}
	if m.Tty {
		n += 2
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovProto(uint64(l))
		}
	}
	if len(m.Envs) > 0 {
		for k, v := range m.Envs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovProto(uint64(len(k))) + 1 + len(v) + sovProto(uint64(len(v)))
			n += mapEntrySize + 1 + sovProto(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PortForwardCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovProto(uint64(m.Port))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func (m *TerminalResizeCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cols != 0 {
		n += 1 + sovProto(uint64(m.Cols))
	}
	if m.Rows != 0 {
		n += 1 + sovProto(uint64(m.Rows))
	}
	return n
}

func (m *ErrorMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovProto(uint64(m.Kind))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovProto(uint64(m.Code))
	}
	return n
}

func (m *StateMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovProto(uint64(m.Kind))
	}
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovProto(uint64(l))
	}
	return n
}

func sovProto(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProto(x uint64) (n int) {
	return sovProto(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`}`,
	}, "")
	return s
}
func (this *Cmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Cmd{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Sid:` + fmt.Sprintf("%v", this.Sid) + `,`,
		`Seq:` + fmt.Sprintf("%v", this.Seq) + `,`,
		`Completed:` + fmt.Sprintf("%v", this.Completed) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Msg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Msg{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Sid:` + fmt.Sprintf("%v", this.Sid) + `,`,
		`Seq:` + fmt.Sprintf("%v", this.Seq) + `,`,
		`Completed:` + fmt.Sprintf("%v", this.Completed) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInfoGetCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInfoGetCmd{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SessionCloseCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SessionCloseCmd{`,
		`Sid:` + fmt.Sprintf("%v", this.Sid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RejectCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RejectCmd{`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LogsCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LogsCmd{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Container:` + fmt.Sprintf("%v", this.Container) + `,`,
		`Follow:` + fmt.Sprintf("%v", this.Follow) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Since:` + fmt.Sprintf("%v", this.Since) + `,`,
		`TailLines:` + fmt.Sprintf("%v", this.TailLines) + `,`,
		`BytesLimit:` + fmt.Sprintf("%v", this.BytesLimit) + `,`,
		`Previous:` + fmt.Sprintf("%v", this.Previous) + `,`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExecOrAttachCmd) String() string {
	if this == nil {
		return "nil"
	}
	keysForEnvs := make([]string, 0, len(this.Envs))
	for k, _ := range this.Envs {
		keysForEnvs = append(keysForEnvs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEnvs)
	mapStringForEnvs := "map[string]string{"
	for _, k := range keysForEnvs {
		mapStringForEnvs += fmt.Sprintf("%v: %v,", k, this.Envs[k])
	}
	mapStringForEnvs += "}"
	s := strings.Join([]string{`&ExecOrAttachCmd{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Container:` + fmt.Sprintf("%v", this.Container) + `,`,
		`Stdin:` + fmt.Sprintf("%v", this.Stdin) + `,`,
		`Stdout:` + fmt.Sprintf("%v", this.Stdout) + `,`,
		`Stderr:` + fmt.Sprintf("%v", this.Stderr) + `,`,
		`Tty:` + fmt.Sprintf("%v", this.Tty) + `,`,
		`Command:` + fmt.Sprintf("%v", this.Command) + `,`,
		`Envs:` + mapStringForEnvs + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortForwardCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortForwardCmd{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TerminalResizeCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TerminalResizeCmd{`,
		`Cols:` + fmt.Sprintf("%v", this.Cols) + `,`,
		`Rows:` + fmt.Sprintf("%v", this.Rows) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ErrorMsg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ErrorMsg{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StateMsg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StateMsg{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`DeviceId:` + fmt.Sprintf("%v", this.DeviceId) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringProto(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= CmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Completed = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Msg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Msg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Msg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= MsgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Completed = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfoGetCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfoGetCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfoGetCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= NodeInfoGetCmd_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionCloseCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionCloseCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionCloseCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RejectCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RejectCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RejectCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= RejectionReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogsCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogsCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogsCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Follow = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timestamp = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Since", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Since = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TailLines", wireType)
			}
			m.TailLines = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TailLines |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesLimit", wireType)
			}
			m.BytesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Previous", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Previous = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecOrAttachCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecOrAttachCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecOrAttachCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stdin = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stdout = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stderr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stderr = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tty = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Envs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Envs == nil {
				m.Envs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProto
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProto
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProto
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthProto
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProto
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProto
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthProto
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProto(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthProto
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Envs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortForwardCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortForwardCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortForwardCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TerminalResizeCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TerminalResizeCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TerminalResizeCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			m.Cols = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cols |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			m.Rows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rows |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= ErrorMsg_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= StateMsg_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProto(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProto
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProto
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProto
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProto
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProto
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProto
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProto        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProto          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProto = fmt.Errorf("proto: unexpected end of group")
)
