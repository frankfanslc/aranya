// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cmd_pod.proto

// +build !rt_none

package aranyagopb

import (
	bytes "bytes"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RestartPolicy int32

const (
	RESTART_ALWAYS     RestartPolicy = 0
	RESTART_ON_FAILURE RestartPolicy = 1
	RESTART_NEVER      RestartPolicy = 2
)

var RestartPolicy_name = map[int32]string{
	0: "RESTART_ALWAYS",
	1: "RESTART_ON_FAILURE",
	2: "RESTART_NEVER",
}

var RestartPolicy_value = map[string]int32{
	"RESTART_ALWAYS":     0,
	"RESTART_ON_FAILURE": 1,
	"RESTART_NEVER":      2,
}

func (RestartPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{0}
}

type ContainerSecuritySpec_ProcMountKind int32

const (
	PROC_MOUNT_DEFAULT  ContainerSecuritySpec_ProcMountKind = 0
	PROC_MOUNT_UNMASKED ContainerSecuritySpec_ProcMountKind = 1
)

var ContainerSecuritySpec_ProcMountKind_name = map[int32]string{
	0: "PROC_MOUNT_DEFAULT",
	1: "PROC_MOUNT_UNMASKED",
}

var ContainerSecuritySpec_ProcMountKind_value = map[string]int32{
	"PROC_MOUNT_DEFAULT":  0,
	"PROC_MOUNT_UNMASKED": 1,
}

func (ContainerSecuritySpec_ProcMountKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{2, 0}
}

type NamedData struct {
	DataMap map[string][]byte `protobuf:"bytes,1,rep,name=data_map,json=dataMap,proto3" json:"data_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NamedData) Reset()      { *m = NamedData{} }
func (*NamedData) ProtoMessage() {}
func (*NamedData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{0}
}
func (m *NamedData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamedData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamedData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamedData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamedData.Merge(m, src)
}
func (m *NamedData) XXX_Size() int {
	return m.Size()
}
func (m *NamedData) XXX_DiscardUnknown() {
	xxx_messageInfo_NamedData.DiscardUnknown(m)
}

var xxx_messageInfo_NamedData proto.InternalMessageInfo

func (m *NamedData) GetDataMap() map[string][]byte {
	if m != nil {
		return m.DataMap
	}
	return nil
}

type SELinuxOptions struct {
	Type  string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Level string `protobuf:"bytes,2,opt,name=level,proto3" json:"level,omitempty"`
	Role  string `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
	User  string `protobuf:"bytes,4,opt,name=user,proto3" json:"user,omitempty"`
}

func (m *SELinuxOptions) Reset()      { *m = SELinuxOptions{} }
func (*SELinuxOptions) ProtoMessage() {}
func (*SELinuxOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{1}
}
func (m *SELinuxOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SELinuxOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SELinuxOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SELinuxOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SELinuxOptions.Merge(m, src)
}
func (m *SELinuxOptions) XXX_Size() int {
	return m.Size()
}
func (m *SELinuxOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_SELinuxOptions.DiscardUnknown(m)
}

var xxx_messageInfo_SELinuxOptions proto.InternalMessageInfo

func (m *SELinuxOptions) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SELinuxOptions) GetLevel() string {
	if m != nil {
		return m.Level
	}
	return ""
}

func (m *SELinuxOptions) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *SELinuxOptions) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

type ContainerSecuritySpec struct {
	Privileged         bool                                `protobuf:"varint,1,opt,name=privileged,proto3" json:"privileged,omitempty"`
	AllowNewPrivileges bool                                `protobuf:"varint,2,opt,name=allow_new_privileges,json=allowNewPrivileges,proto3" json:"allow_new_privileges,omitempty"`
	NonRoot            bool                                `protobuf:"varint,3,opt,name=non_root,json=nonRoot,proto3" json:"non_root,omitempty"`
	ReadOnlyRootfs     bool                                `protobuf:"varint,4,opt,name=read_only_rootfs,json=readOnlyRootfs,proto3" json:"read_only_rootfs,omitempty"`
	User               int64                               `protobuf:"varint,5,opt,name=user,proto3" json:"user,omitempty"`
	Group              int64                               `protobuf:"varint,6,opt,name=group,proto3" json:"group,omitempty"`
	CapsAdd            []string                            `protobuf:"bytes,7,rep,name=caps_add,json=capsAdd,proto3" json:"caps_add,omitempty"`
	CapsDrop           []string                            `protobuf:"bytes,8,rep,name=caps_drop,json=capsDrop,proto3" json:"caps_drop,omitempty"`
	ProcMountKind      ContainerSecuritySpec_ProcMountKind `protobuf:"varint,9,opt,name=proc_mount_kind,json=procMountKind,proto3,enum=aranya.ContainerSecuritySpec_ProcMountKind" json:"proc_mount_kind,omitempty"`
	SelinuxOptions     *SELinuxOptions                     `protobuf:"bytes,10,opt,name=selinux_options,json=selinuxOptions,proto3" json:"selinux_options,omitempty"`
}

func (m *ContainerSecuritySpec) Reset()      { *m = ContainerSecuritySpec{} }
func (*ContainerSecuritySpec) ProtoMessage() {}
func (*ContainerSecuritySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{2}
}
func (m *ContainerSecuritySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerSecuritySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerSecuritySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerSecuritySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerSecuritySpec.Merge(m, src)
}
func (m *ContainerSecuritySpec) XXX_Size() int {
	return m.Size()
}
func (m *ContainerSecuritySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerSecuritySpec.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerSecuritySpec proto.InternalMessageInfo

func (m *ContainerSecuritySpec) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

func (m *ContainerSecuritySpec) GetAllowNewPrivileges() bool {
	if m != nil {
		return m.AllowNewPrivileges
	}
	return false
}

func (m *ContainerSecuritySpec) GetNonRoot() bool {
	if m != nil {
		return m.NonRoot
	}
	return false
}

func (m *ContainerSecuritySpec) GetReadOnlyRootfs() bool {
	if m != nil {
		return m.ReadOnlyRootfs
	}
	return false
}

func (m *ContainerSecuritySpec) GetUser() int64 {
	if m != nil {
		return m.User
	}
	return 0
}

func (m *ContainerSecuritySpec) GetGroup() int64 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *ContainerSecuritySpec) GetCapsAdd() []string {
	if m != nil {
		return m.CapsAdd
	}
	return nil
}

func (m *ContainerSecuritySpec) GetCapsDrop() []string {
	if m != nil {
		return m.CapsDrop
	}
	return nil
}

func (m *ContainerSecuritySpec) GetProcMountKind() ContainerSecuritySpec_ProcMountKind {
	if m != nil {
		return m.ProcMountKind
	}
	return PROC_MOUNT_DEFAULT
}

func (m *ContainerSecuritySpec) GetSelinuxOptions() *SELinuxOptions {
	if m != nil {
		return m.SelinuxOptions
	}
	return nil
}

type ContainerMountSpec struct {
	MountPath string `protobuf:"bytes,1,opt,name=mount_path,json=mountPath,proto3" json:"mount_path,omitempty"`
	SubPath   string `protobuf:"bytes,2,opt,name=sub_path,json=subPath,proto3" json:"sub_path,omitempty"`
	ReadOnly  bool   `protobuf:"varint,3,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	// device type
	Type     string   `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	Options  []string `protobuf:"bytes,5,rep,name=options,proto3" json:"options,omitempty"`
	FileMode uint32   `protobuf:"varint,6,opt,name=file_mode,json=fileMode,proto3" json:"file_mode,omitempty"`
	// mount this volume use cluster CSI
	Remote bool `protobuf:"varint,7,opt,name=remote,proto3" json:"remote,omitempty"`
}

func (m *ContainerMountSpec) Reset()      { *m = ContainerMountSpec{} }
func (*ContainerMountSpec) ProtoMessage() {}
func (*ContainerMountSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{3}
}
func (m *ContainerMountSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerMountSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerMountSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerMountSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerMountSpec.Merge(m, src)
}
func (m *ContainerMountSpec) XXX_Size() int {
	return m.Size()
}
func (m *ContainerMountSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerMountSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerMountSpec proto.InternalMessageInfo

func (m *ContainerMountSpec) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

func (m *ContainerMountSpec) GetSubPath() string {
	if m != nil {
		return m.SubPath
	}
	return ""
}

func (m *ContainerMountSpec) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *ContainerMountSpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ContainerMountSpec) GetOptions() []string {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *ContainerMountSpec) GetFileMode() uint32 {
	if m != nil {
		return m.FileMode
	}
	return 0
}

func (m *ContainerMountSpec) GetRemote() bool {
	if m != nil {
		return m.Remote
	}
	return false
}

type KeyValuePair struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *KeyValuePair) Reset()      { *m = KeyValuePair{} }
func (*KeyValuePair) ProtoMessage() {}
func (*KeyValuePair) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{4}
}
func (m *KeyValuePair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValuePair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyValuePair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyValuePair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValuePair.Merge(m, src)
}
func (m *KeyValuePair) XXX_Size() int {
	return m.Size()
}
func (m *KeyValuePair) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValuePair.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValuePair proto.InternalMessageInfo

func (m *KeyValuePair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValuePair) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type ContainerAction struct {
	// Types that are valid to be assigned to Action:
	//	*ContainerAction_Exec_
	//	*ContainerAction_Http
	//	*ContainerAction_Socket_
	Action isContainerAction_Action `protobuf_oneof:"action"`
}

func (m *ContainerAction) Reset()      { *m = ContainerAction{} }
func (*ContainerAction) ProtoMessage() {}
func (*ContainerAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{5}
}
func (m *ContainerAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerAction.Merge(m, src)
}
func (m *ContainerAction) XXX_Size() int {
	return m.Size()
}
func (m *ContainerAction) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerAction.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerAction proto.InternalMessageInfo

type isContainerAction_Action interface {
	isContainerAction_Action()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ContainerAction_Exec_ struct {
	Exec *ContainerAction_Exec `protobuf:"bytes,1,opt,name=exec,proto3,oneof" json:"exec,omitempty"`
}
type ContainerAction_Http struct {
	Http *ContainerAction_HTTP `protobuf:"bytes,2,opt,name=http,proto3,oneof" json:"http,omitempty"`
}
type ContainerAction_Socket_ struct {
	Socket *ContainerAction_Socket `protobuf:"bytes,3,opt,name=socket,proto3,oneof" json:"socket,omitempty"`
}

func (*ContainerAction_Exec_) isContainerAction_Action()   {}
func (*ContainerAction_Http) isContainerAction_Action()    {}
func (*ContainerAction_Socket_) isContainerAction_Action() {}

func (m *ContainerAction) GetAction() isContainerAction_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *ContainerAction) GetExec() *ContainerAction_Exec {
	if x, ok := m.GetAction().(*ContainerAction_Exec_); ok {
		return x.Exec
	}
	return nil
}

func (m *ContainerAction) GetHttp() *ContainerAction_HTTP {
	if x, ok := m.GetAction().(*ContainerAction_Http); ok {
		return x.Http
	}
	return nil
}

func (m *ContainerAction) GetSocket() *ContainerAction_Socket {
	if x, ok := m.GetAction().(*ContainerAction_Socket_); ok {
		return x.Socket
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ContainerAction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ContainerAction_Exec_)(nil),
		(*ContainerAction_Http)(nil),
		(*ContainerAction_Socket_)(nil),
	}
}

type ContainerAction_Exec struct {
	Command []string `protobuf:"bytes,1,rep,name=command,proto3" json:"command,omitempty"`
}

func (m *ContainerAction_Exec) Reset()      { *m = ContainerAction_Exec{} }
func (*ContainerAction_Exec) ProtoMessage() {}
func (*ContainerAction_Exec) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{5, 0}
}
func (m *ContainerAction_Exec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerAction_Exec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerAction_Exec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerAction_Exec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerAction_Exec.Merge(m, src)
}
func (m *ContainerAction_Exec) XXX_Size() int {
	return m.Size()
}
func (m *ContainerAction_Exec) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerAction_Exec.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerAction_Exec proto.InternalMessageInfo

func (m *ContainerAction_Exec) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

type ContainerAction_HTTP struct {
	Method  string          `protobuf:"bytes,1,opt,name=method,proto3" json:"method,omitempty"`
	Url     string          `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	Headers []*KeyValuePair `protobuf:"bytes,3,rep,name=headers,proto3" json:"headers,omitempty"`
}

func (m *ContainerAction_HTTP) Reset()      { *m = ContainerAction_HTTP{} }
func (*ContainerAction_HTTP) ProtoMessage() {}
func (*ContainerAction_HTTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{5, 1}
}
func (m *ContainerAction_HTTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerAction_HTTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerAction_HTTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerAction_HTTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerAction_HTTP.Merge(m, src)
}
func (m *ContainerAction_HTTP) XXX_Size() int {
	return m.Size()
}
func (m *ContainerAction_HTTP) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerAction_HTTP.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerAction_HTTP proto.InternalMessageInfo

func (m *ContainerAction_HTTP) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *ContainerAction_HTTP) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ContainerAction_HTTP) GetHeaders() []*KeyValuePair {
	if m != nil {
		return m.Headers
	}
	return nil
}

type ContainerAction_Socket struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *ContainerAction_Socket) Reset()      { *m = ContainerAction_Socket{} }
func (*ContainerAction_Socket) ProtoMessage() {}
func (*ContainerAction_Socket) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{5, 2}
}
func (m *ContainerAction_Socket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerAction_Socket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerAction_Socket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerAction_Socket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerAction_Socket.Merge(m, src)
}
func (m *ContainerAction_Socket) XXX_Size() int {
	return m.Size()
}
func (m *ContainerAction_Socket) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerAction_Socket.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerAction_Socket proto.InternalMessageInfo

func (m *ContainerAction_Socket) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type ContainerProbeSpec struct {
	InitialDelay     int64            `protobuf:"varint,1,opt,name=initial_delay,json=initialDelay,proto3" json:"initial_delay,omitempty"`
	ProbeTimeout     int64            `protobuf:"varint,2,opt,name=probe_timeout,json=probeTimeout,proto3" json:"probe_timeout,omitempty"`
	ProbeInterval    int64            `protobuf:"varint,3,opt,name=probe_interval,json=probeInterval,proto3" json:"probe_interval,omitempty"`
	SuccessThreshold int32            `protobuf:"varint,4,opt,name=success_threshold,json=successThreshold,proto3" json:"success_threshold,omitempty"`
	FailureThreshold int32            `protobuf:"varint,5,opt,name=failure_threshold,json=failureThreshold,proto3" json:"failure_threshold,omitempty"`
	Method           *ContainerAction `protobuf:"bytes,6,opt,name=method,proto3" json:"method,omitempty"`
}

func (m *ContainerProbeSpec) Reset()      { *m = ContainerProbeSpec{} }
func (*ContainerProbeSpec) ProtoMessage() {}
func (*ContainerProbeSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{6}
}
func (m *ContainerProbeSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerProbeSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerProbeSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerProbeSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerProbeSpec.Merge(m, src)
}
func (m *ContainerProbeSpec) XXX_Size() int {
	return m.Size()
}
func (m *ContainerProbeSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerProbeSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerProbeSpec proto.InternalMessageInfo

func (m *ContainerProbeSpec) GetInitialDelay() int64 {
	if m != nil {
		return m.InitialDelay
	}
	return 0
}

func (m *ContainerProbeSpec) GetProbeTimeout() int64 {
	if m != nil {
		return m.ProbeTimeout
	}
	return 0
}

func (m *ContainerProbeSpec) GetProbeInterval() int64 {
	if m != nil {
		return m.ProbeInterval
	}
	return 0
}

func (m *ContainerProbeSpec) GetSuccessThreshold() int32 {
	if m != nil {
		return m.SuccessThreshold
	}
	return 0
}

func (m *ContainerProbeSpec) GetFailureThreshold() int32 {
	if m != nil {
		return m.FailureThreshold
	}
	return 0
}

func (m *ContainerProbeSpec) GetMethod() *ContainerAction {
	if m != nil {
		return m.Method
	}
	return nil
}

type ContainerSpec struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// container image name to pull
	Image      string `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	WorkingDir string `protobuf:"bytes,3,opt,name=working_dir,json=workingDir,proto3" json:"working_dir,omitempty"`
	Stdin      bool   `protobuf:"varint,4,opt,name=stdin,proto3" json:"stdin,omitempty"`
	StdinOnce  bool   `protobuf:"varint,5,opt,name=stdin_once,json=stdinOnce,proto3" json:"stdin_once,omitempty"`
	Tty        bool   `protobuf:"varint,6,opt,name=tty,proto3" json:"tty,omitempty"`
	// Command (ENTRYPOINT in Dockerfile)
	Command []string `protobuf:"bytes,7,rep,name=command,proto3" json:"command,omitempty"`
	// Args (CMD in Dockerfile)
	Args []string `protobuf:"bytes,8,rep,name=args,proto3" json:"args,omitempty"`
	// Contaienr environment variables
	//
	// key: env key
	// value: env value
	Envs map[string]string `protobuf:"bytes,9,rep,name=envs,proto3" json:"envs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Container voulme or device mounts
	//
	// key: volume or device name
	// value: mount options
	Mounts         map[string]*ContainerMountSpec `protobuf:"bytes,10,rep,name=mounts,proto3" json:"mounts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ReadinessCheck *ContainerProbeSpec            `protobuf:"bytes,11,opt,name=readiness_check,json=readinessCheck,proto3" json:"readiness_check,omitempty"`
	LivenessCheck  *ContainerProbeSpec            `protobuf:"bytes,12,opt,name=liveness_check,json=livenessCheck,proto3" json:"liveness_check,omitempty"`
	//
	// resolved security opts in pod
	//
	Security *ContainerSecuritySpec `protobuf:"bytes,13,opt,name=security,proto3" json:"security,omitempty"`
	//
	// Container hooks
	//
	HookPostStart *ContainerAction `protobuf:"bytes,14,opt,name=hook_post_start,json=hookPostStart,proto3" json:"hook_post_start,omitempty"`
}

func (m *ContainerSpec) Reset()      { *m = ContainerSpec{} }
func (*ContainerSpec) ProtoMessage() {}
func (*ContainerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{7}
}
func (m *ContainerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerSpec.Merge(m, src)
}
func (m *ContainerSpec) XXX_Size() int {
	return m.Size()
}
func (m *ContainerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerSpec proto.InternalMessageInfo

func (m *ContainerSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ContainerSpec) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ContainerSpec) GetWorkingDir() string {
	if m != nil {
		return m.WorkingDir
	}
	return ""
}

func (m *ContainerSpec) GetStdin() bool {
	if m != nil {
		return m.Stdin
	}
	return false
}

func (m *ContainerSpec) GetStdinOnce() bool {
	if m != nil {
		return m.StdinOnce
	}
	return false
}

func (m *ContainerSpec) GetTty() bool {
	if m != nil {
		return m.Tty
	}
	return false
}

func (m *ContainerSpec) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ContainerSpec) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *ContainerSpec) GetEnvs() map[string]string {
	if m != nil {
		return m.Envs
	}
	return nil
}

func (m *ContainerSpec) GetMounts() map[string]*ContainerMountSpec {
	if m != nil {
		return m.Mounts
	}
	return nil
}

func (m *ContainerSpec) GetReadinessCheck() *ContainerProbeSpec {
	if m != nil {
		return m.ReadinessCheck
	}
	return nil
}

func (m *ContainerSpec) GetLivenessCheck() *ContainerProbeSpec {
	if m != nil {
		return m.LivenessCheck
	}
	return nil
}

func (m *ContainerSpec) GetSecurity() *ContainerSecuritySpec {
	if m != nil {
		return m.Security
	}
	return nil
}

func (m *ContainerSpec) GetHookPostStart() *ContainerAction {
	if m != nil {
		return m.HookPostStart
	}
	return nil
}

type Bandwidth struct {
	// unit: bits/s
	IngressRate int32 `protobuf:"varint,1,opt,name=ingress_rate,json=ingressRate,proto3" json:"ingress_rate,omitempty"`
	EgressRate  int32 `protobuf:"varint,2,opt,name=egress_rate,json=egressRate,proto3" json:"egress_rate,omitempty"`
	// unit: bits
	IngressBurst int32 `protobuf:"varint,3,opt,name=ingress_burst,json=ingressBurst,proto3" json:"ingress_burst,omitempty"`
	EgressBurst  int32 `protobuf:"varint,4,opt,name=egress_burst,json=egressBurst,proto3" json:"egress_burst,omitempty"`
}

func (m *Bandwidth) Reset()      { *m = Bandwidth{} }
func (*Bandwidth) ProtoMessage() {}
func (*Bandwidth) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{8}
}
func (m *Bandwidth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bandwidth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bandwidth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bandwidth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bandwidth.Merge(m, src)
}
func (m *Bandwidth) XXX_Size() int {
	return m.Size()
}
func (m *Bandwidth) XXX_DiscardUnknown() {
	xxx_messageInfo_Bandwidth.DiscardUnknown(m)
}

var xxx_messageInfo_Bandwidth proto.InternalMessageInfo

func (m *Bandwidth) GetIngressRate() int32 {
	if m != nil {
		return m.IngressRate
	}
	return 0
}

func (m *Bandwidth) GetEgressRate() int32 {
	if m != nil {
		return m.EgressRate
	}
	return 0
}

func (m *Bandwidth) GetIngressBurst() int32 {
	if m != nil {
		return m.IngressBurst
	}
	return 0
}

func (m *Bandwidth) GetEgressBurst() int32 {
	if m != nil {
		return m.EgressBurst
	}
	return 0
}

type ContainerPortSpec struct {
	Protocol      string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	ContainerPort int32  `protobuf:"varint,2,opt,name=container_port,json=containerPort,proto3" json:"container_port,omitempty"`
	HostPort      int32  `protobuf:"varint,3,opt,name=host_port,json=hostPort,proto3" json:"host_port,omitempty"`
	HostIp        string `protobuf:"bytes,4,opt,name=host_ip,json=hostIp,proto3" json:"host_ip,omitempty"`
}

func (m *ContainerPortSpec) Reset()      { *m = ContainerPortSpec{} }
func (*ContainerPortSpec) ProtoMessage() {}
func (*ContainerPortSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{9}
}
func (m *ContainerPortSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerPortSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerPortSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerPortSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerPortSpec.Merge(m, src)
}
func (m *ContainerPortSpec) XXX_Size() int {
	return m.Size()
}
func (m *ContainerPortSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerPortSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerPortSpec proto.InternalMessageInfo

func (m *ContainerPortSpec) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *ContainerPortSpec) GetContainerPort() int32 {
	if m != nil {
		return m.ContainerPort
	}
	return 0
}

func (m *ContainerPortSpec) GetHostPort() int32 {
	if m != nil {
		return m.HostPort
	}
	return 0
}

func (m *ContainerPortSpec) GetHostIp() string {
	if m != nil {
		return m.HostIp
	}
	return ""
}

type PodNetworkSpec struct {
	CidrIpv4  string     `protobuf:"bytes,1,opt,name=cidr_ipv4,json=cidrIpv4,proto3" json:"cidr_ipv4,omitempty"`
	CidrIpv6  string     `protobuf:"bytes,2,opt,name=cidr_ipv6,json=cidrIpv6,proto3" json:"cidr_ipv6,omitempty"`
	Bandwidth *Bandwidth `protobuf:"bytes,3,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`
	// /etc/resolv.conf entries
	NameServers   []string `protobuf:"bytes,4,rep,name=name_servers,json=nameServers,proto3" json:"name_servers,omitempty"`
	SearchDomains []string `protobuf:"bytes,5,rep,name=search_domains,json=searchDomains,proto3" json:"search_domains,omitempty"`
	DnsOptions    []string `protobuf:"bytes,6,rep,name=dns_options,json=dnsOptions,proto3" json:"dns_options,omitempty"`
	// /etc/hosts entries
	//
	// key: hostname
	// value: ip
	Hosts map[string]string `protobuf:"bytes,7,rep,name=hosts,proto3" json:"hosts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Container ports is processed when creating the pause container
	//
	// key: port name
	//          the port name is in the format of `{container}/{port_name}`
	//          if the port name is missing in the corev1.Container,
	//          it's index number in the containers list will be used as {port_name}
	// value: port map and spec
	//          currently only ports with `host_port` specified will be exposed
	Ports map[string]*ContainerPortSpec `protobuf:"bytes,8,rep,name=ports,proto3" json:"ports,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *PodNetworkSpec) Reset()      { *m = PodNetworkSpec{} }
func (*PodNetworkSpec) ProtoMessage() {}
func (*PodNetworkSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{10}
}
func (m *PodNetworkSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodNetworkSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodNetworkSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodNetworkSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodNetworkSpec.Merge(m, src)
}
func (m *PodNetworkSpec) XXX_Size() int {
	return m.Size()
}
func (m *PodNetworkSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PodNetworkSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PodNetworkSpec proto.InternalMessageInfo

func (m *PodNetworkSpec) GetCidrIpv4() string {
	if m != nil {
		return m.CidrIpv4
	}
	return ""
}

func (m *PodNetworkSpec) GetCidrIpv6() string {
	if m != nil {
		return m.CidrIpv6
	}
	return ""
}

func (m *PodNetworkSpec) GetBandwidth() *Bandwidth {
	if m != nil {
		return m.Bandwidth
	}
	return nil
}

func (m *PodNetworkSpec) GetNameServers() []string {
	if m != nil {
		return m.NameServers
	}
	return nil
}

func (m *PodNetworkSpec) GetSearchDomains() []string {
	if m != nil {
		return m.SearchDomains
	}
	return nil
}

func (m *PodNetworkSpec) GetDnsOptions() []string {
	if m != nil {
		return m.DnsOptions
	}
	return nil
}

func (m *PodNetworkSpec) GetHosts() map[string]string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *PodNetworkSpec) GetPorts() map[string]*ContainerPortSpec {
	if m != nil {
		return m.Ports
	}
	return nil
}

type PodVolumeSpec struct {
	// Volumes and devices' host path
	//
	// key: volume or device name
	// value: host path
	HostPaths map[string]string `protobuf:"bytes,21,rep,name=host_paths,json=hostPaths,proto3" json:"host_paths,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Data to populate files in container
	//
	// key: volume name
	// value: data from {ConfigMap, Secret}
	VolumeData map[string]*NamedData `protobuf:"bytes,22,rep,name=volume_data,json=volumeData,proto3" json:"volume_data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *PodVolumeSpec) Reset()      { *m = PodVolumeSpec{} }
func (*PodVolumeSpec) ProtoMessage() {}
func (*PodVolumeSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{11}
}
func (m *PodVolumeSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodVolumeSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodVolumeSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodVolumeSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodVolumeSpec.Merge(m, src)
}
func (m *PodVolumeSpec) XXX_Size() int {
	return m.Size()
}
func (m *PodVolumeSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PodVolumeSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PodVolumeSpec proto.InternalMessageInfo

func (m *PodVolumeSpec) GetHostPaths() map[string]string {
	if m != nil {
		return m.HostPaths
	}
	return nil
}

func (m *PodVolumeSpec) GetVolumeData() map[string]*NamedData {
	if m != nil {
		return m.VolumeData
	}
	return nil
}

type PodSecuritySpec struct {
	// key:
	// value:
	Sysctls map[string]string `protobuf:"bytes,15,rep,name=sysctls,proto3" json:"sysctls,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *PodSecuritySpec) Reset()      { *m = PodSecuritySpec{} }
func (*PodSecuritySpec) ProtoMessage() {}
func (*PodSecuritySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{12}
}
func (m *PodSecuritySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodSecuritySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodSecuritySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodSecuritySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodSecuritySpec.Merge(m, src)
}
func (m *PodSecuritySpec) XXX_Size() int {
	return m.Size()
}
func (m *PodSecuritySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PodSecuritySpec.DiscardUnknown(m)
}

var xxx_messageInfo_PodSecuritySpec proto.InternalMessageInfo

func (m *PodSecuritySpec) GetSysctls() map[string]string {
	if m != nil {
		return m.Sysctls
	}
	return nil
}

type PodEnsureCmd struct {
	// kubernetes metadata
	PodUid        string        `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	Namespace     string        `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Name          string        `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	RestartPolicy RestartPolicy `protobuf:"varint,4,opt,name=restart_policy,json=restartPolicy,proto3,enum=aranya.RestartPolicy" json:"restart_policy,omitempty"`
	//
	// Relationships to host namespaces
	//
	HostIpc     bool `protobuf:"varint,5,opt,name=host_ipc,json=hostIpc,proto3" json:"host_ipc,omitempty"`
	HostNetwork bool `protobuf:"varint,6,opt,name=host_network,json=hostNetwork,proto3" json:"host_network,omitempty"`
	HostPid     bool `protobuf:"varint,7,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty"`
	// share pid namespace between containers in the same pod
	SharePid bool `protobuf:"varint,8,opt,name=share_pid,json=sharePid,proto3" json:"share_pid,omitempty"`
	// wait unitl all containers defined in this cmd exited with no error
	Wait bool `protobuf:"varint,9,opt,name=wait,proto3" json:"wait,omitempty"`
	// custom hostname to override container id as hostname
	Hostname   string            `protobuf:"bytes,10,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Containers []*ContainerSpec  `protobuf:"bytes,11,rep,name=containers,proto3" json:"containers,omitempty"`
	Network    *PodNetworkSpec   `protobuf:"bytes,12,opt,name=network,proto3" json:"network,omitempty"`
	Volumes    *PodVolumeSpec    `protobuf:"bytes,13,opt,name=volumes,proto3" json:"volumes,omitempty"`
	Security   *PodSecuritySpec  `protobuf:"bytes,14,opt,name=security,proto3" json:"security,omitempty"`
	Labels     map[string]string `protobuf:"bytes,15,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *PodEnsureCmd) Reset()      { *m = PodEnsureCmd{} }
func (*PodEnsureCmd) ProtoMessage() {}
func (*PodEnsureCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{13}
}
func (m *PodEnsureCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodEnsureCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodEnsureCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodEnsureCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodEnsureCmd.Merge(m, src)
}
func (m *PodEnsureCmd) XXX_Size() int {
	return m.Size()
}
func (m *PodEnsureCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_PodEnsureCmd.DiscardUnknown(m)
}

var xxx_messageInfo_PodEnsureCmd proto.InternalMessageInfo

func (m *PodEnsureCmd) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *PodEnsureCmd) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *PodEnsureCmd) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PodEnsureCmd) GetRestartPolicy() RestartPolicy {
	if m != nil {
		return m.RestartPolicy
	}
	return RESTART_ALWAYS
}

func (m *PodEnsureCmd) GetHostIpc() bool {
	if m != nil {
		return m.HostIpc
	}
	return false
}

func (m *PodEnsureCmd) GetHostNetwork() bool {
	if m != nil {
		return m.HostNetwork
	}
	return false
}

func (m *PodEnsureCmd) GetHostPid() bool {
	if m != nil {
		return m.HostPid
	}
	return false
}

func (m *PodEnsureCmd) GetSharePid() bool {
	if m != nil {
		return m.SharePid
	}
	return false
}

func (m *PodEnsureCmd) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

func (m *PodEnsureCmd) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *PodEnsureCmd) GetContainers() []*ContainerSpec {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *PodEnsureCmd) GetNetwork() *PodNetworkSpec {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *PodEnsureCmd) GetVolumes() *PodVolumeSpec {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *PodEnsureCmd) GetSecurity() *PodSecuritySpec {
	if m != nil {
		return m.Security
	}
	return nil
}

func (m *PodEnsureCmd) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

type PodDeleteCmd struct {
	// pod to perform delete operation
	PodUid string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	// containers to delete, if not specified, delete this pod
	Containers []string `protobuf:"bytes,2,rep,name=containers,proto3" json:"containers,omitempty"`
	// pod deletion grace time
	GraceTime int64 `protobuf:"varint,10,opt,name=grace_time,json=graceTime,proto3" json:"grace_time,omitempty"`
	// key: container name
	// value:
	HookPreStop map[string]*ContainerAction `protobuf:"bytes,11,rep,name=hook_pre_stop,json=hookPreStop,proto3" json:"hook_pre_stop,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *PodDeleteCmd) Reset()      { *m = PodDeleteCmd{} }
func (*PodDeleteCmd) ProtoMessage() {}
func (*PodDeleteCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{14}
}
func (m *PodDeleteCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodDeleteCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodDeleteCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodDeleteCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodDeleteCmd.Merge(m, src)
}
func (m *PodDeleteCmd) XXX_Size() int {
	return m.Size()
}
func (m *PodDeleteCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_PodDeleteCmd.DiscardUnknown(m)
}

var xxx_messageInfo_PodDeleteCmd proto.InternalMessageInfo

func (m *PodDeleteCmd) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *PodDeleteCmd) GetContainers() []string {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *PodDeleteCmd) GetGraceTime() int64 {
	if m != nil {
		return m.GraceTime
	}
	return 0
}

func (m *PodDeleteCmd) GetHookPreStop() map[string]*ContainerAction {
	if m != nil {
		return m.HookPreStop
	}
	return nil
}

type PodListCmd struct {
	// pod namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// pod name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// show all pods available
	All bool `protobuf:"varint,3,opt,name=all,proto3" json:"all,omitempty"`
}

func (m *PodListCmd) Reset()      { *m = PodListCmd{} }
func (*PodListCmd) ProtoMessage() {}
func (*PodListCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{15}
}
func (m *PodListCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodListCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodListCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodListCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodListCmd.Merge(m, src)
}
func (m *PodListCmd) XXX_Size() int {
	return m.Size()
}
func (m *PodListCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_PodListCmd.DiscardUnknown(m)
}

var xxx_messageInfo_PodListCmd proto.InternalMessageInfo

func (m *PodListCmd) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *PodListCmd) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PodListCmd) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func init() {
	proto.RegisterEnum("aranya.RestartPolicy", RestartPolicy_name, RestartPolicy_value)
	proto.RegisterEnum("aranya.ContainerSecuritySpec_ProcMountKind", ContainerSecuritySpec_ProcMountKind_name, ContainerSecuritySpec_ProcMountKind_value)
	proto.RegisterType((*NamedData)(nil), "aranya.NamedData")
	proto.RegisterMapType((map[string][]byte)(nil), "aranya.NamedData.DataMapEntry")
	proto.RegisterType((*SELinuxOptions)(nil), "aranya.SELinuxOptions")
	proto.RegisterType((*ContainerSecuritySpec)(nil), "aranya.ContainerSecuritySpec")
	proto.RegisterType((*ContainerMountSpec)(nil), "aranya.ContainerMountSpec")
	proto.RegisterType((*KeyValuePair)(nil), "aranya.KeyValuePair")
	proto.RegisterType((*ContainerAction)(nil), "aranya.ContainerAction")
	proto.RegisterType((*ContainerAction_Exec)(nil), "aranya.ContainerAction.Exec")
	proto.RegisterType((*ContainerAction_HTTP)(nil), "aranya.ContainerAction.HTTP")
	proto.RegisterType((*ContainerAction_Socket)(nil), "aranya.ContainerAction.Socket")
	proto.RegisterType((*ContainerProbeSpec)(nil), "aranya.ContainerProbeSpec")
	proto.RegisterType((*ContainerSpec)(nil), "aranya.ContainerSpec")
	proto.RegisterMapType((map[string]string)(nil), "aranya.ContainerSpec.EnvsEntry")
	proto.RegisterMapType((map[string]*ContainerMountSpec)(nil), "aranya.ContainerSpec.MountsEntry")
	proto.RegisterType((*Bandwidth)(nil), "aranya.Bandwidth")
	proto.RegisterType((*ContainerPortSpec)(nil), "aranya.ContainerPortSpec")
	proto.RegisterType((*PodNetworkSpec)(nil), "aranya.PodNetworkSpec")
	proto.RegisterMapType((map[string]string)(nil), "aranya.PodNetworkSpec.HostsEntry")
	proto.RegisterMapType((map[string]*ContainerPortSpec)(nil), "aranya.PodNetworkSpec.PortsEntry")
	proto.RegisterType((*PodVolumeSpec)(nil), "aranya.PodVolumeSpec")
	proto.RegisterMapType((map[string]string)(nil), "aranya.PodVolumeSpec.HostPathsEntry")
	proto.RegisterMapType((map[string]*NamedData)(nil), "aranya.PodVolumeSpec.VolumeDataEntry")
	proto.RegisterType((*PodSecuritySpec)(nil), "aranya.PodSecuritySpec")
	proto.RegisterMapType((map[string]string)(nil), "aranya.PodSecuritySpec.SysctlsEntry")
	proto.RegisterType((*PodEnsureCmd)(nil), "aranya.PodEnsureCmd")
	proto.RegisterMapType((map[string]string)(nil), "aranya.PodEnsureCmd.LabelsEntry")
	proto.RegisterType((*PodDeleteCmd)(nil), "aranya.PodDeleteCmd")
	proto.RegisterMapType((map[string]*ContainerAction)(nil), "aranya.PodDeleteCmd.HookPreStopEntry")
	proto.RegisterType((*PodListCmd)(nil), "aranya.PodListCmd")
}

func init() { proto.RegisterFile("cmd_pod.proto", fileDescriptor_7ca6bb171ccf381e) }

var fileDescriptor_7ca6bb171ccf381e = []byte{
	// 2038 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x58, 0xcf, 0x6f, 0x1b, 0xb9,
	0xf5, 0xf7, 0x58, 0xb6, 0x7e, 0x3c, 0x59, 0xb2, 0xc3, 0x6f, 0x7e, 0xcc, 0x6a, 0x37, 0x5a, 0x47,
	0xdf, 0x2e, 0x6a, 0x74, 0xb1, 0x4a, 0xe0, 0x6c, 0xb3, 0xc9, 0x62, 0xd1, 0xd6, 0xb1, 0x15, 0x24,
	0x88, 0x63, 0x0b, 0x23, 0x3b, 0x41, 0x7b, 0x99, 0xd2, 0x43, 0xc6, 0x1a, 0x78, 0x34, 0x1c, 0x70,
	0x28, 0x39, 0xba, 0xb5, 0x3d, 0x16, 0x2d, 0xb0, 0xb7, 0xfe, 0x0b, 0x3d, 0xf4, 0x0f, 0xe9, 0xa9,
	0x08, 0xd0, 0xcb, 0x1e, 0x1b, 0x07, 0x45, 0xf7, 0xb8, 0x7f, 0x42, 0xf1, 0x48, 0xce, 0x78, 0x64,
	0x2b, 0xd9, 0xe6, 0x22, 0xf0, 0x3d, 0x7e, 0x1e, 0x87, 0x7c, 0x3f, 0x3e, 0x8f, 0x14, 0x34, 0x82,
	0x11, 0xf3, 0x13, 0xc1, 0xba, 0x89, 0x14, 0x4a, 0x90, 0x32, 0x95, 0x34, 0x9e, 0xd2, 0xce, 0x1f,
	0x1c, 0xa8, 0xed, 0xd1, 0x11, 0x67, 0x3b, 0x54, 0x51, 0xf2, 0x00, 0xaa, 0x8c, 0x2a, 0xea, 0x8f,
	0x68, 0xe2, 0x3a, 0xeb, 0xa5, 0x8d, 0xfa, 0x66, 0xbb, 0x6b, 0x80, 0xdd, 0x1c, 0xd4, 0xc5, 0x9f,
	0x67, 0x34, 0xe9, 0xc5, 0x4a, 0x4e, 0xbd, 0x0a, 0x33, 0x52, 0xeb, 0x6b, 0x58, 0x29, 0x4e, 0x90,
	0x35, 0x28, 0x9d, 0xf0, 0xa9, 0xeb, 0xac, 0x3b, 0x1b, 0x35, 0x0f, 0x87, 0xe4, 0x2a, 0x2c, 0x4f,
	0x68, 0x34, 0xe6, 0xee, 0xe2, 0xba, 0xb3, 0xb1, 0xe2, 0x19, 0xe1, 0xeb, 0xc5, 0xfb, 0x4e, 0xe7,
	0x08, 0x9a, 0x83, 0xde, 0x6e, 0x18, 0x8f, 0x5f, 0xed, 0x27, 0x2a, 0x14, 0x71, 0x4a, 0x08, 0x2c,
	0xa9, 0x69, 0xc2, 0xad, 0xb9, 0x1e, 0xa3, 0x7d, 0xc4, 0x27, 0x3c, 0xd2, 0xf6, 0x35, 0xcf, 0x08,
	0x88, 0x94, 0x22, 0xe2, 0x6e, 0xc9, 0x20, 0x71, 0x8c, 0xba, 0x71, 0xca, 0xa5, 0xbb, 0x64, 0x74,
	0x38, 0xee, 0x7c, 0x5f, 0x82, 0x6b, 0xdb, 0x22, 0x56, 0x34, 0x8c, 0xb9, 0x1c, 0xf0, 0x60, 0x2c,
	0x43, 0x35, 0x1d, 0x24, 0x3c, 0x20, 0x6d, 0x80, 0x44, 0x86, 0x93, 0x30, 0xe2, 0xc7, 0x9c, 0xe9,
	0x2f, 0x56, 0xbd, 0x82, 0x86, 0xdc, 0x81, 0xab, 0x34, 0x8a, 0xc4, 0xa9, 0x1f, 0xf3, 0x53, 0x3f,
	0xd7, 0xa7, 0x7a, 0x1b, 0x55, 0x8f, 0xe8, 0xb9, 0x3d, 0x7e, 0xda, 0xcf, 0x67, 0xc8, 0x47, 0x50,
	0x8d, 0x45, 0xec, 0x4b, 0x21, 0x94, 0xde, 0x57, 0xd5, 0xab, 0xc4, 0x22, 0xf6, 0x84, 0x50, 0x64,
	0x03, 0xd6, 0x24, 0xa7, 0xcc, 0x17, 0x71, 0x34, 0xd5, 0x80, 0x97, 0xa9, 0xde, 0x66, 0xd5, 0x6b,
	0xa2, 0x7e, 0x3f, 0x8e, 0xa6, 0x9e, 0xd6, 0xe6, 0x87, 0x58, 0x5e, 0x77, 0x36, 0x4a, 0xe6, 0x10,
	0xe8, 0x82, 0x63, 0x29, 0xc6, 0x89, 0x5b, 0xd6, 0x4a, 0x23, 0xe0, 0xe7, 0x02, 0x9a, 0xa4, 0x3e,
	0x65, 0xcc, 0xad, 0xac, 0x97, 0x36, 0x6a, 0x5e, 0x05, 0xe5, 0x2d, 0xc6, 0xc8, 0xc7, 0x50, 0xd3,
	0x53, 0x4c, 0x8a, 0xc4, 0xad, 0xea, 0x39, 0x8d, 0xdd, 0x91, 0x22, 0x21, 0x03, 0x58, 0x4d, 0xa4,
	0x08, 0xfc, 0x91, 0x18, 0xc7, 0xca, 0x3f, 0x09, 0x63, 0xe6, 0xd6, 0xd6, 0x9d, 0x8d, 0xe6, 0xe6,
	0xe7, 0x59, 0xd0, 0xe7, 0x3a, 0xac, 0xdb, 0x97, 0x22, 0x78, 0x86, 0x36, 0x4f, 0xc3, 0x98, 0x79,
	0x8d, 0xa4, 0x28, 0x92, 0x5f, 0xc2, 0x6a, 0xca, 0x23, 0x8c, 0xa5, 0x2f, 0x4c, 0x30, 0x5d, 0x58,
	0x77, 0x36, 0xea, 0x9b, 0xd7, 0xb3, 0x45, 0x67, 0x43, 0xed, 0x35, 0x2d, 0xdc, 0xca, 0x9d, 0x5f,
	0x41, 0x63, 0xe6, 0x03, 0xe4, 0x3a, 0x90, 0xbe, 0xb7, 0xbf, 0xed, 0x3f, 0xdb, 0x3f, 0xdc, 0x3b,
	0xf0, 0x77, 0x7a, 0x8f, 0xb6, 0x0e, 0x77, 0x0f, 0xd6, 0x16, 0xc8, 0x0d, 0xf8, 0xbf, 0x82, 0xfe,
	0x70, 0xef, 0xd9, 0xd6, 0xe0, 0x69, 0x6f, 0x67, 0xcd, 0xe9, 0xfc, 0xc3, 0x01, 0x92, 0xef, 0x5c,
	0xaf, 0xa3, 0xe3, 0x7c, 0x13, 0xc0, 0x9c, 0x34, 0xa1, 0x6a, 0x68, 0x33, 0xab, 0xa6, 0x35, 0x7d,
	0xaa, 0x86, 0xe8, 0xc5, 0x74, 0x7c, 0x64, 0x26, 0x4d, 0x86, 0x55, 0xd2, 0xf1, 0x91, 0x9e, 0xfa,
	0x18, 0x6a, 0x79, 0xd0, 0x6c, 0x40, 0xab, 0x59, 0xb4, 0xf2, 0x54, 0x5d, 0x2a, 0xa4, 0xaa, 0x0b,
	0x95, 0xec, 0xf0, 0xcb, 0x26, 0x20, 0x56, 0xc4, 0xa5, 0x5e, 0x86, 0x11, 0xf7, 0x47, 0x82, 0x71,
	0x1d, 0xc5, 0x86, 0x57, 0x45, 0xc5, 0x33, 0xc1, 0x38, 0xb9, 0x0e, 0x65, 0xc9, 0x47, 0x42, 0x71,
	0xb7, 0xa2, 0x3f, 0x62, 0xa5, 0xce, 0x3d, 0x58, 0x79, 0xca, 0xa7, 0xcf, 0xb1, 0x5e, 0xfa, 0x34,
	0x94, 0x3f, 0x56, 0x5b, 0x35, 0x5b, 0x5b, 0x9d, 0x7f, 0x2f, 0xc2, 0x6a, 0xee, 0x88, 0xad, 0x00,
	0x77, 0x40, 0x36, 0x61, 0x89, 0xbf, 0xe2, 0x81, 0x36, 0xae, 0x6f, 0x7e, 0x72, 0x29, 0xd2, 0x06,
	0xd6, 0xed, 0xbd, 0xe2, 0xc1, 0xe3, 0x05, 0x4f, 0x63, 0xd1, 0x66, 0xa8, 0x54, 0xa2, 0x17, 0x7f,
	0x8f, 0xcd, 0xe3, 0x83, 0x83, 0x3e, 0xda, 0x20, 0x96, 0xdc, 0x87, 0x72, 0x2a, 0x82, 0x13, 0x6e,
	0x2a, 0xa0, 0x40, 0x24, 0x17, 0xad, 0x06, 0x1a, 0xf5, 0x78, 0xc1, 0xb3, 0xf8, 0xd6, 0x3a, 0x2c,
	0xe1, 0xd7, 0xd1, 0x89, 0x81, 0x18, 0x8d, 0x68, 0xcc, 0x34, 0x17, 0x61, 0x56, 0x1b, 0xb1, 0xf5,
	0x5b, 0x58, 0xc2, 0x6f, 0xa1, 0xbf, 0x46, 0x5c, 0x0d, 0x05, 0xb3, 0xae, 0xb0, 0x12, 0xfa, 0x67,
	0x2c, 0x33, 0x9e, 0xc0, 0x21, 0xe9, 0x42, 0x65, 0xc8, 0x29, 0xe3, 0x32, 0x75, 0x4b, 0x9a, 0xd7,
	0xae, 0x66, 0xdb, 0x29, 0x3a, 0xd6, 0xcb, 0x40, 0xad, 0x0e, 0x94, 0xcd, 0xbe, 0x70, 0x17, 0x94,
	0x31, 0xc9, 0xd3, 0xd4, 0x7e, 0x24, 0x13, 0x1f, 0x56, 0xa1, 0x4c, 0xf5, 0x11, 0x3a, 0xdf, 0x2e,
	0x16, 0x12, 0xae, 0x2f, 0xc5, 0x11, 0xd7, 0x09, 0xf7, 0xff, 0xd0, 0x08, 0xe3, 0x50, 0x85, 0x34,
	0xf2, 0x19, 0x8f, 0xa8, 0x09, 0x58, 0xc9, 0x5b, 0xb1, 0xca, 0x1d, 0xd4, 0x21, 0x28, 0x41, 0x0b,
	0x5f, 0x85, 0x23, 0x2e, 0xc6, 0x4a, 0xef, 0xba, 0xe4, 0xad, 0x68, 0xe5, 0x81, 0xd1, 0x91, 0xcf,
	0xa0, 0x69, 0x40, 0x61, 0xac, 0xb8, 0x9c, 0xd0, 0x48, 0x3b, 0xb5, 0xe4, 0x19, 0xd3, 0x27, 0x56,
	0x49, 0x3e, 0x87, 0x2b, 0xe9, 0x38, 0x08, 0x78, 0x9a, 0xfa, 0x6a, 0x28, 0x79, 0x3a, 0x14, 0x11,
	0xd3, 0x79, 0xb9, 0xec, 0xad, 0xd9, 0x89, 0x83, 0x4c, 0x8f, 0xe0, 0x97, 0x34, 0x8c, 0xc6, 0x92,
	0x17, 0xc0, 0xcb, 0x06, 0x6c, 0x27, 0xce, 0xc1, 0xb7, 0x73, 0x4f, 0x97, 0x75, 0x34, 0x6f, 0xbc,
	0x23, 0x9a, 0x59, 0x08, 0x3a, 0xff, 0x5c, 0x86, 0xc6, 0x39, 0x7b, 0xa0, 0x37, 0x08, 0x2c, 0xc5,
	0x74, 0x94, 0x53, 0x3a, 0x8e, 0x31, 0x6d, 0xc3, 0x11, 0x3d, 0xce, 0xd3, 0x56, 0x0b, 0xe4, 0x53,
	0xa8, 0x9f, 0x0a, 0x79, 0x12, 0xc6, 0xc7, 0x3e, 0x0b, 0xa5, 0x65, 0x76, 0xb0, 0xaa, 0x9d, 0x50,
	0xd3, 0x60, 0xaa, 0x58, 0x18, 0x5b, 0xe6, 0x34, 0x02, 0xd6, 0xb7, 0x1e, 0xf8, 0x22, 0x0e, 0xb8,
	0x3e, 0x49, 0xd5, 0xab, 0x69, 0xcd, 0x7e, 0x1c, 0x70, 0x4c, 0x0a, 0xa5, 0xa6, 0x7a, 0xff, 0x55,
	0x0f, 0x87, 0xc5, 0x04, 0xab, 0xcc, 0x24, 0x18, 0xee, 0x95, 0xca, 0xe3, 0xd4, 0x32, 0xa6, 0x1e,
	0x93, 0xbb, 0xb0, 0xc4, 0xe3, 0x49, 0xea, 0xd6, 0x74, 0xfe, 0x7c, 0x7a, 0x99, 0x22, 0x91, 0x1a,
	0x7b, 0xf1, 0x24, 0x35, 0x8d, 0x51, 0x83, 0xc9, 0x03, 0x28, 0x6b, 0x86, 0x41, 0x12, 0x44, 0xb3,
	0x5b, 0xf3, 0xcd, 0x34, 0x49, 0x59, 0x43, 0x6b, 0x40, 0xb6, 0x61, 0x15, 0x39, 0x26, 0x8c, 0x31,
	0x9c, 0xc1, 0x90, 0x07, 0x27, 0x6e, 0x5d, 0xfb, 0xbe, 0x75, 0x69, 0x8d, 0x3c, 0xe5, 0x4c, 0x13,
	0xd1, 0x26, 0xdb, 0x68, 0x41, 0xb6, 0xa0, 0x19, 0x85, 0x13, 0x5e, 0x58, 0x63, 0xe5, 0x47, 0xd7,
	0x68, 0x64, 0x16, 0x66, 0x89, 0x07, 0x50, 0x4d, 0x2d, 0xfb, 0xbb, 0x0d, 0x6d, 0x7c, 0xf3, 0xbd,
	0xed, 0xc1, 0xcb, 0xe1, 0xd8, 0x0b, 0x86, 0x42, 0x9c, 0xf8, 0x89, 0x48, 0x95, 0x9f, 0x2a, 0x2a,
	0x95, 0xdb, 0x7c, 0x7f, 0xfa, 0x34, 0x10, 0xdf, 0x17, 0xa9, 0x1a, 0x20, 0xba, 0xf5, 0x15, 0xd4,
	0x72, 0x8f, 0xfe, 0xaf, 0xac, 0x87, 0x37, 0x8a, 0xd6, 0x21, 0xd4, 0x0b, 0x3e, 0x9d, 0x63, 0x7a,
	0xa7, 0x68, 0x3a, 0xcf, 0x1f, 0x79, 0xdf, 0x28, 0x5e, 0x54, 0xfe, 0xe2, 0x40, 0xed, 0x21, 0x8d,
	0xd9, 0x69, 0xc8, 0xd4, 0x90, 0xdc, 0x82, 0x95, 0x30, 0x3e, 0x46, 0x2e, 0xf0, 0x25, 0x55, 0x26,
	0xb3, 0x97, 0xbd, 0xba, 0xd5, 0x79, 0x54, 0xe9, 0x54, 0xe6, 0x05, 0xc4, 0xa2, 0x46, 0x00, 0x3f,
	0x07, 0x68, 0x8e, 0x30, 0x88, 0xa3, 0xb1, 0x4c, 0x0d, 0x5b, 0x2e, 0x7b, 0xd9, 0xc2, 0x0f, 0x51,
	0x87, 0x1f, 0xe2, 0x45, 0x8c, 0x29, 0x69, 0xbb, 0xb2, 0x86, 0x74, 0xfe, 0xe4, 0xc0, 0x95, 0xf3,
	0x58, 0x0a, 0x69, 0x5a, 0x5e, 0x0b, 0xaa, 0xfa, 0xba, 0x17, 0x88, 0xc8, 0x1e, 0x3e, 0x97, 0x91,
	0x53, 0x82, 0xcc, 0xc0, 0x4f, 0x84, 0x54, 0x76, 0x77, 0x8d, 0xa0, 0xb8, 0x0c, 0x36, 0xac, 0x21,
	0x86, 0x4f, 0x23, 0xcc, 0xe6, 0xaa, 0xa8, 0xd0, 0x93, 0x37, 0xa0, 0xa2, 0x27, 0xc3, 0xc4, 0xb6,
	0xbf, 0x32, 0x8a, 0x4f, 0x92, 0xce, 0x7f, 0x4a, 0xd0, 0xec, 0x0b, 0xb6, 0xc7, 0x15, 0x96, 0xad,
	0xde, 0x0b, 0x5e, 0x45, 0x42, 0x26, 0xfd, 0x30, 0x99, 0x7c, 0x99, 0x6d, 0x06, 0x15, 0x4f, 0x92,
	0xc9, 0x97, 0xc5, 0xc9, 0x7b, 0x36, 0x9a, 0xd9, 0xe4, 0x3d, 0x72, 0x1b, 0x6a, 0x47, 0x99, 0xd3,
	0x6d, 0x37, 0xb9, 0x92, 0xc5, 0x2b, 0x8f, 0x86, 0x77, 0x8e, 0x41, 0x7f, 0x21, 0xbd, 0xf8, 0x29,
	0x97, 0x13, 0xa4, 0xfc, 0x25, 0x5d, 0xc6, 0x75, 0xd4, 0x0d, 0x8c, 0x0a, 0x4f, 0x9f, 0x72, 0x2a,
	0x83, 0xa1, 0xcf, 0xc4, 0x88, 0x86, 0x79, 0xa3, 0x6e, 0x18, 0xed, 0x8e, 0x51, 0x62, 0xfc, 0x58,
	0x9c, 0xe6, 0x37, 0x99, 0xb2, 0xc6, 0x00, 0x8b, 0xd3, 0xec, 0xa2, 0xfa, 0x15, 0x2c, 0xe3, 0x91,
	0x53, 0xcd, 0x20, 0x85, 0xfa, 0x9e, 0x3d, 0x7c, 0xf7, 0x31, 0x62, 0x4c, 0x7d, 0x1b, 0x3c, 0x1a,
	0xa2, 0x4b, 0x0d, 0xc7, 0xbc, 0xdb, 0x10, 0xdd, 0x9c, 0x19, 0x6a, 0x7c, 0xeb, 0x3e, 0xc0, 0xf9,
	0x6a, 0x1f, 0x54, 0x14, 0x03, 0x80, 0xf3, 0xe5, 0xe6, 0x58, 0xde, 0x9e, 0xad, 0x89, 0x8f, 0x2e,
	0x73, 0x84, 0xcd, 0xab, 0x62, 0x49, 0xfc, 0x6d, 0x11, 0x1a, 0x7d, 0xc1, 0x9e, 0x8b, 0x68, 0x3c,
	0x32, 0x6d, 0x6f, 0x1b, 0xc0, 0x64, 0x0c, 0x55, 0xc3, 0xd4, 0xbd, 0xa6, 0x8f, 0xf7, 0x93, 0xc2,
	0xf1, 0xce, 0xa1, 0xda, 0x2d, 0x78, 0xc3, 0xb2, 0x27, 0xd4, 0x99, 0xa6, 0x65, 0xf2, 0x08, 0xea,
	0x13, 0x8d, 0xf3, 0xf1, 0x81, 0xe1, 0x5e, 0xd7, 0xab, 0x7c, 0x36, 0x7f, 0x15, 0x33, 0xc4, 0xd7,
	0x87, 0x59, 0x06, 0x26, 0xb9, 0xa2, 0xf5, 0x0d, 0x34, 0x67, 0x3f, 0xf2, 0x41, 0x1e, 0xeb, 0xc3,
	0xea, 0x85, 0xc5, 0xe7, 0x98, 0xff, 0x74, 0xd6, 0x6d, 0x57, 0x2e, 0xbd, 0x98, 0x8a, 0xee, 0xfa,
	0xb3, 0x03, 0xab, 0x7d, 0xc1, 0x66, 0x1e, 0x20, 0xbf, 0x80, 0x4a, 0x3a, 0x4d, 0x03, 0x15, 0xa5,
	0xee, 0xea, 0x25, 0x6f, 0xcd, 0xdc, 0xbc, 0x07, 0x06, 0x66, 0x9f, 0x5e, 0xd6, 0x08, 0x9f, 0x5e,
	0xc5, 0x89, 0x0f, 0x39, 0x61, 0xe7, 0xf7, 0xcb, 0xb0, 0xd2, 0x17, 0xac, 0x17, 0xa7, 0x63, 0xc9,
	0xb7, 0x47, 0x0c, 0x4b, 0x3a, 0x11, 0xcc, 0x1f, 0x87, 0xf9, 0xa5, 0x2a, 0x11, 0xec, 0x30, 0x64,
	0xe4, 0x13, 0xa8, 0x61, 0x01, 0xa5, 0x09, 0x0d, 0xb2, 0x75, 0xce, 0x15, 0x79, 0x77, 0x2f, 0x15,
	0xba, 0xfb, 0x37, 0xd0, 0x94, 0x5c, 0xd3, 0xbe, 0x9f, 0x88, 0x28, 0x0c, 0xa6, 0x9a, 0x24, 0x9a,
	0x9b, 0xd7, 0xb2, 0xe3, 0x79, 0x66, 0xb6, 0xaf, 0x27, 0xbd, 0x86, 0x2c, 0x8a, 0x78, 0x1f, 0xb7,
	0xdc, 0x12, 0xd8, 0x66, 0x5e, 0x31, 0xe4, 0x12, 0x60, 0x7d, 0xeb, 0xa9, 0xd8, 0x14, 0x8a, 0xed,
	0xe9, 0x75, 0xd4, 0xd9, 0xda, 0xc9, 0xad, 0x93, 0x90, 0xd9, 0xcb, 0xb4, 0xb6, 0xee, 0x87, 0xfa,
	0x4d, 0x94, 0x0e, 0xa9, 0xe4, 0x7a, 0xae, 0x6a, 0x6e, 0xf3, 0x5a, 0x81, 0x93, 0x04, 0x96, 0x4e,
	0x69, 0xa8, 0xf4, 0x43, 0xa8, 0xea, 0xe9, 0x31, 0xb2, 0x28, 0xda, 0xea, 0xf3, 0x81, 0xe1, 0xa6,
	0x4c, 0x26, 0x3f, 0x07, 0xc8, 0xf9, 0x32, 0x75, 0xeb, 0x3a, 0x7c, 0xd7, 0xe6, 0x36, 0x79, 0xaf,
	0x00, 0x24, 0x77, 0xa0, 0x92, 0x6d, 0x7e, 0x65, 0xf6, 0x75, 0x34, 0x5b, 0xff, 0x5e, 0x06, 0x23,
	0xb7, 0xa1, 0x62, 0xd2, 0x3a, 0xb5, 0x5d, 0xf8, 0xda, 0xdc, 0x62, 0xf0, 0x32, 0x14, 0xb9, 0x5b,
	0xe8, 0xdb, 0x17, 0xba, 0xee, 0x85, 0xb4, 0x2a, 0x74, 0xec, 0xfb, 0x50, 0x8e, 0xe8, 0x11, 0xcf,
	0x33, 0x71, 0xbd, 0x60, 0x92, 0xe7, 0x48, 0x77, 0x57, 0x43, 0xec, 0x75, 0xc5, 0xe0, 0x5b, 0x0f,
	0xa0, 0x5e, 0x50, 0x7f, 0x50, 0x0e, 0xfe, 0x71, 0x51, 0xe7, 0xe0, 0x0e, 0x8f, 0xb8, 0x7a, 0x7f,
	0x0e, 0xb6, 0x67, 0xbc, 0xbd, 0x68, 0xd8, 0xb8, 0xe0, 0xd6, 0x9b, 0x00, 0xc7, 0x92, 0x06, 0xe6,
	0x32, 0xad, 0x63, 0x55, 0xf2, 0x6a, 0x5a, 0x83, 0x37, 0x69, 0xf2, 0x04, 0x1a, 0xe6, 0x3e, 0x22,
	0xb9, 0x9f, 0x2a, 0x91, 0xd8, 0x78, 0x15, 0x69, 0x25, 0xdf, 0x44, 0xf7, 0x31, 0xde, 0x44, 0x24,
	0x1f, 0x28, 0x61, 0xff, 0xea, 0xa8, 0x0f, 0xcf, 0x35, 0xad, 0x17, 0xb0, 0x76, 0x11, 0x30, 0xe7,
	0xcc, 0x5f, 0xcc, 0x52, 0xc3, 0x3b, 0xaf, 0x3d, 0x05, 0x67, 0xf4, 0x91, 0xa4, 0xd9, 0x6e, 0x98,
	0x2a, 0xf4, 0xc4, 0x4c, 0xd1, 0x39, 0xef, 0x2a, 0xba, 0xc5, 0x42, 0xd1, 0xad, 0x41, 0x89, 0x46,
	0x91, 0x7d, 0xa5, 0xe2, 0xf0, 0x67, 0x7b, 0xd0, 0x98, 0x29, 0x34, 0x42, 0xa0, 0xe9, 0xf5, 0x06,
	0x07, 0x5b, 0xde, 0x81, 0xbf, 0xb5, 0xfb, 0x62, 0xeb, 0xd7, 0x83, 0xb5, 0x05, 0x7c, 0x64, 0x67,
	0xba, 0xfd, 0x3d, 0xff, 0xd1, 0xd6, 0x93, 0xdd, 0x43, 0xaf, 0xb7, 0xe6, 0x90, 0x2b, 0xd0, 0xc8,
	0xf4, 0x7b, 0xbd, 0xe7, 0x3d, 0x6f, 0x6d, 0xf1, 0xe1, 0x8b, 0xd7, 0x6f, 0xda, 0x0b, 0xdf, 0xbd,
	0x69, 0x2f, 0xfc, 0xf0, 0xa6, 0xed, 0xfc, 0xee, 0xac, 0xed, 0xfc, 0xf5, 0xac, 0xed, 0xfc, 0xfd,
	0xac, 0xed, 0xbc, 0x3e, 0x6b, 0x3b, 0xff, 0x3a, 0x6b, 0x3b, 0xdf, 0x9f, 0xb5, 0x17, 0x7e, 0x38,
	0x6b, 0x3b, 0xdf, 0xbe, 0x6d, 0x2f, 0xbc, 0x7e, 0xdb, 0x5e, 0xf8, 0xee, 0x6d, 0x7b, 0xe1, 0x37,
	0xb7, 0xa8, 0x1c, 0x52, 0xd5, 0x65, 0x7c, 0x72, 0xdb, 0x38, 0xe1, 0x0b, 0x7d, 0x13, 0xb1, 0xc2,
	0xb1, 0x48, 0x8e, 0x8e, 0xca, 0x5a, 0x73, 0xf7, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x4b, 0xe0,
	0x52, 0xde, 0xab, 0x12, 0x00, 0x00,
}

func (x RestartPolicy) String() string {
	s, ok := RestartPolicy_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ContainerSecuritySpec_ProcMountKind) String() string {
	s, ok := ContainerSecuritySpec_ProcMountKind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *NamedData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamedData)
	if !ok {
		that2, ok := that.(NamedData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DataMap) != len(that1.DataMap) {
		return false
	}
	for i := range this.DataMap {
		if !bytes.Equal(this.DataMap[i], that1.DataMap[i]) {
			return false
		}
	}
	return true
}
func (this *SELinuxOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SELinuxOptions)
	if !ok {
		that2, ok := that.(SELinuxOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Level != that1.Level {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	if this.User != that1.User {
		return false
	}
	return true
}
func (this *ContainerSecuritySpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerSecuritySpec)
	if !ok {
		that2, ok := that.(ContainerSecuritySpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Privileged != that1.Privileged {
		return false
	}
	if this.AllowNewPrivileges != that1.AllowNewPrivileges {
		return false
	}
	if this.NonRoot != that1.NonRoot {
		return false
	}
	if this.ReadOnlyRootfs != that1.ReadOnlyRootfs {
		return false
	}
	if this.User != that1.User {
		return false
	}
	if this.Group != that1.Group {
		return false
	}
	if len(this.CapsAdd) != len(that1.CapsAdd) {
		return false
	}
	for i := range this.CapsAdd {
		if this.CapsAdd[i] != that1.CapsAdd[i] {
			return false
		}
	}
	if len(this.CapsDrop) != len(that1.CapsDrop) {
		return false
	}
	for i := range this.CapsDrop {
		if this.CapsDrop[i] != that1.CapsDrop[i] {
			return false
		}
	}
	if this.ProcMountKind != that1.ProcMountKind {
		return false
	}
	if !this.SelinuxOptions.Equal(that1.SelinuxOptions) {
		return false
	}
	return true
}
func (this *ContainerMountSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerMountSpec)
	if !ok {
		that2, ok := that.(ContainerMountSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MountPath != that1.MountPath {
		return false
	}
	if this.SubPath != that1.SubPath {
		return false
	}
	if this.ReadOnly != that1.ReadOnly {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Options) != len(that1.Options) {
		return false
	}
	for i := range this.Options {
		if this.Options[i] != that1.Options[i] {
			return false
		}
	}
	if this.FileMode != that1.FileMode {
		return false
	}
	if this.Remote != that1.Remote {
		return false
	}
	return true
}
func (this *KeyValuePair) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KeyValuePair)
	if !ok {
		that2, ok := that.(KeyValuePair)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *ContainerAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerAction)
	if !ok {
		that2, ok := that.(ContainerAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Action == nil {
		if this.Action != nil {
			return false
		}
	} else if this.Action == nil {
		return false
	} else if !this.Action.Equal(that1.Action) {
		return false
	}
	return true
}
func (this *ContainerAction_Exec_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerAction_Exec_)
	if !ok {
		that2, ok := that.(ContainerAction_Exec_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Exec.Equal(that1.Exec) {
		return false
	}
	return true
}
func (this *ContainerAction_Http) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerAction_Http)
	if !ok {
		that2, ok := that.(ContainerAction_Http)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Http.Equal(that1.Http) {
		return false
	}
	return true
}
func (this *ContainerAction_Socket_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerAction_Socket_)
	if !ok {
		that2, ok := that.(ContainerAction_Socket_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Socket.Equal(that1.Socket) {
		return false
	}
	return true
}
func (this *ContainerAction_Exec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerAction_Exec)
	if !ok {
		that2, ok := that.(ContainerAction_Exec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Command) != len(that1.Command) {
		return false
	}
	for i := range this.Command {
		if this.Command[i] != that1.Command[i] {
			return false
		}
	}
	return true
}
func (this *ContainerAction_HTTP) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerAction_HTTP)
	if !ok {
		that2, ok := that.(ContainerAction_HTTP)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Method != that1.Method {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	return true
}
func (this *ContainerAction_Socket) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerAction_Socket)
	if !ok {
		that2, ok := that.(ContainerAction_Socket)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	return true
}
func (this *ContainerProbeSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerProbeSpec)
	if !ok {
		that2, ok := that.(ContainerProbeSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.InitialDelay != that1.InitialDelay {
		return false
	}
	if this.ProbeTimeout != that1.ProbeTimeout {
		return false
	}
	if this.ProbeInterval != that1.ProbeInterval {
		return false
	}
	if this.SuccessThreshold != that1.SuccessThreshold {
		return false
	}
	if this.FailureThreshold != that1.FailureThreshold {
		return false
	}
	if !this.Method.Equal(that1.Method) {
		return false
	}
	return true
}
func (this *ContainerSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerSpec)
	if !ok {
		that2, ok := that.(ContainerSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Image != that1.Image {
		return false
	}
	if this.WorkingDir != that1.WorkingDir {
		return false
	}
	if this.Stdin != that1.Stdin {
		return false
	}
	if this.StdinOnce != that1.StdinOnce {
		return false
	}
	if this.Tty != that1.Tty {
		return false
	}
	if len(this.Command) != len(that1.Command) {
		return false
	}
	for i := range this.Command {
		if this.Command[i] != that1.Command[i] {
			return false
		}
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if this.Args[i] != that1.Args[i] {
			return false
		}
	}
	if len(this.Envs) != len(that1.Envs) {
		return false
	}
	for i := range this.Envs {
		if this.Envs[i] != that1.Envs[i] {
			return false
		}
	}
	if len(this.Mounts) != len(that1.Mounts) {
		return false
	}
	for i := range this.Mounts {
		if !this.Mounts[i].Equal(that1.Mounts[i]) {
			return false
		}
	}
	if !this.ReadinessCheck.Equal(that1.ReadinessCheck) {
		return false
	}
	if !this.LivenessCheck.Equal(that1.LivenessCheck) {
		return false
	}
	if !this.Security.Equal(that1.Security) {
		return false
	}
	if !this.HookPostStart.Equal(that1.HookPostStart) {
		return false
	}
	return true
}
func (this *Bandwidth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Bandwidth)
	if !ok {
		that2, ok := that.(Bandwidth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IngressRate != that1.IngressRate {
		return false
	}
	if this.EgressRate != that1.EgressRate {
		return false
	}
	if this.IngressBurst != that1.IngressBurst {
		return false
	}
	if this.EgressBurst != that1.EgressBurst {
		return false
	}
	return true
}
func (this *ContainerPortSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerPortSpec)
	if !ok {
		that2, ok := that.(ContainerPortSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.ContainerPort != that1.ContainerPort {
		return false
	}
	if this.HostPort != that1.HostPort {
		return false
	}
	if this.HostIp != that1.HostIp {
		return false
	}
	return true
}
func (this *PodNetworkSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodNetworkSpec)
	if !ok {
		that2, ok := that.(PodNetworkSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CidrIpv4 != that1.CidrIpv4 {
		return false
	}
	if this.CidrIpv6 != that1.CidrIpv6 {
		return false
	}
	if !this.Bandwidth.Equal(that1.Bandwidth) {
		return false
	}
	if len(this.NameServers) != len(that1.NameServers) {
		return false
	}
	for i := range this.NameServers {
		if this.NameServers[i] != that1.NameServers[i] {
			return false
		}
	}
	if len(this.SearchDomains) != len(that1.SearchDomains) {
		return false
	}
	for i := range this.SearchDomains {
		if this.SearchDomains[i] != that1.SearchDomains[i] {
			return false
		}
	}
	if len(this.DnsOptions) != len(that1.DnsOptions) {
		return false
	}
	for i := range this.DnsOptions {
		if this.DnsOptions[i] != that1.DnsOptions[i] {
			return false
		}
	}
	if len(this.Hosts) != len(that1.Hosts) {
		return false
	}
	for i := range this.Hosts {
		if this.Hosts[i] != that1.Hosts[i] {
			return false
		}
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if !this.Ports[i].Equal(that1.Ports[i]) {
			return false
		}
	}
	return true
}
func (this *PodVolumeSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodVolumeSpec)
	if !ok {
		that2, ok := that.(PodVolumeSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.HostPaths) != len(that1.HostPaths) {
		return false
	}
	for i := range this.HostPaths {
		if this.HostPaths[i] != that1.HostPaths[i] {
			return false
		}
	}
	if len(this.VolumeData) != len(that1.VolumeData) {
		return false
	}
	for i := range this.VolumeData {
		if !this.VolumeData[i].Equal(that1.VolumeData[i]) {
			return false
		}
	}
	return true
}
func (this *PodSecuritySpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecuritySpec)
	if !ok {
		that2, ok := that.(PodSecuritySpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Sysctls) != len(that1.Sysctls) {
		return false
	}
	for i := range this.Sysctls {
		if this.Sysctls[i] != that1.Sysctls[i] {
			return false
		}
	}
	return true
}
func (this *PodEnsureCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodEnsureCmd)
	if !ok {
		that2, ok := that.(PodEnsureCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.RestartPolicy != that1.RestartPolicy {
		return false
	}
	if this.HostIpc != that1.HostIpc {
		return false
	}
	if this.HostNetwork != that1.HostNetwork {
		return false
	}
	if this.HostPid != that1.HostPid {
		return false
	}
	if this.SharePid != that1.SharePid {
		return false
	}
	if this.Wait != that1.Wait {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if len(this.Containers) != len(that1.Containers) {
		return false
	}
	for i := range this.Containers {
		if !this.Containers[i].Equal(that1.Containers[i]) {
			return false
		}
	}
	if !this.Network.Equal(that1.Network) {
		return false
	}
	if !this.Volumes.Equal(that1.Volumes) {
		return false
	}
	if !this.Security.Equal(that1.Security) {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *PodDeleteCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodDeleteCmd)
	if !ok {
		that2, ok := that.(PodDeleteCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if len(this.Containers) != len(that1.Containers) {
		return false
	}
	for i := range this.Containers {
		if this.Containers[i] != that1.Containers[i] {
			return false
		}
	}
	if this.GraceTime != that1.GraceTime {
		return false
	}
	if len(this.HookPreStop) != len(that1.HookPreStop) {
		return false
	}
	for i := range this.HookPreStop {
		if !this.HookPreStop[i].Equal(that1.HookPreStop[i]) {
			return false
		}
	}
	return true
}
func (this *PodListCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodListCmd)
	if !ok {
		that2, ok := that.(PodListCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.All != that1.All {
		return false
	}
	return true
}
func (this *NamedData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.NamedData{")
	keysForDataMap := make([]string, 0, len(this.DataMap))
	for k, _ := range this.DataMap {
		keysForDataMap = append(keysForDataMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDataMap)
	mapStringForDataMap := "map[string][]byte{"
	for _, k := range keysForDataMap {
		mapStringForDataMap += fmt.Sprintf("%#v: %#v,", k, this.DataMap[k])
	}
	mapStringForDataMap += "}"
	if this.DataMap != nil {
		s = append(s, "DataMap: "+mapStringForDataMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SELinuxOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&aranyagopb.SELinuxOptions{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Level: "+fmt.Sprintf("%#v", this.Level)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerSecuritySpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&aranyagopb.ContainerSecuritySpec{")
	s = append(s, "Privileged: "+fmt.Sprintf("%#v", this.Privileged)+",\n")
	s = append(s, "AllowNewPrivileges: "+fmt.Sprintf("%#v", this.AllowNewPrivileges)+",\n")
	s = append(s, "NonRoot: "+fmt.Sprintf("%#v", this.NonRoot)+",\n")
	s = append(s, "ReadOnlyRootfs: "+fmt.Sprintf("%#v", this.ReadOnlyRootfs)+",\n")
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "Group: "+fmt.Sprintf("%#v", this.Group)+",\n")
	s = append(s, "CapsAdd: "+fmt.Sprintf("%#v", this.CapsAdd)+",\n")
	s = append(s, "CapsDrop: "+fmt.Sprintf("%#v", this.CapsDrop)+",\n")
	s = append(s, "ProcMountKind: "+fmt.Sprintf("%#v", this.ProcMountKind)+",\n")
	if this.SelinuxOptions != nil {
		s = append(s, "SelinuxOptions: "+fmt.Sprintf("%#v", this.SelinuxOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerMountSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&aranyagopb.ContainerMountSpec{")
	s = append(s, "MountPath: "+fmt.Sprintf("%#v", this.MountPath)+",\n")
	s = append(s, "SubPath: "+fmt.Sprintf("%#v", this.SubPath)+",\n")
	s = append(s, "ReadOnly: "+fmt.Sprintf("%#v", this.ReadOnly)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	s = append(s, "FileMode: "+fmt.Sprintf("%#v", this.FileMode)+",\n")
	s = append(s, "Remote: "+fmt.Sprintf("%#v", this.Remote)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KeyValuePair) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aranyagopb.KeyValuePair{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&aranyagopb.ContainerAction{")
	if this.Action != nil {
		s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerAction_Exec_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aranyagopb.ContainerAction_Exec_{` +
		`Exec:` + fmt.Sprintf("%#v", this.Exec) + `}`}, ", ")
	return s
}
func (this *ContainerAction_Http) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aranyagopb.ContainerAction_Http{` +
		`Http:` + fmt.Sprintf("%#v", this.Http) + `}`}, ", ")
	return s
}
func (this *ContainerAction_Socket_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aranyagopb.ContainerAction_Socket_{` +
		`Socket:` + fmt.Sprintf("%#v", this.Socket) + `}`}, ", ")
	return s
}
func (this *ContainerAction_Exec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.ContainerAction_Exec{")
	s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerAction_HTTP) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&aranyagopb.ContainerAction_HTTP{")
	s = append(s, "Method: "+fmt.Sprintf("%#v", this.Method)+",\n")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerAction_Socket) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.ContainerAction_Socket{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerProbeSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&aranyagopb.ContainerProbeSpec{")
	s = append(s, "InitialDelay: "+fmt.Sprintf("%#v", this.InitialDelay)+",\n")
	s = append(s, "ProbeTimeout: "+fmt.Sprintf("%#v", this.ProbeTimeout)+",\n")
	s = append(s, "ProbeInterval: "+fmt.Sprintf("%#v", this.ProbeInterval)+",\n")
	s = append(s, "SuccessThreshold: "+fmt.Sprintf("%#v", this.SuccessThreshold)+",\n")
	s = append(s, "FailureThreshold: "+fmt.Sprintf("%#v", this.FailureThreshold)+",\n")
	if this.Method != nil {
		s = append(s, "Method: "+fmt.Sprintf("%#v", this.Method)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&aranyagopb.ContainerSpec{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Image: "+fmt.Sprintf("%#v", this.Image)+",\n")
	s = append(s, "WorkingDir: "+fmt.Sprintf("%#v", this.WorkingDir)+",\n")
	s = append(s, "Stdin: "+fmt.Sprintf("%#v", this.Stdin)+",\n")
	s = append(s, "StdinOnce: "+fmt.Sprintf("%#v", this.StdinOnce)+",\n")
	s = append(s, "Tty: "+fmt.Sprintf("%#v", this.Tty)+",\n")
	s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	s = append(s, "Args: "+fmt.Sprintf("%#v", this.Args)+",\n")
	keysForEnvs := make([]string, 0, len(this.Envs))
	for k, _ := range this.Envs {
		keysForEnvs = append(keysForEnvs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEnvs)
	mapStringForEnvs := "map[string]string{"
	for _, k := range keysForEnvs {
		mapStringForEnvs += fmt.Sprintf("%#v: %#v,", k, this.Envs[k])
	}
	mapStringForEnvs += "}"
	if this.Envs != nil {
		s = append(s, "Envs: "+mapStringForEnvs+",\n")
	}
	keysForMounts := make([]string, 0, len(this.Mounts))
	for k, _ := range this.Mounts {
		keysForMounts = append(keysForMounts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMounts)
	mapStringForMounts := "map[string]*ContainerMountSpec{"
	for _, k := range keysForMounts {
		mapStringForMounts += fmt.Sprintf("%#v: %#v,", k, this.Mounts[k])
	}
	mapStringForMounts += "}"
	if this.Mounts != nil {
		s = append(s, "Mounts: "+mapStringForMounts+",\n")
	}
	if this.ReadinessCheck != nil {
		s = append(s, "ReadinessCheck: "+fmt.Sprintf("%#v", this.ReadinessCheck)+",\n")
	}
	if this.LivenessCheck != nil {
		s = append(s, "LivenessCheck: "+fmt.Sprintf("%#v", this.LivenessCheck)+",\n")
	}
	if this.Security != nil {
		s = append(s, "Security: "+fmt.Sprintf("%#v", this.Security)+",\n")
	}
	if this.HookPostStart != nil {
		s = append(s, "HookPostStart: "+fmt.Sprintf("%#v", this.HookPostStart)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Bandwidth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&aranyagopb.Bandwidth{")
	s = append(s, "IngressRate: "+fmt.Sprintf("%#v", this.IngressRate)+",\n")
	s = append(s, "EgressRate: "+fmt.Sprintf("%#v", this.EgressRate)+",\n")
	s = append(s, "IngressBurst: "+fmt.Sprintf("%#v", this.IngressBurst)+",\n")
	s = append(s, "EgressBurst: "+fmt.Sprintf("%#v", this.EgressBurst)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerPortSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&aranyagopb.ContainerPortSpec{")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "ContainerPort: "+fmt.Sprintf("%#v", this.ContainerPort)+",\n")
	s = append(s, "HostPort: "+fmt.Sprintf("%#v", this.HostPort)+",\n")
	s = append(s, "HostIp: "+fmt.Sprintf("%#v", this.HostIp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodNetworkSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&aranyagopb.PodNetworkSpec{")
	s = append(s, "CidrIpv4: "+fmt.Sprintf("%#v", this.CidrIpv4)+",\n")
	s = append(s, "CidrIpv6: "+fmt.Sprintf("%#v", this.CidrIpv6)+",\n")
	if this.Bandwidth != nil {
		s = append(s, "Bandwidth: "+fmt.Sprintf("%#v", this.Bandwidth)+",\n")
	}
	s = append(s, "NameServers: "+fmt.Sprintf("%#v", this.NameServers)+",\n")
	s = append(s, "SearchDomains: "+fmt.Sprintf("%#v", this.SearchDomains)+",\n")
	s = append(s, "DnsOptions: "+fmt.Sprintf("%#v", this.DnsOptions)+",\n")
	keysForHosts := make([]string, 0, len(this.Hosts))
	for k, _ := range this.Hosts {
		keysForHosts = append(keysForHosts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHosts)
	mapStringForHosts := "map[string]string{"
	for _, k := range keysForHosts {
		mapStringForHosts += fmt.Sprintf("%#v: %#v,", k, this.Hosts[k])
	}
	mapStringForHosts += "}"
	if this.Hosts != nil {
		s = append(s, "Hosts: "+mapStringForHosts+",\n")
	}
	keysForPorts := make([]string, 0, len(this.Ports))
	for k, _ := range this.Ports {
		keysForPorts = append(keysForPorts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPorts)
	mapStringForPorts := "map[string]*ContainerPortSpec{"
	for _, k := range keysForPorts {
		mapStringForPorts += fmt.Sprintf("%#v: %#v,", k, this.Ports[k])
	}
	mapStringForPorts += "}"
	if this.Ports != nil {
		s = append(s, "Ports: "+mapStringForPorts+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodVolumeSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aranyagopb.PodVolumeSpec{")
	keysForHostPaths := make([]string, 0, len(this.HostPaths))
	for k, _ := range this.HostPaths {
		keysForHostPaths = append(keysForHostPaths, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHostPaths)
	mapStringForHostPaths := "map[string]string{"
	for _, k := range keysForHostPaths {
		mapStringForHostPaths += fmt.Sprintf("%#v: %#v,", k, this.HostPaths[k])
	}
	mapStringForHostPaths += "}"
	if this.HostPaths != nil {
		s = append(s, "HostPaths: "+mapStringForHostPaths+",\n")
	}
	keysForVolumeData := make([]string, 0, len(this.VolumeData))
	for k, _ := range this.VolumeData {
		keysForVolumeData = append(keysForVolumeData, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVolumeData)
	mapStringForVolumeData := "map[string]*NamedData{"
	for _, k := range keysForVolumeData {
		mapStringForVolumeData += fmt.Sprintf("%#v: %#v,", k, this.VolumeData[k])
	}
	mapStringForVolumeData += "}"
	if this.VolumeData != nil {
		s = append(s, "VolumeData: "+mapStringForVolumeData+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodSecuritySpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.PodSecuritySpec{")
	keysForSysctls := make([]string, 0, len(this.Sysctls))
	for k, _ := range this.Sysctls {
		keysForSysctls = append(keysForSysctls, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSysctls)
	mapStringForSysctls := "map[string]string{"
	for _, k := range keysForSysctls {
		mapStringForSysctls += fmt.Sprintf("%#v: %#v,", k, this.Sysctls[k])
	}
	mapStringForSysctls += "}"
	if this.Sysctls != nil {
		s = append(s, "Sysctls: "+mapStringForSysctls+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodEnsureCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&aranyagopb.PodEnsureCmd{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "RestartPolicy: "+fmt.Sprintf("%#v", this.RestartPolicy)+",\n")
	s = append(s, "HostIpc: "+fmt.Sprintf("%#v", this.HostIpc)+",\n")
	s = append(s, "HostNetwork: "+fmt.Sprintf("%#v", this.HostNetwork)+",\n")
	s = append(s, "HostPid: "+fmt.Sprintf("%#v", this.HostPid)+",\n")
	s = append(s, "SharePid: "+fmt.Sprintf("%#v", this.SharePid)+",\n")
	s = append(s, "Wait: "+fmt.Sprintf("%#v", this.Wait)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	if this.Containers != nil {
		s = append(s, "Containers: "+fmt.Sprintf("%#v", this.Containers)+",\n")
	}
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	if this.Volumes != nil {
		s = append(s, "Volumes: "+fmt.Sprintf("%#v", this.Volumes)+",\n")
	}
	if this.Security != nil {
		s = append(s, "Security: "+fmt.Sprintf("%#v", this.Security)+",\n")
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodDeleteCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&aranyagopb.PodDeleteCmd{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Containers: "+fmt.Sprintf("%#v", this.Containers)+",\n")
	s = append(s, "GraceTime: "+fmt.Sprintf("%#v", this.GraceTime)+",\n")
	keysForHookPreStop := make([]string, 0, len(this.HookPreStop))
	for k, _ := range this.HookPreStop {
		keysForHookPreStop = append(keysForHookPreStop, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHookPreStop)
	mapStringForHookPreStop := "map[string]*ContainerAction{"
	for _, k := range keysForHookPreStop {
		mapStringForHookPreStop += fmt.Sprintf("%#v: %#v,", k, this.HookPreStop[k])
	}
	mapStringForHookPreStop += "}"
	if this.HookPreStop != nil {
		s = append(s, "HookPreStop: "+mapStringForHookPreStop+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodListCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&aranyagopb.PodListCmd{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "All: "+fmt.Sprintf("%#v", this.All)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCmdPod(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *NamedData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamedData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DataMap) > 0 {
		for k := range m.DataMap {
			v := m.DataMap[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintCmdPod(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SELinuxOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SELinuxOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SELinuxOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Level) > 0 {
		i -= len(m.Level)
		copy(dAtA[i:], m.Level)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Level)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerSecuritySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerSecuritySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerSecuritySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SelinuxOptions != nil {
		{
			size, err := m.SelinuxOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ProcMountKind != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.ProcMountKind))
		i--
		dAtA[i] = 0x48
	}
	if len(m.CapsDrop) > 0 {
		for iNdEx := len(m.CapsDrop) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CapsDrop[iNdEx])
			copy(dAtA[i:], m.CapsDrop[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.CapsDrop[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CapsAdd) > 0 {
		for iNdEx := len(m.CapsAdd) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CapsAdd[iNdEx])
			copy(dAtA[i:], m.CapsAdd[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.CapsAdd[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Group != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x30
	}
	if m.User != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.User))
		i--
		dAtA[i] = 0x28
	}
	if m.ReadOnlyRootfs {
		i--
		if m.ReadOnlyRootfs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.NonRoot {
		i--
		if m.NonRoot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AllowNewPrivileges {
		i--
		if m.AllowNewPrivileges {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Privileged {
		i--
		if m.Privileged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContainerMountSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerMountSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerMountSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Remote {
		i--
		if m.Remote {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.FileMode != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.FileMode))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Options[iNdEx])
			copy(dAtA[i:], m.Options[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Options[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if m.ReadOnly {
		i--
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.SubPath) > 0 {
		i -= len(m.SubPath)
		copy(dAtA[i:], m.SubPath)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.SubPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MountPath) > 0 {
		i -= len(m.MountPath)
		copy(dAtA[i:], m.MountPath)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.MountPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyValuePair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValuePair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValuePair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		{
			size := m.Action.Size()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ContainerAction_Exec_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerAction_Exec_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Exec != nil {
		{
			size, err := m.Exec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ContainerAction_Http) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerAction_Http) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Http != nil {
		{
			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ContainerAction_Socket_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerAction_Socket_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Socket != nil {
		{
			size, err := m.Socket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ContainerAction_Exec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerAction_Exec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerAction_Exec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		for iNdEx := len(m.Command) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Command[iNdEx])
			copy(dAtA[i:], m.Command[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Command[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ContainerAction_HTTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerAction_HTTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerAction_HTTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCmdPod(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerAction_Socket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerAction_Socket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerAction_Socket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerProbeSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerProbeSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerProbeSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Method != nil {
		{
			size, err := m.Method.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.FailureThreshold != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.FailureThreshold))
		i--
		dAtA[i] = 0x28
	}
	if m.SuccessThreshold != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.SuccessThreshold))
		i--
		dAtA[i] = 0x20
	}
	if m.ProbeInterval != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.ProbeInterval))
		i--
		dAtA[i] = 0x18
	}
	if m.ProbeTimeout != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.ProbeTimeout))
		i--
		dAtA[i] = 0x10
	}
	if m.InitialDelay != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.InitialDelay))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContainerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HookPostStart != nil {
		{
			size, err := m.HookPostStart.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Security != nil {
		{
			size, err := m.Security.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.LivenessCheck != nil {
		{
			size, err := m.LivenessCheck.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.ReadinessCheck != nil {
		{
			size, err := m.ReadinessCheck.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Mounts) > 0 {
		for k := range m.Mounts {
			v := m.Mounts[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCmdPod(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Envs) > 0 {
		for k := range m.Envs {
			v := m.Envs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Command) > 0 {
		for iNdEx := len(m.Command) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Command[iNdEx])
			copy(dAtA[i:], m.Command[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Command[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Tty {
		i--
		if m.Tty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.StdinOnce {
		i--
		if m.StdinOnce {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Stdin {
		i--
		if m.Stdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.WorkingDir) > 0 {
		i -= len(m.WorkingDir)
		copy(dAtA[i:], m.WorkingDir)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.WorkingDir)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Bandwidth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bandwidth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Bandwidth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EgressBurst != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.EgressBurst))
		i--
		dAtA[i] = 0x20
	}
	if m.IngressBurst != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.IngressBurst))
		i--
		dAtA[i] = 0x18
	}
	if m.EgressRate != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.EgressRate))
		i--
		dAtA[i] = 0x10
	}
	if m.IngressRate != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.IngressRate))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContainerPortSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerPortSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerPortSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HostIp) > 0 {
		i -= len(m.HostIp)
		copy(dAtA[i:], m.HostIp)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.HostIp)))
		i--
		dAtA[i] = 0x22
	}
	if m.HostPort != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.HostPort))
		i--
		dAtA[i] = 0x18
	}
	if m.ContainerPort != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.ContainerPort))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PodNetworkSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodNetworkSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodNetworkSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for k := range m.Ports {
			v := m.Ports[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCmdPod(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Hosts) > 0 {
		for k := range m.Hosts {
			v := m.Hosts[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.DnsOptions) > 0 {
		for iNdEx := len(m.DnsOptions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DnsOptions[iNdEx])
			copy(dAtA[i:], m.DnsOptions[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.DnsOptions[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SearchDomains) > 0 {
		for iNdEx := len(m.SearchDomains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SearchDomains[iNdEx])
			copy(dAtA[i:], m.SearchDomains[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.SearchDomains[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NameServers) > 0 {
		for iNdEx := len(m.NameServers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NameServers[iNdEx])
			copy(dAtA[i:], m.NameServers[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.NameServers[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Bandwidth != nil {
		{
			size, err := m.Bandwidth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CidrIpv6) > 0 {
		i -= len(m.CidrIpv6)
		copy(dAtA[i:], m.CidrIpv6)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.CidrIpv6)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CidrIpv4) > 0 {
		i -= len(m.CidrIpv4)
		copy(dAtA[i:], m.CidrIpv4)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.CidrIpv4)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PodVolumeSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodVolumeSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodVolumeSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VolumeData) > 0 {
		for k := range m.VolumeData {
			v := m.VolumeData[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCmdPod(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.HostPaths) > 0 {
		for k := range m.HostPaths {
			v := m.HostPaths[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PodSecuritySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodSecuritySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecuritySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sysctls) > 0 {
		for k := range m.Sysctls {
			v := m.Sysctls[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x7a
		}
	}
	return len(dAtA) - i, nil
}

func (m *PodEnsureCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodEnsureCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodEnsureCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.Security != nil {
		{
			size, err := m.Security.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Volumes != nil {
		{
			size, err := m.Volumes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Network != nil {
		{
			size, err := m.Network.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.Containers) > 0 {
		for iNdEx := len(m.Containers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Containers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCmdPod(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x52
	}
	if m.Wait {
		i--
		if m.Wait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.SharePid {
		i--
		if m.SharePid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.HostPid {
		i--
		if m.HostPid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.HostNetwork {
		i--
		if m.HostNetwork {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.HostIpc {
		i--
		if m.HostIpc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.RestartPolicy != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.RestartPolicy))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PodUid) > 0 {
		i -= len(m.PodUid)
		copy(dAtA[i:], m.PodUid)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.PodUid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PodDeleteCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodDeleteCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodDeleteCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HookPreStop) > 0 {
		for k := range m.HookPreStop {
			v := m.HookPreStop[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCmdPod(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.GraceTime != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.GraceTime))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Containers) > 0 {
		for iNdEx := len(m.Containers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Containers[iNdEx])
			copy(dAtA[i:], m.Containers[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Containers[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PodUid) > 0 {
		i -= len(m.PodUid)
		copy(dAtA[i:], m.PodUid)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.PodUid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PodListCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodListCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodListCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.All {
		i--
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCmdPod(dAtA []byte, offset int, v uint64) int {
	offset -= sovCmdPod(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NamedData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DataMap) > 0 {
		for k, v := range m.DataMap {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovCmdPod(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SELinuxOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Level)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}

func (m *ContainerSecuritySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Privileged {
		n += 2
	}
	if m.AllowNewPrivileges {
		n += 2
	}
	if m.NonRoot {
		n += 2
	}
	if m.ReadOnlyRootfs {
		n += 2
	}
	if m.User != 0 {
		n += 1 + sovCmdPod(uint64(m.User))
	}
	if m.Group != 0 {
		n += 1 + sovCmdPod(uint64(m.Group))
	}
	if len(m.CapsAdd) > 0 {
		for _, s := range m.CapsAdd {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if len(m.CapsDrop) > 0 {
		for _, s := range m.CapsDrop {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if m.ProcMountKind != 0 {
		n += 1 + sovCmdPod(uint64(m.ProcMountKind))
	}
	if m.SelinuxOptions != nil {
		l = m.SelinuxOptions.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}

func (m *ContainerMountSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MountPath)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.SubPath)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.ReadOnly {
		n += 2
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, s := range m.Options {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if m.FileMode != 0 {
		n += 1 + sovCmdPod(uint64(m.FileMode))
	}
	if m.Remote {
		n += 2
	}
	return n
}

func (m *KeyValuePair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}

func (m *ContainerAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		n += m.Action.Size()
	}
	return n
}

func (m *ContainerAction_Exec_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exec != nil {
		l = m.Exec.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}
func (m *ContainerAction_Http) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}
func (m *ContainerAction_Socket_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Socket != nil {
		l = m.Socket.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}
func (m *ContainerAction_Exec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	return n
}

func (m *ContainerAction_HTTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	return n
}

func (m *ContainerAction_Socket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}

func (m *ContainerProbeSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InitialDelay != 0 {
		n += 1 + sovCmdPod(uint64(m.InitialDelay))
	}
	if m.ProbeTimeout != 0 {
		n += 1 + sovCmdPod(uint64(m.ProbeTimeout))
	}
	if m.ProbeInterval != 0 {
		n += 1 + sovCmdPod(uint64(m.ProbeInterval))
	}
	if m.SuccessThreshold != 0 {
		n += 1 + sovCmdPod(uint64(m.SuccessThreshold))
	}
	if m.FailureThreshold != 0 {
		n += 1 + sovCmdPod(uint64(m.FailureThreshold))
	}
	if m.Method != nil {
		l = m.Method.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}

func (m *ContainerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.WorkingDir)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.Stdin {
		n += 2
	}
	if m.StdinOnce {
		n += 2
	}
	if m.Tty {
		n += 2
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if len(m.Envs) > 0 {
		for k, v := range m.Envs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + 1 + len(v) + sovCmdPod(uint64(len(v)))
			n += mapEntrySize + 1 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	if len(m.Mounts) > 0 {
		for k, v := range m.Mounts {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdPod(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	if m.ReadinessCheck != nil {
		l = m.ReadinessCheck.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.LivenessCheck != nil {
		l = m.LivenessCheck.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.Security != nil {
		l = m.Security.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.HookPostStart != nil {
		l = m.HookPostStart.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}

func (m *Bandwidth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IngressRate != 0 {
		n += 1 + sovCmdPod(uint64(m.IngressRate))
	}
	if m.EgressRate != 0 {
		n += 1 + sovCmdPod(uint64(m.EgressRate))
	}
	if m.IngressBurst != 0 {
		n += 1 + sovCmdPod(uint64(m.IngressBurst))
	}
	if m.EgressBurst != 0 {
		n += 1 + sovCmdPod(uint64(m.EgressBurst))
	}
	return n
}

func (m *ContainerPortSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.ContainerPort != 0 {
		n += 1 + sovCmdPod(uint64(m.ContainerPort))
	}
	if m.HostPort != 0 {
		n += 1 + sovCmdPod(uint64(m.HostPort))
	}
	l = len(m.HostIp)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}

func (m *PodNetworkSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CidrIpv4)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.CidrIpv6)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.Bandwidth != nil {
		l = m.Bandwidth.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if len(m.NameServers) > 0 {
		for _, s := range m.NameServers {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if len(m.SearchDomains) > 0 {
		for _, s := range m.SearchDomains {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if len(m.DnsOptions) > 0 {
		for _, s := range m.DnsOptions {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if len(m.Hosts) > 0 {
		for k, v := range m.Hosts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + 1 + len(v) + sovCmdPod(uint64(len(v)))
			n += mapEntrySize + 1 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	if len(m.Ports) > 0 {
		for k, v := range m.Ports {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdPod(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PodVolumeSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.HostPaths) > 0 {
		for k, v := range m.HostPaths {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + 1 + len(v) + sovCmdPod(uint64(len(v)))
			n += mapEntrySize + 2 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	if len(m.VolumeData) > 0 {
		for k, v := range m.VolumeData {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdPod(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PodSecuritySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sysctls) > 0 {
		for k, v := range m.Sysctls {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + 1 + len(v) + sovCmdPod(uint64(len(v)))
			n += mapEntrySize + 1 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PodEnsureCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.RestartPolicy != 0 {
		n += 1 + sovCmdPod(uint64(m.RestartPolicy))
	}
	if m.HostIpc {
		n += 2
	}
	if m.HostNetwork {
		n += 2
	}
	if m.HostPid {
		n += 2
	}
	if m.SharePid {
		n += 2
	}
	if m.Wait {
		n += 2
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.Size()
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if m.Network != nil {
		l = m.Network.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.Volumes != nil {
		l = m.Volumes.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.Security != nil {
		l = m.Security.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + 1 + len(v) + sovCmdPod(uint64(len(v)))
			n += mapEntrySize + 1 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PodDeleteCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if len(m.Containers) > 0 {
		for _, s := range m.Containers {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if m.GraceTime != 0 {
		n += 1 + sovCmdPod(uint64(m.GraceTime))
	}
	if len(m.HookPreStop) > 0 {
		for k, v := range m.HookPreStop {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdPod(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PodListCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.All {
		n += 2
	}
	return n
}

func sovCmdPod(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCmdPod(x uint64) (n int) {
	return sovCmdPod(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *NamedData) String() string {
	if this == nil {
		return "nil"
	}
	keysForDataMap := make([]string, 0, len(this.DataMap))
	for k, _ := range this.DataMap {
		keysForDataMap = append(keysForDataMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDataMap)
	mapStringForDataMap := "map[string][]byte{"
	for _, k := range keysForDataMap {
		mapStringForDataMap += fmt.Sprintf("%v: %v,", k, this.DataMap[k])
	}
	mapStringForDataMap += "}"
	s := strings.Join([]string{`&NamedData{`,
		`DataMap:` + mapStringForDataMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *SELinuxOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SELinuxOptions{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Level:` + fmt.Sprintf("%v", this.Level) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerSecuritySpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerSecuritySpec{`,
		`Privileged:` + fmt.Sprintf("%v", this.Privileged) + `,`,
		`AllowNewPrivileges:` + fmt.Sprintf("%v", this.AllowNewPrivileges) + `,`,
		`NonRoot:` + fmt.Sprintf("%v", this.NonRoot) + `,`,
		`ReadOnlyRootfs:` + fmt.Sprintf("%v", this.ReadOnlyRootfs) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`Group:` + fmt.Sprintf("%v", this.Group) + `,`,
		`CapsAdd:` + fmt.Sprintf("%v", this.CapsAdd) + `,`,
		`CapsDrop:` + fmt.Sprintf("%v", this.CapsDrop) + `,`,
		`ProcMountKind:` + fmt.Sprintf("%v", this.ProcMountKind) + `,`,
		`SelinuxOptions:` + strings.Replace(this.SelinuxOptions.String(), "SELinuxOptions", "SELinuxOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerMountSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerMountSpec{`,
		`MountPath:` + fmt.Sprintf("%v", this.MountPath) + `,`,
		`SubPath:` + fmt.Sprintf("%v", this.SubPath) + `,`,
		`ReadOnly:` + fmt.Sprintf("%v", this.ReadOnly) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Options:` + fmt.Sprintf("%v", this.Options) + `,`,
		`FileMode:` + fmt.Sprintf("%v", this.FileMode) + `,`,
		`Remote:` + fmt.Sprintf("%v", this.Remote) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KeyValuePair) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KeyValuePair{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerAction{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerAction_Exec_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerAction_Exec_{`,
		`Exec:` + strings.Replace(fmt.Sprintf("%v", this.Exec), "ContainerAction_Exec", "ContainerAction_Exec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerAction_Http) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerAction_Http{`,
		`Http:` + strings.Replace(fmt.Sprintf("%v", this.Http), "ContainerAction_HTTP", "ContainerAction_HTTP", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerAction_Socket_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerAction_Socket_{`,
		`Socket:` + strings.Replace(fmt.Sprintf("%v", this.Socket), "ContainerAction_Socket", "ContainerAction_Socket", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerAction_Exec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerAction_Exec{`,
		`Command:` + fmt.Sprintf("%v", this.Command) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerAction_HTTP) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHeaders := "[]*KeyValuePair{"
	for _, f := range this.Headers {
		repeatedStringForHeaders += strings.Replace(f.String(), "KeyValuePair", "KeyValuePair", 1) + ","
	}
	repeatedStringForHeaders += "}"
	s := strings.Join([]string{`&ContainerAction_HTTP{`,
		`Method:` + fmt.Sprintf("%v", this.Method) + `,`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`Headers:` + repeatedStringForHeaders + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerAction_Socket) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerAction_Socket{`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerProbeSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerProbeSpec{`,
		`InitialDelay:` + fmt.Sprintf("%v", this.InitialDelay) + `,`,
		`ProbeTimeout:` + fmt.Sprintf("%v", this.ProbeTimeout) + `,`,
		`ProbeInterval:` + fmt.Sprintf("%v", this.ProbeInterval) + `,`,
		`SuccessThreshold:` + fmt.Sprintf("%v", this.SuccessThreshold) + `,`,
		`FailureThreshold:` + fmt.Sprintf("%v", this.FailureThreshold) + `,`,
		`Method:` + strings.Replace(this.Method.String(), "ContainerAction", "ContainerAction", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerSpec) String() string {
	if this == nil {
		return "nil"
	}
	keysForEnvs := make([]string, 0, len(this.Envs))
	for k, _ := range this.Envs {
		keysForEnvs = append(keysForEnvs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEnvs)
	mapStringForEnvs := "map[string]string{"
	for _, k := range keysForEnvs {
		mapStringForEnvs += fmt.Sprintf("%v: %v,", k, this.Envs[k])
	}
	mapStringForEnvs += "}"
	keysForMounts := make([]string, 0, len(this.Mounts))
	for k, _ := range this.Mounts {
		keysForMounts = append(keysForMounts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMounts)
	mapStringForMounts := "map[string]*ContainerMountSpec{"
	for _, k := range keysForMounts {
		mapStringForMounts += fmt.Sprintf("%v: %v,", k, this.Mounts[k])
	}
	mapStringForMounts += "}"
	s := strings.Join([]string{`&ContainerSpec{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Image:` + fmt.Sprintf("%v", this.Image) + `,`,
		`WorkingDir:` + fmt.Sprintf("%v", this.WorkingDir) + `,`,
		`Stdin:` + fmt.Sprintf("%v", this.Stdin) + `,`,
		`StdinOnce:` + fmt.Sprintf("%v", this.StdinOnce) + `,`,
		`Tty:` + fmt.Sprintf("%v", this.Tty) + `,`,
		`Command:` + fmt.Sprintf("%v", this.Command) + `,`,
		`Args:` + fmt.Sprintf("%v", this.Args) + `,`,
		`Envs:` + mapStringForEnvs + `,`,
		`Mounts:` + mapStringForMounts + `,`,
		`ReadinessCheck:` + strings.Replace(this.ReadinessCheck.String(), "ContainerProbeSpec", "ContainerProbeSpec", 1) + `,`,
		`LivenessCheck:` + strings.Replace(this.LivenessCheck.String(), "ContainerProbeSpec", "ContainerProbeSpec", 1) + `,`,
		`Security:` + strings.Replace(this.Security.String(), "ContainerSecuritySpec", "ContainerSecuritySpec", 1) + `,`,
		`HookPostStart:` + strings.Replace(this.HookPostStart.String(), "ContainerAction", "ContainerAction", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Bandwidth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Bandwidth{`,
		`IngressRate:` + fmt.Sprintf("%v", this.IngressRate) + `,`,
		`EgressRate:` + fmt.Sprintf("%v", this.EgressRate) + `,`,
		`IngressBurst:` + fmt.Sprintf("%v", this.IngressBurst) + `,`,
		`EgressBurst:` + fmt.Sprintf("%v", this.EgressBurst) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerPortSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerPortSpec{`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`ContainerPort:` + fmt.Sprintf("%v", this.ContainerPort) + `,`,
		`HostPort:` + fmt.Sprintf("%v", this.HostPort) + `,`,
		`HostIp:` + fmt.Sprintf("%v", this.HostIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodNetworkSpec) String() string {
	if this == nil {
		return "nil"
	}
	keysForHosts := make([]string, 0, len(this.Hosts))
	for k, _ := range this.Hosts {
		keysForHosts = append(keysForHosts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHosts)
	mapStringForHosts := "map[string]string{"
	for _, k := range keysForHosts {
		mapStringForHosts += fmt.Sprintf("%v: %v,", k, this.Hosts[k])
	}
	mapStringForHosts += "}"
	keysForPorts := make([]string, 0, len(this.Ports))
	for k, _ := range this.Ports {
		keysForPorts = append(keysForPorts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPorts)
	mapStringForPorts := "map[string]*ContainerPortSpec{"
	for _, k := range keysForPorts {
		mapStringForPorts += fmt.Sprintf("%v: %v,", k, this.Ports[k])
	}
	mapStringForPorts += "}"
	s := strings.Join([]string{`&PodNetworkSpec{`,
		`CidrIpv4:` + fmt.Sprintf("%v", this.CidrIpv4) + `,`,
		`CidrIpv6:` + fmt.Sprintf("%v", this.CidrIpv6) + `,`,
		`Bandwidth:` + strings.Replace(this.Bandwidth.String(), "Bandwidth", "Bandwidth", 1) + `,`,
		`NameServers:` + fmt.Sprintf("%v", this.NameServers) + `,`,
		`SearchDomains:` + fmt.Sprintf("%v", this.SearchDomains) + `,`,
		`DnsOptions:` + fmt.Sprintf("%v", this.DnsOptions) + `,`,
		`Hosts:` + mapStringForHosts + `,`,
		`Ports:` + mapStringForPorts + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodVolumeSpec) String() string {
	if this == nil {
		return "nil"
	}
	keysForHostPaths := make([]string, 0, len(this.HostPaths))
	for k, _ := range this.HostPaths {
		keysForHostPaths = append(keysForHostPaths, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHostPaths)
	mapStringForHostPaths := "map[string]string{"
	for _, k := range keysForHostPaths {
		mapStringForHostPaths += fmt.Sprintf("%v: %v,", k, this.HostPaths[k])
	}
	mapStringForHostPaths += "}"
	keysForVolumeData := make([]string, 0, len(this.VolumeData))
	for k, _ := range this.VolumeData {
		keysForVolumeData = append(keysForVolumeData, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVolumeData)
	mapStringForVolumeData := "map[string]*NamedData{"
	for _, k := range keysForVolumeData {
		mapStringForVolumeData += fmt.Sprintf("%v: %v,", k, this.VolumeData[k])
	}
	mapStringForVolumeData += "}"
	s := strings.Join([]string{`&PodVolumeSpec{`,
		`HostPaths:` + mapStringForHostPaths + `,`,
		`VolumeData:` + mapStringForVolumeData + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecuritySpec) String() string {
	if this == nil {
		return "nil"
	}
	keysForSysctls := make([]string, 0, len(this.Sysctls))
	for k, _ := range this.Sysctls {
		keysForSysctls = append(keysForSysctls, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSysctls)
	mapStringForSysctls := "map[string]string{"
	for _, k := range keysForSysctls {
		mapStringForSysctls += fmt.Sprintf("%v: %v,", k, this.Sysctls[k])
	}
	mapStringForSysctls += "}"
	s := strings.Join([]string{`&PodSecuritySpec{`,
		`Sysctls:` + mapStringForSysctls + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodEnsureCmd) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForContainers := "[]*ContainerSpec{"
	for _, f := range this.Containers {
		repeatedStringForContainers += strings.Replace(f.String(), "ContainerSpec", "ContainerSpec", 1) + ","
	}
	repeatedStringForContainers += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&PodEnsureCmd{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`RestartPolicy:` + fmt.Sprintf("%v", this.RestartPolicy) + `,`,
		`HostIpc:` + fmt.Sprintf("%v", this.HostIpc) + `,`,
		`HostNetwork:` + fmt.Sprintf("%v", this.HostNetwork) + `,`,
		`HostPid:` + fmt.Sprintf("%v", this.HostPid) + `,`,
		`SharePid:` + fmt.Sprintf("%v", this.SharePid) + `,`,
		`Wait:` + fmt.Sprintf("%v", this.Wait) + `,`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`Containers:` + repeatedStringForContainers + `,`,
		`Network:` + strings.Replace(this.Network.String(), "PodNetworkSpec", "PodNetworkSpec", 1) + `,`,
		`Volumes:` + strings.Replace(this.Volumes.String(), "PodVolumeSpec", "PodVolumeSpec", 1) + `,`,
		`Security:` + strings.Replace(this.Security.String(), "PodSecuritySpec", "PodSecuritySpec", 1) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodDeleteCmd) String() string {
	if this == nil {
		return "nil"
	}
	keysForHookPreStop := make([]string, 0, len(this.HookPreStop))
	for k, _ := range this.HookPreStop {
		keysForHookPreStop = append(keysForHookPreStop, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHookPreStop)
	mapStringForHookPreStop := "map[string]*ContainerAction{"
	for _, k := range keysForHookPreStop {
		mapStringForHookPreStop += fmt.Sprintf("%v: %v,", k, this.HookPreStop[k])
	}
	mapStringForHookPreStop += "}"
	s := strings.Join([]string{`&PodDeleteCmd{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Containers:` + fmt.Sprintf("%v", this.Containers) + `,`,
		`GraceTime:` + fmt.Sprintf("%v", this.GraceTime) + `,`,
		`HookPreStop:` + mapStringForHookPreStop + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodListCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodListCmd{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`All:` + fmt.Sprintf("%v", this.All) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCmdPod(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *NamedData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataMap == nil {
				m.DataMap = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthCmdPod
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DataMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SELinuxOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SELinuxOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SELinuxOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerSecuritySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerSecuritySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerSecuritySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowNewPrivileges", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowNewPrivileges = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonRoot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NonRoot = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnlyRootfs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnlyRootfs = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			m.User = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.User |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapsAdd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapsAdd = append(m.CapsAdd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapsDrop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapsDrop = append(m.CapsDrop, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcMountKind", wireType)
			}
			m.ProcMountKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcMountKind |= ContainerSecuritySpec_ProcMountKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelinuxOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SelinuxOptions == nil {
				m.SelinuxOptions = &SELinuxOptions{}
			}
			if err := m.SelinuxOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerMountSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerMountSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerMountSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMode", wireType)
			}
			m.FileMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileMode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remote", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remote = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValuePair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValuePair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValuePair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContainerAction_Exec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ContainerAction_Exec_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContainerAction_HTTP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ContainerAction_Http{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Socket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContainerAction_Socket{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ContainerAction_Socket_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerAction_Exec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Exec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Exec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerAction_HTTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &KeyValuePair{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerAction_Socket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Socket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Socket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerProbeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerProbeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerProbeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialDelay", wireType)
			}
			m.InitialDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialDelay |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbeTimeout", wireType)
			}
			m.ProbeTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProbeTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbeInterval", wireType)
			}
			m.ProbeInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProbeInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessThreshold", wireType)
			}
			m.SuccessThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccessThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureThreshold", wireType)
			}
			m.FailureThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FailureThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Method == nil {
				m.Method = &ContainerAction{}
			}
			if err := m.Method.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkingDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stdin = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdinOnce", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StdinOnce = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tty = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Envs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Envs == nil {
				m.Envs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Envs[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mounts == nil {
				m.Mounts = make(map[string]*ContainerMountSpec)
			}
			var mapkey string
			var mapvalue *ContainerMountSpec
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdPod
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ContainerMountSpec{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Mounts[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadinessCheck == nil {
				m.ReadinessCheck = &ContainerProbeSpec{}
			}
			if err := m.ReadinessCheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivenessCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LivenessCheck == nil {
				m.LivenessCheck = &ContainerProbeSpec{}
			}
			if err := m.LivenessCheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Security == nil {
				m.Security = &ContainerSecuritySpec{}
			}
			if err := m.Security.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HookPostStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HookPostStart == nil {
				m.HookPostStart = &ContainerAction{}
			}
			if err := m.HookPostStart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bandwidth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bandwidth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bandwidth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressRate", wireType)
			}
			m.IngressRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngressRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressRate", wireType)
			}
			m.EgressRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EgressRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressBurst", wireType)
			}
			m.IngressBurst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngressBurst |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressBurst", wireType)
			}
			m.EgressBurst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EgressBurst |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerPortSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerPortSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerPortSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPort", wireType)
			}
			m.ContainerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			m.HostPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodNetworkSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodNetworkSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodNetworkSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CidrIpv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CidrIpv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CidrIpv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CidrIpv6 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bandwidth == nil {
				m.Bandwidth = &Bandwidth{}
			}
			if err := m.Bandwidth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameServers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameServers = append(m.NameServers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchDomains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchDomains = append(m.SearchDomains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsOptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsOptions = append(m.DnsOptions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hosts == nil {
				m.Hosts = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Hosts[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ports == nil {
				m.Ports = make(map[string]*ContainerPortSpec)
			}
			var mapkey string
			var mapvalue *ContainerPortSpec
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdPod
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ContainerPortSpec{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ports[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodVolumeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodVolumeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodVolumeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HostPaths == nil {
				m.HostPaths = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HostPaths[mapkey] = mapvalue
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeData == nil {
				m.VolumeData = make(map[string]*NamedData)
			}
			var mapkey string
			var mapvalue *NamedData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdPod
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NamedData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VolumeData[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodSecuritySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodSecuritySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodSecuritySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sysctls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sysctls == nil {
				m.Sysctls = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sysctls[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodEnsureCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodEnsureCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodEnsureCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartPolicy", wireType)
			}
			m.RestartPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestartPolicy |= RestartPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIpc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostIpc = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostNetwork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostNetwork = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostPid = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SharePid = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wait = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, &ContainerSpec{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &PodNetworkSpec{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Volumes == nil {
				m.Volumes = &PodVolumeSpec{}
			}
			if err := m.Volumes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Security == nil {
				m.Security = &PodSecuritySpec{}
			}
			if err := m.Security.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodDeleteCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodDeleteCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodDeleteCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraceTime", wireType)
			}
			m.GraceTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GraceTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HookPreStop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HookPreStop == nil {
				m.HookPreStop = make(map[string]*ContainerAction)
			}
			var mapkey string
			var mapvalue *ContainerAction
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdPod
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ContainerAction{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HookPreStop[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodListCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodListCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodListCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCmdPod(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCmdPod
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCmdPod
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCmdPod
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCmdPod        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCmdPod          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCmdPod = fmt.Errorf("proto: unexpected end of group")
)
