// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cmd_pod.proto

// +build !rt_none

package aranyagopb

import (
	bytes "bytes"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ImagePullPolicy int32

const (
	IMAGE_PULL_ALWAYS         ImagePullPolicy = 0
	IMAGE_PULL_IF_NOT_PRESENT ImagePullPolicy = 1
	IMAGE_PULL_NEVER          ImagePullPolicy = 2
)

var ImagePullPolicy_name = map[int32]string{
	0: "IMAGE_PULL_ALWAYS",
	1: "IMAGE_PULL_IF_NOT_PRESENT",
	2: "IMAGE_PULL_NEVER",
}

var ImagePullPolicy_value = map[string]int32{
	"IMAGE_PULL_ALWAYS":         0,
	"IMAGE_PULL_IF_NOT_PRESENT": 1,
	"IMAGE_PULL_NEVER":          2,
}

func (ImagePullPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{0}
}

type RestartPolicy int32

const (
	RESTART_ALWAYS     RestartPolicy = 0
	RESTART_ON_FAILURE RestartPolicy = 1
	RESTART_NEVER      RestartPolicy = 2
)

var RestartPolicy_name = map[int32]string{
	0: "RESTART_ALWAYS",
	1: "RESTART_ON_FAILURE",
	2: "RESTART_NEVER",
}

var RestartPolicy_value = map[string]int32{
	"RESTART_ALWAYS":     0,
	"RESTART_ON_FAILURE": 1,
	"RESTART_NEVER":      2,
}

func (RestartPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{1}
}

type PodCmd_Action int32

const (
	_INVALID_POD_ACTION PodCmd_Action = 0
	// create init/work/ephemeral containers in pod
	CREATE_CONTAINERS PodCmd_Action = 1
	// Delete a pod in device
	DELETE_POD PodCmd_Action = 2
	// List all managed pod in device
	LIST_PODS PodCmd_Action = 3
	// Ensure all images exist
	ENSURE_IMAGES PodCmd_Action = 4
	// Delete containers
	DELETE_CONTAINERS PodCmd_Action = 6
	// start arhat pod sync loop
	START_POD_SYNC_LOOP PodCmd_Action = 7
)

var PodCmd_Action_name = map[int32]string{
	0: "_INVALID_POD_ACTION",
	1: "CREATE_CONTAINERS",
	2: "DELETE_POD",
	3: "LIST_PODS",
	4: "ENSURE_IMAGES",
	6: "DELETE_CONTAINERS",
	7: "START_POD_SYNC_LOOP",
}

var PodCmd_Action_value = map[string]int32{
	"_INVALID_POD_ACTION": 0,
	"CREATE_CONTAINERS":   1,
	"DELETE_POD":          2,
	"LIST_PODS":           3,
	"ENSURE_IMAGES":       4,
	"DELETE_CONTAINERS":   6,
	"START_POD_SYNC_LOOP": 7,
}

func (PodCmd_Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{0, 0}
}

type SecurityOptions_ProcMountKind int32

const (
	PROC_MOUNT_DEFAULT  SecurityOptions_ProcMountKind = 0
	PROC_MOUNT_UNMASKED SecurityOptions_ProcMountKind = 1
)

var SecurityOptions_ProcMountKind_name = map[int32]string{
	0: "PROC_MOUNT_DEFAULT",
	1: "PROC_MOUNT_UNMASKED",
}

var SecurityOptions_ProcMountKind_value = map[string]int32{
	"PROC_MOUNT_DEFAULT":  0,
	"PROC_MOUNT_UNMASKED": 1,
}

func (SecurityOptions_ProcMountKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{7, 0}
}

type PodCmd struct {
	// action type
	Action PodCmd_Action `protobuf:"varint,1,opt,name=action,proto3,enum=aranya.PodCmd_Action" json:"action,omitempty"`
	// options for action
	//
	// Types that are valid to be assigned to Options:
	//	*PodCmd_SyncOptions
	//	*PodCmd_ImageEnsureOptions
	//	*PodCmd_CreateOptions
	//	*PodCmd_DeleteOptions
	//	*PodCmd_ListOptions
	Options isPodCmd_Options `protobuf_oneof:"options"`
}

func (m *PodCmd) Reset()      { *m = PodCmd{} }
func (*PodCmd) ProtoMessage() {}
func (*PodCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{0}
}
func (m *PodCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodCmd.Merge(m, src)
}
func (m *PodCmd) XXX_Size() int {
	return m.Size()
}
func (m *PodCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_PodCmd.DiscardUnknown(m)
}

var xxx_messageInfo_PodCmd proto.InternalMessageInfo

type isPodCmd_Options interface {
	isPodCmd_Options()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PodCmd_SyncOptions struct {
	SyncOptions *SyncOptions `protobuf:"bytes,2,opt,name=sync_options,json=syncOptions,proto3,oneof" json:"sync_options,omitempty"`
}
type PodCmd_ImageEnsureOptions struct {
	ImageEnsureOptions *ImageEnsureOptions `protobuf:"bytes,3,opt,name=image_ensure_options,json=imageEnsureOptions,proto3,oneof" json:"image_ensure_options,omitempty"`
}
type PodCmd_CreateOptions struct {
	CreateOptions *CreateOptions `protobuf:"bytes,4,opt,name=create_options,json=createOptions,proto3,oneof" json:"create_options,omitempty"`
}
type PodCmd_DeleteOptions struct {
	DeleteOptions *DeleteOptions `protobuf:"bytes,5,opt,name=delete_options,json=deleteOptions,proto3,oneof" json:"delete_options,omitempty"`
}
type PodCmd_ListOptions struct {
	ListOptions *ListOptions `protobuf:"bytes,6,opt,name=list_options,json=listOptions,proto3,oneof" json:"list_options,omitempty"`
}

func (*PodCmd_SyncOptions) isPodCmd_Options()        {}
func (*PodCmd_ImageEnsureOptions) isPodCmd_Options() {}
func (*PodCmd_CreateOptions) isPodCmd_Options()      {}
func (*PodCmd_DeleteOptions) isPodCmd_Options()      {}
func (*PodCmd_ListOptions) isPodCmd_Options()        {}

func (m *PodCmd) GetOptions() isPodCmd_Options {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *PodCmd) GetAction() PodCmd_Action {
	if m != nil {
		return m.Action
	}
	return _INVALID_POD_ACTION
}

func (m *PodCmd) GetSyncOptions() *SyncOptions {
	if x, ok := m.GetOptions().(*PodCmd_SyncOptions); ok {
		return x.SyncOptions
	}
	return nil
}

func (m *PodCmd) GetImageEnsureOptions() *ImageEnsureOptions {
	if x, ok := m.GetOptions().(*PodCmd_ImageEnsureOptions); ok {
		return x.ImageEnsureOptions
	}
	return nil
}

func (m *PodCmd) GetCreateOptions() *CreateOptions {
	if x, ok := m.GetOptions().(*PodCmd_CreateOptions); ok {
		return x.CreateOptions
	}
	return nil
}

func (m *PodCmd) GetDeleteOptions() *DeleteOptions {
	if x, ok := m.GetOptions().(*PodCmd_DeleteOptions); ok {
		return x.DeleteOptions
	}
	return nil
}

func (m *PodCmd) GetListOptions() *ListOptions {
	if x, ok := m.GetOptions().(*PodCmd_ListOptions); ok {
		return x.ListOptions
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PodCmd) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PodCmd_SyncOptions)(nil),
		(*PodCmd_ImageEnsureOptions)(nil),
		(*PodCmd_CreateOptions)(nil),
		(*PodCmd_DeleteOptions)(nil),
		(*PodCmd_ListOptions)(nil),
	}
}

type AuthConfig struct {
	Username      string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password      string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	Auth          string `protobuf:"bytes,3,opt,name=auth,proto3" json:"auth,omitempty"`
	ServerAddress string `protobuf:"bytes,4,opt,name=server_address,json=serverAddress,proto3" json:"server_address,omitempty"`
	// IdentityToken is used to authenticate the user and get
	// an access token for the registry.
	IdentityToken string `protobuf:"bytes,5,opt,name=identity_token,json=identityToken,proto3" json:"identity_token,omitempty"`
	// RegistryToken is a bearer token to be sent to a registry
	RegistryToken string `protobuf:"bytes,6,opt,name=registry_token,json=registryToken,proto3" json:"registry_token,omitempty"`
	Email         string `protobuf:"bytes,7,opt,name=email,proto3" json:"email,omitempty"`
}

func (m *AuthConfig) Reset()      { *m = AuthConfig{} }
func (*AuthConfig) ProtoMessage() {}
func (*AuthConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{1}
}
func (m *AuthConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthConfig.Merge(m, src)
}
func (m *AuthConfig) XXX_Size() int {
	return m.Size()
}
func (m *AuthConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthConfig.DiscardUnknown(m)
}

var xxx_messageInfo_AuthConfig proto.InternalMessageInfo

func (m *AuthConfig) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *AuthConfig) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *AuthConfig) GetAuth() string {
	if m != nil {
		return m.Auth
	}
	return ""
}

func (m *AuthConfig) GetServerAddress() string {
	if m != nil {
		return m.ServerAddress
	}
	return ""
}

func (m *AuthConfig) GetIdentityToken() string {
	if m != nil {
		return m.IdentityToken
	}
	return ""
}

func (m *AuthConfig) GetRegistryToken() string {
	if m != nil {
		return m.RegistryToken
	}
	return ""
}

func (m *AuthConfig) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

type ImagePull struct {
	// image pull secrets
	AuthConfig *AuthConfig `protobuf:"bytes,2,opt,name=auth_config,json=authConfig,proto3" json:"auth_config,omitempty"`
	// pull policy
	PullPolicy ImagePullPolicy `protobuf:"varint,3,opt,name=pull_policy,json=pullPolicy,proto3,enum=aranya.ImagePullPolicy" json:"pull_policy,omitempty"`
}

func (m *ImagePull) Reset()      { *m = ImagePull{} }
func (*ImagePull) ProtoMessage() {}
func (*ImagePull) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{2}
}
func (m *ImagePull) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImagePull) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImagePull.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImagePull) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImagePull.Merge(m, src)
}
func (m *ImagePull) XXX_Size() int {
	return m.Size()
}
func (m *ImagePull) XXX_DiscardUnknown() {
	xxx_messageInfo_ImagePull.DiscardUnknown(m)
}

var xxx_messageInfo_ImagePull proto.InternalMessageInfo

func (m *ImagePull) GetAuthConfig() *AuthConfig {
	if m != nil {
		return m.AuthConfig
	}
	return nil
}

func (m *ImagePull) GetPullPolicy() ImagePullPolicy {
	if m != nil {
		return m.PullPolicy
	}
	return IMAGE_PULL_ALWAYS
}

type ImageEnsureOptions struct {
	ImagePull map[string]*ImagePull `protobuf:"bytes,1,rep,name=image_pull,json=imagePull,proto3" json:"image_pull,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ImageEnsureOptions) Reset()      { *m = ImageEnsureOptions{} }
func (*ImageEnsureOptions) ProtoMessage() {}
func (*ImageEnsureOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{3}
}
func (m *ImageEnsureOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImageEnsureOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImageEnsureOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImageEnsureOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageEnsureOptions.Merge(m, src)
}
func (m *ImageEnsureOptions) XXX_Size() int {
	return m.Size()
}
func (m *ImageEnsureOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageEnsureOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ImageEnsureOptions proto.InternalMessageInfo

func (m *ImageEnsureOptions) GetImagePull() map[string]*ImagePull {
	if m != nil {
		return m.ImagePull
	}
	return nil
}

type NamedData struct {
	DataMap map[string][]byte `protobuf:"bytes,1,rep,name=data_map,json=dataMap,proto3" json:"data_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NamedData) Reset()      { *m = NamedData{} }
func (*NamedData) ProtoMessage() {}
func (*NamedData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{4}
}
func (m *NamedData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamedData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamedData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamedData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamedData.Merge(m, src)
}
func (m *NamedData) XXX_Size() int {
	return m.Size()
}
func (m *NamedData) XXX_DiscardUnknown() {
	xxx_messageInfo_NamedData.DiscardUnknown(m)
}

var xxx_messageInfo_NamedData proto.InternalMessageInfo

func (m *NamedData) GetDataMap() map[string][]byte {
	if m != nil {
		return m.DataMap
	}
	return nil
}

type ContainerPort struct {
	Protocol      string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	ContainerPort int32  `protobuf:"varint,2,opt,name=container_port,json=containerPort,proto3" json:"container_port,omitempty"`
	HostPort      int32  `protobuf:"varint,3,opt,name=host_port,json=hostPort,proto3" json:"host_port,omitempty"`
	HostIp        string `protobuf:"bytes,4,opt,name=host_ip,json=hostIp,proto3" json:"host_ip,omitempty"`
}

func (m *ContainerPort) Reset()      { *m = ContainerPort{} }
func (*ContainerPort) ProtoMessage() {}
func (*ContainerPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{5}
}
func (m *ContainerPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerPort.Merge(m, src)
}
func (m *ContainerPort) XXX_Size() int {
	return m.Size()
}
func (m *ContainerPort) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerPort.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerPort proto.InternalMessageInfo

func (m *ContainerPort) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *ContainerPort) GetContainerPort() int32 {
	if m != nil {
		return m.ContainerPort
	}
	return 0
}

func (m *ContainerPort) GetHostPort() int32 {
	if m != nil {
		return m.HostPort
	}
	return 0
}

func (m *ContainerPort) GetHostIp() string {
	if m != nil {
		return m.HostIp
	}
	return ""
}

type SELinuxOptions struct {
	Type  string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Level string `protobuf:"bytes,2,opt,name=level,proto3" json:"level,omitempty"`
	Role  string `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
	User  string `protobuf:"bytes,4,opt,name=user,proto3" json:"user,omitempty"`
}

func (m *SELinuxOptions) Reset()      { *m = SELinuxOptions{} }
func (*SELinuxOptions) ProtoMessage() {}
func (*SELinuxOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{6}
}
func (m *SELinuxOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SELinuxOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SELinuxOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SELinuxOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SELinuxOptions.Merge(m, src)
}
func (m *SELinuxOptions) XXX_Size() int {
	return m.Size()
}
func (m *SELinuxOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_SELinuxOptions.DiscardUnknown(m)
}

var xxx_messageInfo_SELinuxOptions proto.InternalMessageInfo

func (m *SELinuxOptions) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SELinuxOptions) GetLevel() string {
	if m != nil {
		return m.Level
	}
	return ""
}

func (m *SELinuxOptions) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *SELinuxOptions) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

type SecurityOptions struct {
	Privileged         bool                          `protobuf:"varint,1,opt,name=privileged,proto3" json:"privileged,omitempty"`
	AllowNewPrivileges bool                          `protobuf:"varint,2,opt,name=allow_new_privileges,json=allowNewPrivileges,proto3" json:"allow_new_privileges,omitempty"`
	NonRoot            bool                          `protobuf:"varint,3,opt,name=non_root,json=nonRoot,proto3" json:"non_root,omitempty"`
	ReadOnlyRootfs     bool                          `protobuf:"varint,4,opt,name=read_only_rootfs,json=readOnlyRootfs,proto3" json:"read_only_rootfs,omitempty"`
	User               int64                         `protobuf:"varint,5,opt,name=user,proto3" json:"user,omitempty"`
	Group              int64                         `protobuf:"varint,6,opt,name=group,proto3" json:"group,omitempty"`
	CapsAdd            []string                      `protobuf:"bytes,7,rep,name=caps_add,json=capsAdd,proto3" json:"caps_add,omitempty"`
	CapsDrop           []string                      `protobuf:"bytes,8,rep,name=caps_drop,json=capsDrop,proto3" json:"caps_drop,omitempty"`
	ProcMountKind      SecurityOptions_ProcMountKind `protobuf:"varint,9,opt,name=proc_mount_kind,json=procMountKind,proto3,enum=aranya.SecurityOptions_ProcMountKind" json:"proc_mount_kind,omitempty"`
	SelinuxOptions     *SELinuxOptions               `protobuf:"bytes,10,opt,name=selinux_options,json=selinuxOptions,proto3" json:"selinux_options,omitempty"`
}

func (m *SecurityOptions) Reset()      { *m = SecurityOptions{} }
func (*SecurityOptions) ProtoMessage() {}
func (*SecurityOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{7}
}
func (m *SecurityOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityOptions.Merge(m, src)
}
func (m *SecurityOptions) XXX_Size() int {
	return m.Size()
}
func (m *SecurityOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityOptions.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityOptions proto.InternalMessageInfo

func (m *SecurityOptions) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

func (m *SecurityOptions) GetAllowNewPrivileges() bool {
	if m != nil {
		return m.AllowNewPrivileges
	}
	return false
}

func (m *SecurityOptions) GetNonRoot() bool {
	if m != nil {
		return m.NonRoot
	}
	return false
}

func (m *SecurityOptions) GetReadOnlyRootfs() bool {
	if m != nil {
		return m.ReadOnlyRootfs
	}
	return false
}

func (m *SecurityOptions) GetUser() int64 {
	if m != nil {
		return m.User
	}
	return 0
}

func (m *SecurityOptions) GetGroup() int64 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *SecurityOptions) GetCapsAdd() []string {
	if m != nil {
		return m.CapsAdd
	}
	return nil
}

func (m *SecurityOptions) GetCapsDrop() []string {
	if m != nil {
		return m.CapsDrop
	}
	return nil
}

func (m *SecurityOptions) GetProcMountKind() SecurityOptions_ProcMountKind {
	if m != nil {
		return m.ProcMountKind
	}
	return PROC_MOUNT_DEFAULT
}

func (m *SecurityOptions) GetSelinuxOptions() *SELinuxOptions {
	if m != nil {
		return m.SelinuxOptions
	}
	return nil
}

type MountOptions struct {
	MountPath string `protobuf:"bytes,1,opt,name=mount_path,json=mountPath,proto3" json:"mount_path,omitempty"`
	SubPath   string `protobuf:"bytes,2,opt,name=sub_path,json=subPath,proto3" json:"sub_path,omitempty"`
	ReadOnly  bool   `protobuf:"varint,3,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	// device type
	Type     string   `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	Options  []string `protobuf:"bytes,5,rep,name=options,proto3" json:"options,omitempty"`
	FileMode uint32   `protobuf:"varint,6,opt,name=file_mode,json=fileMode,proto3" json:"file_mode,omitempty"`
	// mount this volume use cluster CSI
	Remote bool `protobuf:"varint,7,opt,name=remote,proto3" json:"remote,omitempty"`
}

func (m *MountOptions) Reset()      { *m = MountOptions{} }
func (*MountOptions) ProtoMessage() {}
func (*MountOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{8}
}
func (m *MountOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MountOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MountOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MountOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MountOptions.Merge(m, src)
}
func (m *MountOptions) XXX_Size() int {
	return m.Size()
}
func (m *MountOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_MountOptions.DiscardUnknown(m)
}

var xxx_messageInfo_MountOptions proto.InternalMessageInfo

func (m *MountOptions) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

func (m *MountOptions) GetSubPath() string {
	if m != nil {
		return m.SubPath
	}
	return ""
}

func (m *MountOptions) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *MountOptions) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MountOptions) GetOptions() []string {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *MountOptions) GetFileMode() uint32 {
	if m != nil {
		return m.FileMode
	}
	return 0
}

func (m *MountOptions) GetRemote() bool {
	if m != nil {
		return m.Remote
	}
	return false
}

type ActionMethod struct {
	// Types that are valid to be assigned to Action:
	//	*ActionMethod_Exec
	//	*ActionMethod_Http
	//	*ActionMethod_Socket
	Action isActionMethod_Action `protobuf_oneof:"action"`
}

func (m *ActionMethod) Reset()      { *m = ActionMethod{} }
func (*ActionMethod) ProtoMessage() {}
func (*ActionMethod) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{9}
}
func (m *ActionMethod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionMethod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionMethod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionMethod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionMethod.Merge(m, src)
}
func (m *ActionMethod) XXX_Size() int {
	return m.Size()
}
func (m *ActionMethod) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionMethod.DiscardUnknown(m)
}

var xxx_messageInfo_ActionMethod proto.InternalMessageInfo

type isActionMethod_Action interface {
	isActionMethod_Action()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ActionMethod_Exec struct {
	Exec *ActionMethod_ActionExec `protobuf:"bytes,1,opt,name=exec,proto3,oneof" json:"exec,omitempty"`
}
type ActionMethod_Http struct {
	Http *ActionMethod_ActionHTTP `protobuf:"bytes,2,opt,name=http,proto3,oneof" json:"http,omitempty"`
}
type ActionMethod_Socket struct {
	Socket *ActionMethod_ActionSocket `protobuf:"bytes,3,opt,name=socket,proto3,oneof" json:"socket,omitempty"`
}

func (*ActionMethod_Exec) isActionMethod_Action()   {}
func (*ActionMethod_Http) isActionMethod_Action()   {}
func (*ActionMethod_Socket) isActionMethod_Action() {}

func (m *ActionMethod) GetAction() isActionMethod_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *ActionMethod) GetExec() *ActionMethod_ActionExec {
	if x, ok := m.GetAction().(*ActionMethod_Exec); ok {
		return x.Exec
	}
	return nil
}

func (m *ActionMethod) GetHttp() *ActionMethod_ActionHTTP {
	if x, ok := m.GetAction().(*ActionMethod_Http); ok {
		return x.Http
	}
	return nil
}

func (m *ActionMethod) GetSocket() *ActionMethod_ActionSocket {
	if x, ok := m.GetAction().(*ActionMethod_Socket); ok {
		return x.Socket
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ActionMethod) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ActionMethod_Exec)(nil),
		(*ActionMethod_Http)(nil),
		(*ActionMethod_Socket)(nil),
	}
}

type ActionMethod_ActionExec struct {
	Command []string `protobuf:"bytes,1,rep,name=command,proto3" json:"command,omitempty"`
}

func (m *ActionMethod_ActionExec) Reset()      { *m = ActionMethod_ActionExec{} }
func (*ActionMethod_ActionExec) ProtoMessage() {}
func (*ActionMethod_ActionExec) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{9, 0}
}
func (m *ActionMethod_ActionExec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionMethod_ActionExec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionMethod_ActionExec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionMethod_ActionExec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionMethod_ActionExec.Merge(m, src)
}
func (m *ActionMethod_ActionExec) XXX_Size() int {
	return m.Size()
}
func (m *ActionMethod_ActionExec) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionMethod_ActionExec.DiscardUnknown(m)
}

var xxx_messageInfo_ActionMethod_ActionExec proto.InternalMessageInfo

func (m *ActionMethod_ActionExec) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

type ActionMethod_ActionHTTP struct {
	Method  string          `protobuf:"bytes,1,opt,name=method,proto3" json:"method,omitempty"`
	Url     string          `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	Headers []*KeyValuePair `protobuf:"bytes,3,rep,name=headers,proto3" json:"headers,omitempty"`
}

func (m *ActionMethod_ActionHTTP) Reset()      { *m = ActionMethod_ActionHTTP{} }
func (*ActionMethod_ActionHTTP) ProtoMessage() {}
func (*ActionMethod_ActionHTTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{9, 1}
}
func (m *ActionMethod_ActionHTTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionMethod_ActionHTTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionMethod_ActionHTTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionMethod_ActionHTTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionMethod_ActionHTTP.Merge(m, src)
}
func (m *ActionMethod_ActionHTTP) XXX_Size() int {
	return m.Size()
}
func (m *ActionMethod_ActionHTTP) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionMethod_ActionHTTP.DiscardUnknown(m)
}

var xxx_messageInfo_ActionMethod_ActionHTTP proto.InternalMessageInfo

func (m *ActionMethod_ActionHTTP) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *ActionMethod_ActionHTTP) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ActionMethod_ActionHTTP) GetHeaders() []*KeyValuePair {
	if m != nil {
		return m.Headers
	}
	return nil
}

type ActionMethod_ActionSocket struct {
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *ActionMethod_ActionSocket) Reset()      { *m = ActionMethod_ActionSocket{} }
func (*ActionMethod_ActionSocket) ProtoMessage() {}
func (*ActionMethod_ActionSocket) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{9, 2}
}
func (m *ActionMethod_ActionSocket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionMethod_ActionSocket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionMethod_ActionSocket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionMethod_ActionSocket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionMethod_ActionSocket.Merge(m, src)
}
func (m *ActionMethod_ActionSocket) XXX_Size() int {
	return m.Size()
}
func (m *ActionMethod_ActionSocket) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionMethod_ActionSocket.DiscardUnknown(m)
}

var xxx_messageInfo_ActionMethod_ActionSocket proto.InternalMessageInfo

func (m *ActionMethod_ActionSocket) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type Probe struct {
	Method           *ActionMethod `protobuf:"bytes,1,opt,name=method,proto3" json:"method,omitempty"`
	InitialDelay     int64         `protobuf:"varint,2,opt,name=initial_delay,json=initialDelay,proto3" json:"initial_delay,omitempty"`
	ProbeTimeout     int64         `protobuf:"varint,3,opt,name=probe_timeout,json=probeTimeout,proto3" json:"probe_timeout,omitempty"`
	ProbeInterval    int64         `protobuf:"varint,4,opt,name=probe_interval,json=probeInterval,proto3" json:"probe_interval,omitempty"`
	SuccessThreshold int32         `protobuf:"varint,5,opt,name=success_threshold,json=successThreshold,proto3" json:"success_threshold,omitempty"`
	FailureThreshold int32         `protobuf:"varint,6,opt,name=failure_threshold,json=failureThreshold,proto3" json:"failure_threshold,omitempty"`
}

func (m *Probe) Reset()      { *m = Probe{} }
func (*Probe) ProtoMessage() {}
func (*Probe) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{10}
}
func (m *Probe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Probe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Probe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Probe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Probe.Merge(m, src)
}
func (m *Probe) XXX_Size() int {
	return m.Size()
}
func (m *Probe) XXX_DiscardUnknown() {
	xxx_messageInfo_Probe.DiscardUnknown(m)
}

var xxx_messageInfo_Probe proto.InternalMessageInfo

func (m *Probe) GetMethod() *ActionMethod {
	if m != nil {
		return m.Method
	}
	return nil
}

func (m *Probe) GetInitialDelay() int64 {
	if m != nil {
		return m.InitialDelay
	}
	return 0
}

func (m *Probe) GetProbeTimeout() int64 {
	if m != nil {
		return m.ProbeTimeout
	}
	return 0
}

func (m *Probe) GetProbeInterval() int64 {
	if m != nil {
		return m.ProbeInterval
	}
	return 0
}

func (m *Probe) GetSuccessThreshold() int32 {
	if m != nil {
		return m.SuccessThreshold
	}
	return 0
}

func (m *Probe) GetFailureThreshold() int32 {
	if m != nil {
		return m.FailureThreshold
	}
	return 0
}

type ContainerSpec struct {
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// container image name to pull
	Image string `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	// Command (ENTRYPOINT in Dockerfile)
	Command []string `protobuf:"bytes,3,rep,name=command,proto3" json:"command,omitempty"`
	// Args (CMD in Dockerfile)
	Args       []string `protobuf:"bytes,4,rep,name=args,proto3" json:"args,omitempty"`
	WorkingDir string   `protobuf:"bytes,5,opt,name=working_dir,json=workingDir,proto3" json:"working_dir,omitempty"`
	Stdin      bool     `protobuf:"varint,6,opt,name=stdin,proto3" json:"stdin,omitempty"`
	StdinOnce  bool     `protobuf:"varint,7,opt,name=stdin_once,json=stdinOnce,proto3" json:"stdin_once,omitempty"`
	Tty        bool     `protobuf:"varint,8,opt,name=tty,proto3" json:"tty,omitempty"`
	// Contaienr environment variables
	//
	// key: env key
	// value: env value
	Envs map[string]string `protobuf:"bytes,11,rep,name=envs,proto3" json:"envs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Container voulme or device mounts
	//
	// key: volume or device name
	// value: mount options
	Mounts         map[string]*MountOptions `protobuf:"bytes,12,rep,name=mounts,proto3" json:"mounts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ReadinessCheck *Probe                   `protobuf:"bytes,13,opt,name=readiness_check,json=readinessCheck,proto3" json:"readiness_check,omitempty"`
	LivenessCheck  *Probe                   `protobuf:"bytes,14,opt,name=liveness_check,json=livenessCheck,proto3" json:"liveness_check,omitempty"`
	//
	// resolved security opts in pod
	//
	Security *SecurityOptions `protobuf:"bytes,21,opt,name=security,proto3" json:"security,omitempty"`
	//
	// Container hooks
	//
	HookPostStart *ActionMethod `protobuf:"bytes,31,opt,name=hook_post_start,json=hookPostStart,proto3" json:"hook_post_start,omitempty"`
}

func (m *ContainerSpec) Reset()      { *m = ContainerSpec{} }
func (*ContainerSpec) ProtoMessage() {}
func (*ContainerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{11}
}
func (m *ContainerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerSpec.Merge(m, src)
}
func (m *ContainerSpec) XXX_Size() int {
	return m.Size()
}
func (m *ContainerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerSpec proto.InternalMessageInfo

func (m *ContainerSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ContainerSpec) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ContainerSpec) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ContainerSpec) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *ContainerSpec) GetWorkingDir() string {
	if m != nil {
		return m.WorkingDir
	}
	return ""
}

func (m *ContainerSpec) GetStdin() bool {
	if m != nil {
		return m.Stdin
	}
	return false
}

func (m *ContainerSpec) GetStdinOnce() bool {
	if m != nil {
		return m.StdinOnce
	}
	return false
}

func (m *ContainerSpec) GetTty() bool {
	if m != nil {
		return m.Tty
	}
	return false
}

func (m *ContainerSpec) GetEnvs() map[string]string {
	if m != nil {
		return m.Envs
	}
	return nil
}

func (m *ContainerSpec) GetMounts() map[string]*MountOptions {
	if m != nil {
		return m.Mounts
	}
	return nil
}

func (m *ContainerSpec) GetReadinessCheck() *Probe {
	if m != nil {
		return m.ReadinessCheck
	}
	return nil
}

func (m *ContainerSpec) GetLivenessCheck() *Probe {
	if m != nil {
		return m.LivenessCheck
	}
	return nil
}

func (m *ContainerSpec) GetSecurity() *SecurityOptions {
	if m != nil {
		return m.Security
	}
	return nil
}

func (m *ContainerSpec) GetHookPostStart() *ActionMethod {
	if m != nil {
		return m.HookPostStart
	}
	return nil
}

type CreateOptions struct {
	// kubernetes metadata
	PodUid        string        `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	Namespace     string        `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Name          string        `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	RestartPolicy RestartPolicy `protobuf:"varint,4,opt,name=restart_policy,json=restartPolicy,proto3,enum=aranya.RestartPolicy" json:"restart_policy,omitempty"`
	//
	// Relationships to host namespaces
	//
	HostIpc     bool `protobuf:"varint,5,opt,name=host_ipc,json=hostIpc,proto3" json:"host_ipc,omitempty"`
	HostNetwork bool `protobuf:"varint,6,opt,name=host_network,json=hostNetwork,proto3" json:"host_network,omitempty"`
	HostPid     bool `protobuf:"varint,7,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty"`
	// custom hostname to override container id as hostname
	Hostname string `protobuf:"bytes,8,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// share pid namespace between containers in the same pod
	SharePid   bool             `protobuf:"varint,9,opt,name=share_pid,json=sharePid,proto3" json:"share_pid,omitempty"`
	Containers []*ContainerSpec `protobuf:"bytes,11,rep,name=containers,proto3" json:"containers,omitempty"`
	// wait unitl all containers defined above exited with no error
	WaitContainers bool `protobuf:"varint,12,opt,name=wait_containers,json=waitContainers,proto3" json:"wait_containers,omitempty"`
	// Container ports is processed when creating the pause container
	//
	// key: port name
	//          the port name is in the format of `{container}/{port_name}`
	//          if the port name is missing in the corev1.Container,
	//          it's index number in the containers list will be used as {port_name}
	// value: port map and spec
	//          currently only ports with `host_port` specified will be exposed
	Ports map[string]*ContainerPort `protobuf:"bytes,13,rep,name=ports,proto3" json:"ports,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	//
	// Network options
	//
	NameServers   []string `protobuf:"bytes,14,rep,name=name_servers,json=nameServers,proto3" json:"name_servers,omitempty"`
	SearchDomains []string `protobuf:"bytes,15,rep,name=search_domains,json=searchDomains,proto3" json:"search_domains,omitempty"`
	// /etc/hosts entries
	//
	// key: hostname
	// value: ip
	Hosts          map[string]string `protobuf:"bytes,16,rep,name=hosts,proto3" json:"hosts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DnsOptions     []string          `protobuf:"bytes,17,rep,name=dns_options,json=dnsOptions,proto3" json:"dns_options,omitempty"`
	NetworkOptions *NetworkOptions   `protobuf:"bytes,18,opt,name=network_options,json=networkOptions,proto3" json:"network_options,omitempty"`
	// Volumes and devices' host path
	//
	// key: volume or device name
	// value: host path
	HostPaths map[string]string `protobuf:"bytes,21,rep,name=host_paths,json=hostPaths,proto3" json:"host_paths,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Data to populate files in container
	//
	// key: volume name
	// value: data from {ConfigMap, Secret}
	VolumeData map[string]*NamedData `protobuf:"bytes,22,rep,name=volume_data,json=volumeData,proto3" json:"volume_data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Labels     map[string]string     `protobuf:"bytes,23,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// whether we should consider the pod failed if container creation failed
	DeletePodOnFailure bool `protobuf:"varint,24,opt,name=delete_pod_on_failure,json=deletePodOnFailure,proto3" json:"delete_pod_on_failure,omitempty"`
	// Security options
	Sysctls map[string]string `protobuf:"bytes,31,rep,name=sysctls,proto3" json:"sysctls,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CreateOptions) Reset()      { *m = CreateOptions{} }
func (*CreateOptions) ProtoMessage() {}
func (*CreateOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{12}
}
func (m *CreateOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateOptions.Merge(m, src)
}
func (m *CreateOptions) XXX_Size() int {
	return m.Size()
}
func (m *CreateOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateOptions.DiscardUnknown(m)
}

var xxx_messageInfo_CreateOptions proto.InternalMessageInfo

func (m *CreateOptions) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *CreateOptions) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *CreateOptions) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateOptions) GetRestartPolicy() RestartPolicy {
	if m != nil {
		return m.RestartPolicy
	}
	return RESTART_ALWAYS
}

func (m *CreateOptions) GetHostIpc() bool {
	if m != nil {
		return m.HostIpc
	}
	return false
}

func (m *CreateOptions) GetHostNetwork() bool {
	if m != nil {
		return m.HostNetwork
	}
	return false
}

func (m *CreateOptions) GetHostPid() bool {
	if m != nil {
		return m.HostPid
	}
	return false
}

func (m *CreateOptions) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *CreateOptions) GetSharePid() bool {
	if m != nil {
		return m.SharePid
	}
	return false
}

func (m *CreateOptions) GetContainers() []*ContainerSpec {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *CreateOptions) GetWaitContainers() bool {
	if m != nil {
		return m.WaitContainers
	}
	return false
}

func (m *CreateOptions) GetPorts() map[string]*ContainerPort {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *CreateOptions) GetNameServers() []string {
	if m != nil {
		return m.NameServers
	}
	return nil
}

func (m *CreateOptions) GetSearchDomains() []string {
	if m != nil {
		return m.SearchDomains
	}
	return nil
}

func (m *CreateOptions) GetHosts() map[string]string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *CreateOptions) GetDnsOptions() []string {
	if m != nil {
		return m.DnsOptions
	}
	return nil
}

func (m *CreateOptions) GetNetworkOptions() *NetworkOptions {
	if m != nil {
		return m.NetworkOptions
	}
	return nil
}

func (m *CreateOptions) GetHostPaths() map[string]string {
	if m != nil {
		return m.HostPaths
	}
	return nil
}

func (m *CreateOptions) GetVolumeData() map[string]*NamedData {
	if m != nil {
		return m.VolumeData
	}
	return nil
}

func (m *CreateOptions) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *CreateOptions) GetDeletePodOnFailure() bool {
	if m != nil {
		return m.DeletePodOnFailure
	}
	return false
}

func (m *CreateOptions) GetSysctls() map[string]string {
	if m != nil {
		return m.Sysctls
	}
	return nil
}

type DeleteOptions struct {
	// pod to perform delete operation
	PodUid string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	// containers to delete, if not specified, delete this pod
	Containers []string `protobuf:"bytes,2,rep,name=containers,proto3" json:"containers,omitempty"`
	// pod deletion grace time
	GraceTime   int64                    `protobuf:"varint,10,opt,name=grace_time,json=graceTime,proto3" json:"grace_time,omitempty"`
	HookPreStop map[string]*ActionMethod `protobuf:"bytes,11,rep,name=hook_pre_stop,json=hookPreStop,proto3" json:"hook_pre_stop,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *DeleteOptions) Reset()      { *m = DeleteOptions{} }
func (*DeleteOptions) ProtoMessage() {}
func (*DeleteOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{13}
}
func (m *DeleteOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteOptions.Merge(m, src)
}
func (m *DeleteOptions) XXX_Size() int {
	return m.Size()
}
func (m *DeleteOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteOptions.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteOptions proto.InternalMessageInfo

func (m *DeleteOptions) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *DeleteOptions) GetContainers() []string {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *DeleteOptions) GetGraceTime() int64 {
	if m != nil {
		return m.GraceTime
	}
	return 0
}

func (m *DeleteOptions) GetHookPreStop() map[string]*ActionMethod {
	if m != nil {
		return m.HookPreStop
	}
	return nil
}

type ListOptions struct {
	// pod namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// pod name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// show all pods available
	All bool `protobuf:"varint,3,opt,name=all,proto3" json:"all,omitempty"`
}

func (m *ListOptions) Reset()      { *m = ListOptions{} }
func (*ListOptions) ProtoMessage() {}
func (*ListOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca6bb171ccf381e, []int{14}
}
func (m *ListOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListOptions.Merge(m, src)
}
func (m *ListOptions) XXX_Size() int {
	return m.Size()
}
func (m *ListOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ListOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ListOptions proto.InternalMessageInfo

func (m *ListOptions) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ListOptions) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListOptions) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func init() {
	proto.RegisterEnum("aranya.ImagePullPolicy", ImagePullPolicy_name, ImagePullPolicy_value)
	proto.RegisterEnum("aranya.RestartPolicy", RestartPolicy_name, RestartPolicy_value)
	proto.RegisterEnum("aranya.PodCmd_Action", PodCmd_Action_name, PodCmd_Action_value)
	proto.RegisterEnum("aranya.SecurityOptions_ProcMountKind", SecurityOptions_ProcMountKind_name, SecurityOptions_ProcMountKind_value)
	proto.RegisterType((*PodCmd)(nil), "aranya.PodCmd")
	proto.RegisterType((*AuthConfig)(nil), "aranya.AuthConfig")
	proto.RegisterType((*ImagePull)(nil), "aranya.ImagePull")
	proto.RegisterType((*ImageEnsureOptions)(nil), "aranya.ImageEnsureOptions")
	proto.RegisterMapType((map[string]*ImagePull)(nil), "aranya.ImageEnsureOptions.ImagePullEntry")
	proto.RegisterType((*NamedData)(nil), "aranya.NamedData")
	proto.RegisterMapType((map[string][]byte)(nil), "aranya.NamedData.DataMapEntry")
	proto.RegisterType((*ContainerPort)(nil), "aranya.ContainerPort")
	proto.RegisterType((*SELinuxOptions)(nil), "aranya.SELinuxOptions")
	proto.RegisterType((*SecurityOptions)(nil), "aranya.SecurityOptions")
	proto.RegisterType((*MountOptions)(nil), "aranya.MountOptions")
	proto.RegisterType((*ActionMethod)(nil), "aranya.ActionMethod")
	proto.RegisterType((*ActionMethod_ActionExec)(nil), "aranya.ActionMethod.ActionExec")
	proto.RegisterType((*ActionMethod_ActionHTTP)(nil), "aranya.ActionMethod.ActionHTTP")
	proto.RegisterType((*ActionMethod_ActionSocket)(nil), "aranya.ActionMethod.ActionSocket")
	proto.RegisterType((*Probe)(nil), "aranya.Probe")
	proto.RegisterType((*ContainerSpec)(nil), "aranya.ContainerSpec")
	proto.RegisterMapType((map[string]string)(nil), "aranya.ContainerSpec.EnvsEntry")
	proto.RegisterMapType((map[string]*MountOptions)(nil), "aranya.ContainerSpec.MountsEntry")
	proto.RegisterType((*CreateOptions)(nil), "aranya.CreateOptions")
	proto.RegisterMapType((map[string]string)(nil), "aranya.CreateOptions.HostPathsEntry")
	proto.RegisterMapType((map[string]string)(nil), "aranya.CreateOptions.HostsEntry")
	proto.RegisterMapType((map[string]string)(nil), "aranya.CreateOptions.LabelsEntry")
	proto.RegisterMapType((map[string]*ContainerPort)(nil), "aranya.CreateOptions.PortsEntry")
	proto.RegisterMapType((map[string]string)(nil), "aranya.CreateOptions.SysctlsEntry")
	proto.RegisterMapType((map[string]*NamedData)(nil), "aranya.CreateOptions.VolumeDataEntry")
	proto.RegisterType((*DeleteOptions)(nil), "aranya.DeleteOptions")
	proto.RegisterMapType((map[string]*ActionMethod)(nil), "aranya.DeleteOptions.HookPreStopEntry")
	proto.RegisterType((*ListOptions)(nil), "aranya.ListOptions")
}

func init() { proto.RegisterFile("cmd_pod.proto", fileDescriptor_7ca6bb171ccf381e) }

var fileDescriptor_7ca6bb171ccf381e = []byte{
	// 2377 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x58, 0xcf, 0x73, 0xdb, 0xc6,
	0x15, 0x26, 0x44, 0x89, 0x3f, 0x1e, 0x05, 0x8a, 0xda, 0x48, 0x36, 0xc2, 0x34, 0xb4, 0xcc, 0x36,
	0x89, 0x9b, 0x34, 0x6a, 0x6b, 0x37, 0xa9, 0xe3, 0x7a, 0x9a, 0xd2, 0x14, 0x5d, 0x29, 0xa6, 0x48,
	0x16, 0xa4, 0x9c, 0x49, 0x67, 0x3a, 0x18, 0x08, 0x58, 0x8b, 0x18, 0x81, 0x58, 0x0c, 0xb0, 0x94,
	0xcc, 0x9e, 0x32, 0x3d, 0xb5, 0xb7, 0x9e, 0x7b, 0xed, 0xa5, 0xd3, 0x4b, 0xff, 0x8d, 0x1c, 0x7d,
	0xcc, 0xa1, 0x87, 0x5a, 0xbe, 0xf4, 0x98, 0x4b, 0xa7, 0xd7, 0xce, 0xdb, 0x5d, 0x80, 0x80, 0x2d,
	0xbb, 0xa3, 0x0b, 0x07, 0xef, 0x7b, 0xdf, 0x7b, 0x78, 0xd8, 0xf7, 0xf6, 0xed, 0x5b, 0x82, 0xee,
	0xcc, 0x5c, 0x2b, 0x64, 0xee, 0x6e, 0x18, 0x31, 0xce, 0x48, 0xc9, 0x8e, 0xec, 0x60, 0x61, 0x37,
	0xeb, 0x08, 0xcf, 0xbc, 0xd8, 0x91, 0x78, 0x73, 0x13, 0xe5, 0x80, 0xf2, 0x73, 0x16, 0x9d, 0x4a,
	0xa8, 0xfd, 0xd7, 0x55, 0x28, 0x8d, 0x98, 0xdb, 0x9d, 0xb9, 0xe4, 0x63, 0x28, 0xd9, 0x0e, 0xf7,
	0x58, 0x60, 0x68, 0x3b, 0xda, 0xad, 0xfa, 0xed, 0xed, 0x5d, 0xe9, 0x66, 0x57, 0xea, 0x77, 0x3b,
	0x42, 0x69, 0x2a, 0x12, 0xb9, 0x0b, 0xeb, 0xf1, 0x22, 0x70, 0x2c, 0x16, 0xa2, 0x18, 0x1b, 0x2b,
	0x3b, 0xda, 0xad, 0xda, 0xed, 0xb7, 0x12, 0xa3, 0xf1, 0x22, 0x70, 0x86, 0x52, 0xb5, 0x5f, 0x30,
	0x6b, 0xf1, 0x52, 0x24, 0x03, 0xd8, 0xf2, 0x66, 0xf6, 0x09, 0xb5, 0x68, 0x10, 0xcf, 0x23, 0x9a,
	0x7a, 0x28, 0x0a, 0x0f, 0xcd, 0xc4, 0xc3, 0x01, 0x72, 0x7a, 0x82, 0xb2, 0x74, 0x44, 0xbc, 0x57,
	0x50, 0xf2, 0x4b, 0xa8, 0x3b, 0x11, 0xb5, 0xf9, 0xd2, 0xd3, 0xaa, 0xf0, 0x94, 0x7e, 0x40, 0x57,
	0x68, 0x97, 0x4e, 0x74, 0x27, 0x0b, 0xa0, 0xbd, 0x4b, 0x7d, 0x9a, 0xb1, 0x5f, 0xcb, 0xdb, 0xef,
	0x09, 0x6d, 0xc6, 0xde, 0xcd, 0x02, 0xb8, 0x12, 0xbe, 0x17, 0xf3, 0xd4, 0xba, 0x94, 0x5f, 0x89,
	0xbe, 0x17, 0xf3, 0xcc, 0x4a, 0xf8, 0x4b, 0xb1, 0xfd, 0x17, 0x0d, 0x4a, 0x72, 0x59, 0xc9, 0x75,
	0x78, 0xcb, 0x3a, 0x18, 0x3c, 0xee, 0xf4, 0x0f, 0xf6, 0xac, 0xd1, 0x70, 0xcf, 0xea, 0x74, 0x27,
	0x07, 0xc3, 0x41, 0xa3, 0x40, 0xb6, 0x61, 0xb3, 0x6b, 0xf6, 0x3a, 0x93, 0x9e, 0xd5, 0x1d, 0x0e,
	0x26, 0x9d, 0x83, 0x41, 0xcf, 0x1c, 0x37, 0x34, 0x52, 0x07, 0xd8, 0xeb, 0xf5, 0x7b, 0x93, 0x1e,
	0xb2, 0x1b, 0x2b, 0x44, 0x87, 0x6a, 0xff, 0x60, 0x3c, 0x41, 0x69, 0xdc, 0x28, 0x92, 0x4d, 0xd0,
	0x7b, 0x83, 0xf1, 0x91, 0xd9, 0xb3, 0x0e, 0x0e, 0x3b, 0xbf, 0xee, 0x8d, 0x1b, 0xab, 0xe8, 0x48,
	0x59, 0x64, 0x1c, 0x95, 0xf0, 0xc5, 0xe3, 0x49, 0xc7, 0x14, 0x96, 0xd6, 0xf8, 0xab, 0x41, 0xd7,
	0xea, 0x0f, 0x87, 0xa3, 0x46, 0xf9, 0x41, 0x15, 0xca, 0xea, 0x8b, 0xda, 0x2f, 0x34, 0x80, 0xce,
	0x9c, 0x4f, 0xbb, 0x2c, 0x78, 0xe2, 0x9d, 0x90, 0x26, 0x54, 0xe6, 0x31, 0x8d, 0x02, 0x7b, 0x46,
	0x45, 0xad, 0x54, 0xcd, 0x54, 0x46, 0x5d, 0x68, 0xc7, 0xf1, 0x39, 0x8b, 0x5c, 0x51, 0x12, 0x55,
	0x33, 0x95, 0x09, 0x81, 0x55, 0x7b, 0xce, 0xa7, 0x22, 0xd1, 0x55, 0x53, 0x3c, 0x93, 0xf7, 0xa0,
	0x1e, 0xd3, 0xe8, 0x8c, 0x46, 0x96, 0xed, 0xba, 0x11, 0x8d, 0x65, 0xf2, 0xaa, 0xa6, 0x2e, 0xd1,
	0x8e, 0x04, 0x91, 0xe6, 0xb9, 0x34, 0xe0, 0x1e, 0x5f, 0x58, 0x9c, 0x9d, 0xd2, 0x40, 0xe4, 0xa8,
	0x6a, 0xea, 0x09, 0x3a, 0x41, 0x10, 0x69, 0x11, 0x3d, 0xf1, 0x62, 0x1e, 0x25, 0xb4, 0x92, 0xa4,
	0x25, 0xa8, 0xa4, 0x6d, 0xc1, 0x1a, 0x9d, 0xd9, 0x9e, 0x6f, 0x94, 0x85, 0x56, 0x0a, 0xed, 0xdf,
	0x43, 0x55, 0xd4, 0xdc, 0x68, 0xee, 0xfb, 0xe4, 0x0e, 0xd4, 0x30, 0x3e, 0xcb, 0x11, 0x9f, 0xac,
	0xaa, 0x9b, 0x24, 0x39, 0x5d, 0x2e, 0x86, 0x09, 0xf6, 0x72, 0x61, 0xee, 0x42, 0x2d, 0x9c, 0xfb,
	0xbe, 0x15, 0x32, 0xdf, 0x73, 0x16, 0xe2, 0x3b, 0xeb, 0xb7, 0xaf, 0xe7, 0x0a, 0x1a, 0x9d, 0x8f,
	0x84, 0xda, 0x84, 0x30, 0x7d, 0x6e, 0xff, 0x43, 0x03, 0xf2, 0x6a, 0xc1, 0x93, 0x7d, 0x00, 0xb9,
	0x55, 0x90, 0x6a, 0x68, 0x3b, 0xc5, 0x5b, 0xb5, 0xdb, 0x3f, 0x7c, 0xfd, 0x06, 0x59, 0xbe, 0xa2,
	0x17, 0xf0, 0x68, 0x61, 0x56, 0xbd, 0x44, 0x6e, 0x0e, 0xa1, 0x9e, 0x57, 0x92, 0x06, 0x14, 0x4f,
	0xe9, 0x42, 0x25, 0x10, 0x1f, 0xc9, 0x07, 0xb0, 0x76, 0x66, 0xfb, 0x73, 0xaa, 0xbe, 0x76, 0xf3,
	0x95, 0xc0, 0x4d, 0xa9, 0xbf, 0xb7, 0x72, 0x57, 0x6b, 0xff, 0x41, 0x83, 0xea, 0xc0, 0x9e, 0x51,
	0x77, 0xcf, 0xe6, 0x36, 0xf9, 0x0c, 0x2a, 0xae, 0xcd, 0x6d, 0x6b, 0x66, 0x87, 0x2a, 0xcc, 0x56,
	0x62, 0x9d, 0x92, 0x76, 0xf1, 0xe7, 0xd0, 0x0e, 0x65, 0x6c, 0x65, 0x57, 0x4a, 0xcd, 0x7b, 0xb0,
	0x9e, 0x55, 0x5c, 0x12, 0xd7, 0x56, 0x36, 0xae, 0xf5, 0x6c, 0x10, 0x7f, 0xd4, 0x40, 0xef, 0xb2,
	0x80, 0xdb, 0x5e, 0x40, 0xa3, 0x11, 0x8b, 0xb8, 0xa8, 0x3f, 0xec, 0x6c, 0x0e, 0xf3, 0x93, 0xda,
	0x4c, 0x64, 0xac, 0x0e, 0x27, 0x21, 0x5b, 0x21, 0x8b, 0xb8, 0x70, 0xb8, 0x66, 0xea, 0x4e, 0xce,
	0xc5, 0x3b, 0x50, 0x9d, 0xb2, 0x98, 0x4b, 0x46, 0x51, 0x30, 0x2a, 0x08, 0x08, 0xe5, 0x75, 0x28,
	0x0b, 0xa5, 0x17, 0xaa, 0x42, 0x2d, 0xa1, 0x78, 0x10, 0xb6, 0x8f, 0xa1, 0x3e, 0xee, 0xf5, 0xbd,
	0x60, 0xfe, 0x34, 0x49, 0x1e, 0x81, 0x55, 0xbe, 0x08, 0x93, 0x2d, 0x22, 0x9e, 0xf1, 0x53, 0x7c,
	0x7a, 0x46, 0x7d, 0xb5, 0x37, 0xa4, 0x80, 0xcc, 0x88, 0xf9, 0x34, 0xd9, 0x18, 0xf8, 0x8c, 0x18,
	0x6e, 0x2a, 0xf5, 0x16, 0xf1, 0xdc, 0xfe, 0x67, 0x11, 0x36, 0xc6, 0xd4, 0x99, 0x47, 0x1e, 0x5f,
	0x24, 0x6f, 0x69, 0x01, 0x84, 0x91, 0x77, 0xe6, 0xf9, 0xf4, 0x84, 0xba, 0xe2, 0x5d, 0x15, 0x33,
	0x83, 0x90, 0x9f, 0xc0, 0x96, 0xed, 0xfb, 0xec, 0xdc, 0x0a, 0xe8, 0xb9, 0x95, 0xe2, 0xb2, 0x5f,
	0x57, 0x4c, 0x22, 0x74, 0x03, 0x7a, 0x3e, 0x4a, 0x35, 0xe4, 0x6d, 0xa8, 0x04, 0x2c, 0xb0, 0x22,
	0xc6, 0xe4, 0xe7, 0x57, 0xcc, 0x72, 0xc0, 0x02, 0x93, 0x31, 0x4e, 0x6e, 0x41, 0x23, 0xa2, 0xb6,
	0x6b, 0xb1, 0xc0, 0x5f, 0x08, 0xc2, 0x13, 0xb9, 0x5f, 0x2b, 0x66, 0x1d, 0xf1, 0x61, 0xe0, 0x2f,
	0x4c, 0x81, 0xa6, 0xe1, 0xe3, 0x36, 0x2d, 0xca, 0xf0, 0xf1, 0xe3, 0x4f, 0x22, 0x36, 0x0f, 0xc5,
	0xa6, 0x2c, 0x9a, 0x52, 0xc0, 0xd7, 0x39, 0x76, 0x18, 0xe3, 0xfe, 0x37, 0xca, 0x3b, 0xc5, 0x5b,
	0x55, 0xb3, 0x8c, 0x72, 0xc7, 0x75, 0x31, 0x13, 0x42, 0xe5, 0x46, 0x2c, 0x34, 0x2a, 0x42, 0x27,
	0xb8, 0x7b, 0x11, 0x0b, 0xc9, 0x21, 0x6c, 0x84, 0x11, 0x73, 0xac, 0x19, 0x9b, 0x07, 0xdc, 0x3a,
	0xf5, 0x02, 0xd7, 0xa8, 0x8a, 0x0d, 0xf7, 0x5e, 0x7a, 0x06, 0xe5, 0x97, 0x6a, 0x77, 0x14, 0x31,
	0xe7, 0x10, 0xd9, 0x8f, 0xbc, 0xc0, 0x35, 0xf5, 0x30, 0x2b, 0x92, 0xcf, 0x61, 0x23, 0xa6, 0x3e,
	0xe6, 0x2f, 0x6d, 0xe4, 0x20, 0xb6, 0xc1, 0xb5, 0xd4, 0x5d, 0x2e, 0xbd, 0x66, 0x5d, 0xd1, 0x93,
	0x66, 0xfe, 0x2b, 0xd0, 0x73, 0x2f, 0x20, 0xd7, 0x80, 0x8c, 0xcc, 0x61, 0xd7, 0x3a, 0x1c, 0x1e,
	0x0d, 0x26, 0xd6, 0x5e, 0xef, 0x61, 0xe7, 0xa8, 0x3f, 0x69, 0x14, 0xb0, 0xe3, 0x66, 0xf0, 0xa3,
	0xc1, 0x61, 0x67, 0xfc, 0xa8, 0xb7, 0xd7, 0xd0, 0xda, 0xdf, 0x68, 0xb0, 0x2e, 0xcc, 0x93, 0xdc,
	0xbe, 0x0b, 0x20, 0xbf, 0x2e, 0xb4, 0xf9, 0x54, 0xd5, 0x51, 0x55, 0x20, 0x23, 0x9b, 0x4f, 0x71,
	0xe5, 0xe2, 0xf9, 0xb1, 0x54, 0xca, 0x7a, 0x2a, 0xc7, 0xf3, 0x63, 0xa1, 0x7a, 0x07, 0xaa, 0x69,
	0xa2, 0x54, 0x12, 0x2b, 0x49, 0x86, 0xd2, 0xc2, 0x5c, 0xcd, 0x14, 0xa6, 0x91, 0x76, 0x7b, 0x63,
	0x4d, 0x26, 0x41, 0x89, 0xe8, 0xea, 0x89, 0xe7, 0x53, 0x6b, 0xc6, 0x5c, 0x2a, 0x32, 0xa7, 0x9b,
	0x15, 0x04, 0x0e, 0x99, 0x4b, 0xc9, 0x35, 0x28, 0x45, 0x74, 0xc6, 0x38, 0x15, 0xad, 0xb4, 0x62,
	0x2a, 0xa9, 0xfd, 0x9f, 0x15, 0x58, 0x97, 0x27, 0xdb, 0x21, 0xe5, 0x53, 0xe6, 0x92, 0x4f, 0x60,
	0x95, 0x3e, 0xa5, 0x8e, 0xf8, 0x88, 0xda, 0xed, 0x1b, 0x69, 0x23, 0xcd, 0x70, 0x94, 0xd0, 0x7b,
	0x4a, 0x9d, 0xfd, 0x82, 0x29, 0xe8, 0x68, 0x36, 0xe5, 0x3c, 0x54, 0x1d, 0xe9, 0x4d, 0x66, 0xfb,
	0x93, 0xc9, 0x08, 0xcd, 0x90, 0x4e, 0x7e, 0x01, 0xa5, 0x98, 0x39, 0xa7, 0x94, 0xab, 0xa1, 0xe2,
	0xe6, 0x1b, 0x0c, 0xc7, 0x82, 0xb8, 0x5f, 0x30, 0x95, 0x49, 0xf3, 0x7d, 0x80, 0x65, 0x24, 0xb8,
	0x30, 0x0e, 0x9b, 0xcd, 0xec, 0xc0, 0x15, 0x8d, 0x0d, 0xab, 0x53, 0x8a, 0xcd, 0x27, 0x09, 0x0f,
	0x5f, 0x8d, 0x2b, 0x31, 0x13, 0x6e, 0x55, 0x9e, 0x94, 0x84, 0xed, 0x6c, 0x1e, 0x25, 0xfb, 0x1d,
	0x1f, 0xc9, 0x2e, 0x94, 0xa7, 0xd4, 0x76, 0x69, 0x84, 0x23, 0x0f, 0xb6, 0xca, 0xad, 0x24, 0xba,
	0x47, 0x74, 0xf1, 0x18, 0x7b, 0xdb, 0xc8, 0xf6, 0x22, 0x33, 0x21, 0x35, 0x77, 0x92, 0xa5, 0x94,
	0x91, 0x26, 0x1e, 0xb5, 0xd4, 0xe3, 0x83, 0x4a, 0x32, 0xba, 0xb5, 0xbf, 0x5e, 0x81, 0xb5, 0x51,
	0xc4, 0x8e, 0x29, 0xf9, 0x51, 0x2e, 0x9e, 0xcc, 0x4b, 0xb2, 0x4b, 0x90, 0x46, 0xf9, 0x7d, 0xd0,
	0xbd, 0xc0, 0xe3, 0x9e, 0xed, 0x5b, 0x2e, 0xf5, 0xed, 0x85, 0x88, 0xb7, 0x68, 0xae, 0x2b, 0x70,
	0x0f, 0x31, 0x24, 0x85, 0xe8, 0xdb, 0xe2, 0xde, 0x8c, 0xb2, 0xb9, 0x5c, 0xdc, 0xa2, 0xb9, 0x2e,
	0xc0, 0x89, 0xc4, 0xb0, 0xc9, 0x4a, 0x92, 0x17, 0x70, 0x1a, 0x9d, 0xd9, 0xbe, 0x28, 0xb3, 0xa2,
	0x29, 0x4d, 0x0f, 0x14, 0x48, 0x3e, 0x82, 0xcd, 0x78, 0xee, 0x38, 0x34, 0x8e, 0x2d, 0x3e, 0x8d,
	0x68, 0x3c, 0x65, 0xbe, 0x2b, 0x9a, 0xc5, 0x9a, 0xd9, 0x50, 0x8a, 0x49, 0x82, 0x23, 0xf9, 0x89,
	0xed, 0xf9, 0x38, 0x2c, 0x2e, 0xc9, 0x25, 0x49, 0x56, 0x8a, 0x94, 0xdc, 0xfe, 0xfb, 0x5a, 0xe6,
	0x4c, 0x18, 0x87, 0xd4, 0xc1, 0x7a, 0x17, 0xb3, 0x8a, 0xcc, 0x81, 0x78, 0xc6, 0x5e, 0x24, 0x0e,
	0x47, 0xb5, 0x8c, 0x52, 0xc8, 0x26, 0xbb, 0x98, 0x4b, 0xb6, 0x98, 0x5d, 0xa2, 0x13, 0xec, 0x76,
	0x45, 0x31, 0xbb, 0x44, 0x27, 0x31, 0xb9, 0x01, 0x35, 0x1c, 0xa5, 0xbd, 0xe0, 0xc4, 0x72, 0xbd,
	0x48, 0x4d, 0x24, 0xa0, 0xa0, 0x3d, 0x4f, 0x34, 0xbc, 0x98, 0xbb, 0x9e, 0x9c, 0x42, 0x2a, 0xa6,
	0x14, 0x70, 0x57, 0x8b, 0x07, 0x8b, 0x05, 0x4e, 0xb2, 0x6f, 0xaa, 0x02, 0x19, 0x06, 0x0e, 0xc5,
	0xf4, 0x72, 0xbe, 0x30, 0x2a, 0x02, 0xc7, 0x47, 0x72, 0x07, 0x56, 0x69, 0x70, 0x16, 0x1b, 0x35,
	0x51, 0x2d, 0xe9, 0x26, 0xc8, 0x7d, 0xe4, 0x6e, 0x2f, 0x38, 0x8b, 0xe5, 0xc9, 0x2a, 0xc8, 0xe4,
	0x33, 0x28, 0x89, 0x4e, 0x11, 0x1b, 0xeb, 0xc2, 0xec, 0xe6, 0xe5, 0x66, 0xa2, 0xdf, 0x28, 0x43,
	0x65, 0x40, 0x3e, 0x85, 0x0d, 0xec, 0x15, 0x5e, 0x80, 0xd9, 0x71, 0xa6, 0xd4, 0x39, 0x35, 0x74,
	0x51, 0x43, 0x7a, 0x7a, 0x25, 0xc0, 0x5c, 0xca, 0x9e, 0x2f, 0x58, 0x5d, 0x24, 0x91, 0x9f, 0x41,
	0xdd, 0xf7, 0xce, 0x68, 0xc6, 0xac, 0x7e, 0x99, 0x99, 0x9e, 0x90, 0xa4, 0xd5, 0x1d, 0xa8, 0xc4,
	0xaa, 0x51, 0x1b, 0xdb, 0x82, 0x7f, 0xfd, 0x35, 0x0d, 0xdc, 0x4c, 0x89, 0xe4, 0x3e, 0x6c, 0x4c,
	0x19, 0x3b, 0xb5, 0x42, 0x3c, 0x8b, 0x63, 0x6e, 0x47, 0xdc, 0xb8, 0xf1, 0x86, 0x32, 0xd7, 0x91,
	0x3c, 0x62, 0x31, 0x1f, 0x23, 0xb5, 0xf9, 0x73, 0xa8, 0xa6, 0xcb, 0xf5, 0xff, 0xe6, 0x8d, 0x6a,
	0x66, 0xde, 0x68, 0x0e, 0xa1, 0x96, 0x59, 0xb0, 0x4b, 0x4c, 0x3f, 0xcc, 0x8f, 0x50, 0x69, 0x34,
	0xd9, 0xb6, 0x9e, 0x1d, 0x60, 0xfe, 0x0b, 0xa0, 0xe7, 0xae, 0x27, 0x38, 0x60, 0x84, 0xcc, 0xb5,
	0xe6, 0x5e, 0xda, 0x48, 0x42, 0xe6, 0x1e, 0x79, 0x2e, 0xf9, 0x1e, 0x54, 0xb1, 0x72, 0xe3, 0xd0,
	0x76, 0x92, 0xc8, 0x96, 0x40, 0x5a, 0xe3, 0xc5, 0x4c, 0x8d, 0xdf, 0xc7, 0x69, 0x58, 0x2c, 0x4e,
	0x32, 0x91, 0xae, 0xe6, 0x6f, 0x76, 0xa6, 0xd4, 0xaa, 0x79, 0x54, 0x8f, 0xb2, 0x22, 0x9e, 0x2e,
	0x6a, 0xd2, 0x71, 0x44, 0x69, 0x57, 0xcc, 0xb2, 0x1c, 0x75, 0x1c, 0x72, 0x13, 0xd6, 0x85, 0x4a,
	0xdd, 0x25, 0x55, 0x79, 0xd7, 0x10, 0x1b, 0x48, 0x28, 0xb5, 0x0e, 0x3d, 0x57, 0x95, 0xb8, 0xb0,
	0x1e, 0x79, 0x2e, 0x8e, 0x68, 0xf8, 0x28, 0xc2, 0xad, 0xc8, 0x11, 0x2d, 0x91, 0xf1, 0xb0, 0x89,
	0xa7, 0x76, 0x44, 0x85, 0x5d, 0x55, 0x9e, 0x5b, 0x02, 0x40, 0xc3, 0x4f, 0x00, 0xd2, 0x49, 0x2d,
	0xd9, 0x0d, 0xdb, 0x97, 0x96, 0xb5, 0x99, 0x21, 0x92, 0x0f, 0x60, 0xe3, 0xdc, 0xf6, 0xb8, 0x95,
	0xb1, 0x5d, 0x97, 0x33, 0x0b, 0xc2, 0xdd, 0x25, 0xf1, 0x53, 0x58, 0xc3, 0x99, 0x2f, 0x36, 0x74,
	0xe1, 0x7a, 0xe7, 0xd2, 0xfb, 0xe3, 0x2e, 0x8e, 0x81, 0x6a, 0xc3, 0x48, 0x3a, 0x2e, 0x07, 0x06,
	0x6f, 0xc9, 0x2b, 0x4b, 0x6c, 0xd4, 0x45, 0x8f, 0xa8, 0x21, 0x36, 0x96, 0x90, 0xbc, 0xe6, 0xd8,
	0x91, 0x33, 0xb5, 0x5c, 0x36, 0xb3, 0xbd, 0x20, 0x36, 0x36, 0x04, 0x49, 0x97, 0xe8, 0x9e, 0x04,
	0x31, 0x02, 0x5c, 0x8a, 0xd8, 0x68, 0xbc, 0x29, 0x82, 0x7d, 0xa4, 0xa8, 0x08, 0x04, 0x1d, 0x3b,
	0x91, 0x1b, 0xc4, 0xe9, 0xe0, 0xb2, 0x29, 0x7c, 0x83, 0x1b, 0xc4, 0x49, 0x55, 0x7d, 0x0e, 0x1b,
	0x2a, 0x59, 0x29, 0x89, 0xe4, 0xa7, 0x1b, 0x95, 0xb8, 0x74, 0xba, 0x09, 0x72, 0x32, 0xe9, 0x02,
	0xc8, 0x7c, 0xda, 0x7c, 0x1a, 0x1b, 0xdb, 0x22, 0xbc, 0x1f, 0xbc, 0x3e, 0x3c, 0x1c, 0x42, 0x54,
	0x88, 0x62, 0x98, 0x16, 0x32, 0x79, 0x08, 0xb5, 0x33, 0xe6, 0xcf, 0x67, 0xd4, 0xc2, 0xe1, 0xdf,
	0xb8, 0x26, 0xbc, 0xbc, 0x77, 0xb9, 0x97, 0xc7, 0x82, 0x88, 0x37, 0x03, 0xe9, 0x06, 0xce, 0x52,
	0x00, 0x7b, 0x9b, 0x6f, 0x1f, 0x53, 0x3f, 0x36, 0xae, 0xbf, 0xd4, 0xdb, 0x72, 0x2e, 0xfa, 0x82,
	0xa3, 0x7a, 0x9b, 0x34, 0x20, 0x3f, 0x85, 0x6d, 0x75, 0xd9, 0xc7, 0x5d, 0xc6, 0x02, 0x4b, 0x9d,
	0x1f, 0x86, 0x21, 0xe7, 0x61, 0xa9, 0x1c, 0x31, 0x77, 0x18, 0x3c, 0x94, 0x1a, 0x72, 0x1f, 0xca,
	0xf1, 0x22, 0x76, 0xb8, 0x1f, 0x1b, 0x37, 0xc4, 0xeb, 0xda, 0x97, 0xbf, 0x6e, 0x2c, 0x49, 0xea,
	0x7a, 0xa3, 0x4c, 0x9a, 0x43, 0x80, 0x65, 0xc5, 0x5c, 0xd2, 0x31, 0x3e, 0xca, 0x77, 0x8c, 0x57,
	0xeb, 0x19, 0xad, 0xb3, 0x3d, 0xe8, 0x2e, 0xc0, 0xb2, 0x00, 0xae, 0xd4, 0xbd, 0xee, 0x43, 0x3d,
	0x9f, 0x9b, 0x2b, 0x59, 0x8f, 0x60, 0xe3, 0xa5, 0x9c, 0x5c, 0xe1, 0x0a, 0x99, 0x5e, 0x02, 0xb3,
	0x1e, 0x3f, 0x83, 0x5a, 0x26, 0x45, 0x57, 0x0a, 0xe6, 0x1e, 0xac, 0x67, 0x97, 0xfb, 0x2a, 0xb6,
	0x5f, 0xac, 0x56, 0xa0, 0x51, 0x6b, 0xff, 0x69, 0x05, 0xf4, 0xdc, 0x1f, 0x3b, 0xaf, 0xef, 0xbc,
	0xad, 0x5c, 0xdf, 0x59, 0x91, 0x9b, 0x2b, 0xd3, 0x60, 0xde, 0x05, 0x38, 0x89, 0x6c, 0x47, 0xce,
	0x45, 0xe2, 0xd6, 0x50, 0x34, 0xab, 0x02, 0xc1, 0xa1, 0x88, 0x7c, 0x01, 0xba, 0x3c, 0xab, 0x22,
	0x6a, 0xc5, 0x9c, 0x85, 0xaa, 0x73, 0xbd, 0x7f, 0xe9, 0xdf, 0x4b, 0xbb, 0xfb, 0x78, 0x52, 0x45,
	0x74, 0xcc, 0x99, 0xba, 0x28, 0xd7, 0xa6, 0x4b, 0xa4, 0x39, 0x81, 0xc6, 0xcb, 0x84, 0x2b, 0x9c,
	0x42, 0xb9, 0x33, 0x31, 0x73, 0x0a, 0xfd, 0x06, 0x6a, 0x99, 0x7f, 0xa9, 0xf2, 0x27, 0x8d, 0xf6,
	0xba, 0x93, 0x26, 0x3b, 0x4d, 0x35, 0xa0, 0x68, 0xfb, 0xbe, 0xba, 0x68, 0xe0, 0xe3, 0x87, 0xbf,
	0x83, 0x8d, 0x97, 0xfe, 0xef, 0x20, 0xdb, 0xb0, 0x29, 0xfe, 0x8c, 0xb2, 0x46, 0x47, 0xfd, 0xbe,
	0xd5, 0xe9, 0x7f, 0xd9, 0xf9, 0x6a, 0xdc, 0x28, 0x90, 0x77, 0xe1, 0xed, 0x0c, 0x7c, 0xf0, 0xd0,
	0x1a, 0x0c, 0x27, 0xd6, 0xc8, 0xec, 0x8d, 0x7b, 0x83, 0x49, 0x43, 0x23, 0x5b, 0xd0, 0xc8, 0xa8,
	0x07, 0xbd, 0xc7, 0x3d, 0xb3, 0xb1, 0xf2, 0xe1, 0x00, 0xf4, 0xdc, 0xe1, 0x45, 0x08, 0xd4, 0xcd,
	0x9e, 0xfc, 0x23, 0x2b, 0xf5, 0x7c, 0x0d, 0x48, 0x82, 0x0d, 0x07, 0xd6, 0xc3, 0xce, 0x41, 0xff,
	0xc8, 0xec, 0x35, 0x34, 0xb2, 0x09, 0x7a, 0x82, 0x2b, 0x7f, 0x0f, 0xbe, 0x7c, 0xf6, 0xbc, 0x55,
	0xf8, 0xf6, 0x79, 0xab, 0xf0, 0xdd, 0xf3, 0x96, 0xf6, 0xf5, 0x45, 0x4b, 0xfb, 0xdb, 0x45, 0x4b,
	0xfb, 0xe6, 0xa2, 0xa5, 0x3d, 0xbb, 0x68, 0x69, 0xff, 0xba, 0x68, 0x69, 0xff, 0xbe, 0x68, 0x15,
	0xbe, 0xbb, 0x68, 0x69, 0x7f, 0x7e, 0xd1, 0x2a, 0x3c, 0x7b, 0xd1, 0x2a, 0x7c, 0xfb, 0xa2, 0x55,
	0xf8, 0xed, 0x4d, 0x3b, 0x9a, 0xda, 0x7c, 0xd7, 0xa5, 0x67, 0x3f, 0x96, 0x2b, 0xfc, 0xb1, 0xf8,
	0xaf, 0x41, 0x09, 0x27, 0x2c, 0x3c, 0x3e, 0x2e, 0x09, 0xe4, 0xce, 0xff, 0x02, 0x00, 0x00, 0xff,
	0xff, 0xde, 0x59, 0xda, 0xc7, 0xa3, 0x15, 0x00, 0x00,
}

func (x ImagePullPolicy) String() string {
	s, ok := ImagePullPolicy_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RestartPolicy) String() string {
	s, ok := RestartPolicy_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PodCmd_Action) String() string {
	s, ok := PodCmd_Action_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SecurityOptions_ProcMountKind) String() string {
	s, ok := SecurityOptions_ProcMountKind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *PodCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd)
	if !ok {
		that2, ok := that.(PodCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if that1.Options == nil {
		if this.Options != nil {
			return false
		}
	} else if this.Options == nil {
		return false
	} else if !this.Options.Equal(that1.Options) {
		return false
	}
	return true
}
func (this *PodCmd_SyncOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_SyncOptions)
	if !ok {
		that2, ok := that.(PodCmd_SyncOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SyncOptions.Equal(that1.SyncOptions) {
		return false
	}
	return true
}
func (this *PodCmd_ImageEnsureOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_ImageEnsureOptions)
	if !ok {
		that2, ok := that.(PodCmd_ImageEnsureOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ImageEnsureOptions.Equal(that1.ImageEnsureOptions) {
		return false
	}
	return true
}
func (this *PodCmd_CreateOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_CreateOptions)
	if !ok {
		that2, ok := that.(PodCmd_CreateOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CreateOptions.Equal(that1.CreateOptions) {
		return false
	}
	return true
}
func (this *PodCmd_DeleteOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_DeleteOptions)
	if !ok {
		that2, ok := that.(PodCmd_DeleteOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeleteOptions.Equal(that1.DeleteOptions) {
		return false
	}
	return true
}
func (this *PodCmd_ListOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_ListOptions)
	if !ok {
		that2, ok := that.(PodCmd_ListOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ListOptions.Equal(that1.ListOptions) {
		return false
	}
	return true
}
func (this *AuthConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthConfig)
	if !ok {
		that2, ok := that.(AuthConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if this.Password != that1.Password {
		return false
	}
	if this.Auth != that1.Auth {
		return false
	}
	if this.ServerAddress != that1.ServerAddress {
		return false
	}
	if this.IdentityToken != that1.IdentityToken {
		return false
	}
	if this.RegistryToken != that1.RegistryToken {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	return true
}
func (this *ImagePull) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImagePull)
	if !ok {
		that2, ok := that.(ImagePull)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AuthConfig.Equal(that1.AuthConfig) {
		return false
	}
	if this.PullPolicy != that1.PullPolicy {
		return false
	}
	return true
}
func (this *ImageEnsureOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageEnsureOptions)
	if !ok {
		that2, ok := that.(ImageEnsureOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ImagePull) != len(that1.ImagePull) {
		return false
	}
	for i := range this.ImagePull {
		if !this.ImagePull[i].Equal(that1.ImagePull[i]) {
			return false
		}
	}
	return true
}
func (this *NamedData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamedData)
	if !ok {
		that2, ok := that.(NamedData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DataMap) != len(that1.DataMap) {
		return false
	}
	for i := range this.DataMap {
		if !bytes.Equal(this.DataMap[i], that1.DataMap[i]) {
			return false
		}
	}
	return true
}
func (this *ContainerPort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerPort)
	if !ok {
		that2, ok := that.(ContainerPort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.ContainerPort != that1.ContainerPort {
		return false
	}
	if this.HostPort != that1.HostPort {
		return false
	}
	if this.HostIp != that1.HostIp {
		return false
	}
	return true
}
func (this *SELinuxOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SELinuxOptions)
	if !ok {
		that2, ok := that.(SELinuxOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Level != that1.Level {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	if this.User != that1.User {
		return false
	}
	return true
}
func (this *SecurityOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityOptions)
	if !ok {
		that2, ok := that.(SecurityOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Privileged != that1.Privileged {
		return false
	}
	if this.AllowNewPrivileges != that1.AllowNewPrivileges {
		return false
	}
	if this.NonRoot != that1.NonRoot {
		return false
	}
	if this.ReadOnlyRootfs != that1.ReadOnlyRootfs {
		return false
	}
	if this.User != that1.User {
		return false
	}
	if this.Group != that1.Group {
		return false
	}
	if len(this.CapsAdd) != len(that1.CapsAdd) {
		return false
	}
	for i := range this.CapsAdd {
		if this.CapsAdd[i] != that1.CapsAdd[i] {
			return false
		}
	}
	if len(this.CapsDrop) != len(that1.CapsDrop) {
		return false
	}
	for i := range this.CapsDrop {
		if this.CapsDrop[i] != that1.CapsDrop[i] {
			return false
		}
	}
	if this.ProcMountKind != that1.ProcMountKind {
		return false
	}
	if !this.SelinuxOptions.Equal(that1.SelinuxOptions) {
		return false
	}
	return true
}
func (this *MountOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MountOptions)
	if !ok {
		that2, ok := that.(MountOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MountPath != that1.MountPath {
		return false
	}
	if this.SubPath != that1.SubPath {
		return false
	}
	if this.ReadOnly != that1.ReadOnly {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Options) != len(that1.Options) {
		return false
	}
	for i := range this.Options {
		if this.Options[i] != that1.Options[i] {
			return false
		}
	}
	if this.FileMode != that1.FileMode {
		return false
	}
	if this.Remote != that1.Remote {
		return false
	}
	return true
}
func (this *ActionMethod) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionMethod)
	if !ok {
		that2, ok := that.(ActionMethod)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Action == nil {
		if this.Action != nil {
			return false
		}
	} else if this.Action == nil {
		return false
	} else if !this.Action.Equal(that1.Action) {
		return false
	}
	return true
}
func (this *ActionMethod_Exec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionMethod_Exec)
	if !ok {
		that2, ok := that.(ActionMethod_Exec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Exec.Equal(that1.Exec) {
		return false
	}
	return true
}
func (this *ActionMethod_Http) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionMethod_Http)
	if !ok {
		that2, ok := that.(ActionMethod_Http)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Http.Equal(that1.Http) {
		return false
	}
	return true
}
func (this *ActionMethod_Socket) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionMethod_Socket)
	if !ok {
		that2, ok := that.(ActionMethod_Socket)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Socket.Equal(that1.Socket) {
		return false
	}
	return true
}
func (this *ActionMethod_ActionExec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionMethod_ActionExec)
	if !ok {
		that2, ok := that.(ActionMethod_ActionExec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Command) != len(that1.Command) {
		return false
	}
	for i := range this.Command {
		if this.Command[i] != that1.Command[i] {
			return false
		}
	}
	return true
}
func (this *ActionMethod_ActionHTTP) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionMethod_ActionHTTP)
	if !ok {
		that2, ok := that.(ActionMethod_ActionHTTP)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Method != that1.Method {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	return true
}
func (this *ActionMethod_ActionSocket) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionMethod_ActionSocket)
	if !ok {
		that2, ok := that.(ActionMethod_ActionSocket)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	return true
}
func (this *Probe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Probe)
	if !ok {
		that2, ok := that.(Probe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Method.Equal(that1.Method) {
		return false
	}
	if this.InitialDelay != that1.InitialDelay {
		return false
	}
	if this.ProbeTimeout != that1.ProbeTimeout {
		return false
	}
	if this.ProbeInterval != that1.ProbeInterval {
		return false
	}
	if this.SuccessThreshold != that1.SuccessThreshold {
		return false
	}
	if this.FailureThreshold != that1.FailureThreshold {
		return false
	}
	return true
}
func (this *ContainerSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerSpec)
	if !ok {
		that2, ok := that.(ContainerSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Image != that1.Image {
		return false
	}
	if len(this.Command) != len(that1.Command) {
		return false
	}
	for i := range this.Command {
		if this.Command[i] != that1.Command[i] {
			return false
		}
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if this.Args[i] != that1.Args[i] {
			return false
		}
	}
	if this.WorkingDir != that1.WorkingDir {
		return false
	}
	if this.Stdin != that1.Stdin {
		return false
	}
	if this.StdinOnce != that1.StdinOnce {
		return false
	}
	if this.Tty != that1.Tty {
		return false
	}
	if len(this.Envs) != len(that1.Envs) {
		return false
	}
	for i := range this.Envs {
		if this.Envs[i] != that1.Envs[i] {
			return false
		}
	}
	if len(this.Mounts) != len(that1.Mounts) {
		return false
	}
	for i := range this.Mounts {
		if !this.Mounts[i].Equal(that1.Mounts[i]) {
			return false
		}
	}
	if !this.ReadinessCheck.Equal(that1.ReadinessCheck) {
		return false
	}
	if !this.LivenessCheck.Equal(that1.LivenessCheck) {
		return false
	}
	if !this.Security.Equal(that1.Security) {
		return false
	}
	if !this.HookPostStart.Equal(that1.HookPostStart) {
		return false
	}
	return true
}
func (this *CreateOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateOptions)
	if !ok {
		that2, ok := that.(CreateOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.RestartPolicy != that1.RestartPolicy {
		return false
	}
	if this.HostIpc != that1.HostIpc {
		return false
	}
	if this.HostNetwork != that1.HostNetwork {
		return false
	}
	if this.HostPid != that1.HostPid {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.SharePid != that1.SharePid {
		return false
	}
	if len(this.Containers) != len(that1.Containers) {
		return false
	}
	for i := range this.Containers {
		if !this.Containers[i].Equal(that1.Containers[i]) {
			return false
		}
	}
	if this.WaitContainers != that1.WaitContainers {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if !this.Ports[i].Equal(that1.Ports[i]) {
			return false
		}
	}
	if len(this.NameServers) != len(that1.NameServers) {
		return false
	}
	for i := range this.NameServers {
		if this.NameServers[i] != that1.NameServers[i] {
			return false
		}
	}
	if len(this.SearchDomains) != len(that1.SearchDomains) {
		return false
	}
	for i := range this.SearchDomains {
		if this.SearchDomains[i] != that1.SearchDomains[i] {
			return false
		}
	}
	if len(this.Hosts) != len(that1.Hosts) {
		return false
	}
	for i := range this.Hosts {
		if this.Hosts[i] != that1.Hosts[i] {
			return false
		}
	}
	if len(this.DnsOptions) != len(that1.DnsOptions) {
		return false
	}
	for i := range this.DnsOptions {
		if this.DnsOptions[i] != that1.DnsOptions[i] {
			return false
		}
	}
	if !this.NetworkOptions.Equal(that1.NetworkOptions) {
		return false
	}
	if len(this.HostPaths) != len(that1.HostPaths) {
		return false
	}
	for i := range this.HostPaths {
		if this.HostPaths[i] != that1.HostPaths[i] {
			return false
		}
	}
	if len(this.VolumeData) != len(that1.VolumeData) {
		return false
	}
	for i := range this.VolumeData {
		if !this.VolumeData[i].Equal(that1.VolumeData[i]) {
			return false
		}
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if this.DeletePodOnFailure != that1.DeletePodOnFailure {
		return false
	}
	if len(this.Sysctls) != len(that1.Sysctls) {
		return false
	}
	for i := range this.Sysctls {
		if this.Sysctls[i] != that1.Sysctls[i] {
			return false
		}
	}
	return true
}
func (this *DeleteOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteOptions)
	if !ok {
		that2, ok := that.(DeleteOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if len(this.Containers) != len(that1.Containers) {
		return false
	}
	for i := range this.Containers {
		if this.Containers[i] != that1.Containers[i] {
			return false
		}
	}
	if this.GraceTime != that1.GraceTime {
		return false
	}
	if len(this.HookPreStop) != len(that1.HookPreStop) {
		return false
	}
	for i := range this.HookPreStop {
		if !this.HookPreStop[i].Equal(that1.HookPreStop[i]) {
			return false
		}
	}
	return true
}
func (this *ListOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListOptions)
	if !ok {
		that2, ok := that.(ListOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.All != that1.All {
		return false
	}
	return true
}
func (this *PodCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&aranyagopb.PodCmd{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodCmd_SyncOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aranyagopb.PodCmd_SyncOptions{` +
		`SyncOptions:` + fmt.Sprintf("%#v", this.SyncOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_ImageEnsureOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aranyagopb.PodCmd_ImageEnsureOptions{` +
		`ImageEnsureOptions:` + fmt.Sprintf("%#v", this.ImageEnsureOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_CreateOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aranyagopb.PodCmd_CreateOptions{` +
		`CreateOptions:` + fmt.Sprintf("%#v", this.CreateOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_DeleteOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aranyagopb.PodCmd_DeleteOptions{` +
		`DeleteOptions:` + fmt.Sprintf("%#v", this.DeleteOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_ListOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aranyagopb.PodCmd_ListOptions{` +
		`ListOptions:` + fmt.Sprintf("%#v", this.ListOptions) + `}`}, ", ")
	return s
}
func (this *AuthConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&aranyagopb.AuthConfig{")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	s = append(s, "Auth: "+fmt.Sprintf("%#v", this.Auth)+",\n")
	s = append(s, "ServerAddress: "+fmt.Sprintf("%#v", this.ServerAddress)+",\n")
	s = append(s, "IdentityToken: "+fmt.Sprintf("%#v", this.IdentityToken)+",\n")
	s = append(s, "RegistryToken: "+fmt.Sprintf("%#v", this.RegistryToken)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImagePull) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&aranyagopb.ImagePull{")
	if this.AuthConfig != nil {
		s = append(s, "AuthConfig: "+fmt.Sprintf("%#v", this.AuthConfig)+",\n")
	}
	s = append(s, "PullPolicy: "+fmt.Sprintf("%#v", this.PullPolicy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImageEnsureOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.ImageEnsureOptions{")
	keysForImagePull := make([]string, 0, len(this.ImagePull))
	for k, _ := range this.ImagePull {
		keysForImagePull = append(keysForImagePull, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForImagePull)
	mapStringForImagePull := "map[string]*ImagePull{"
	for _, k := range keysForImagePull {
		mapStringForImagePull += fmt.Sprintf("%#v: %#v,", k, this.ImagePull[k])
	}
	mapStringForImagePull += "}"
	if this.ImagePull != nil {
		s = append(s, "ImagePull: "+mapStringForImagePull+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamedData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.NamedData{")
	keysForDataMap := make([]string, 0, len(this.DataMap))
	for k, _ := range this.DataMap {
		keysForDataMap = append(keysForDataMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDataMap)
	mapStringForDataMap := "map[string][]byte{"
	for _, k := range keysForDataMap {
		mapStringForDataMap += fmt.Sprintf("%#v: %#v,", k, this.DataMap[k])
	}
	mapStringForDataMap += "}"
	if this.DataMap != nil {
		s = append(s, "DataMap: "+mapStringForDataMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&aranyagopb.ContainerPort{")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "ContainerPort: "+fmt.Sprintf("%#v", this.ContainerPort)+",\n")
	s = append(s, "HostPort: "+fmt.Sprintf("%#v", this.HostPort)+",\n")
	s = append(s, "HostIp: "+fmt.Sprintf("%#v", this.HostIp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SELinuxOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&aranyagopb.SELinuxOptions{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Level: "+fmt.Sprintf("%#v", this.Level)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&aranyagopb.SecurityOptions{")
	s = append(s, "Privileged: "+fmt.Sprintf("%#v", this.Privileged)+",\n")
	s = append(s, "AllowNewPrivileges: "+fmt.Sprintf("%#v", this.AllowNewPrivileges)+",\n")
	s = append(s, "NonRoot: "+fmt.Sprintf("%#v", this.NonRoot)+",\n")
	s = append(s, "ReadOnlyRootfs: "+fmt.Sprintf("%#v", this.ReadOnlyRootfs)+",\n")
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "Group: "+fmt.Sprintf("%#v", this.Group)+",\n")
	s = append(s, "CapsAdd: "+fmt.Sprintf("%#v", this.CapsAdd)+",\n")
	s = append(s, "CapsDrop: "+fmt.Sprintf("%#v", this.CapsDrop)+",\n")
	s = append(s, "ProcMountKind: "+fmt.Sprintf("%#v", this.ProcMountKind)+",\n")
	if this.SelinuxOptions != nil {
		s = append(s, "SelinuxOptions: "+fmt.Sprintf("%#v", this.SelinuxOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MountOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&aranyagopb.MountOptions{")
	s = append(s, "MountPath: "+fmt.Sprintf("%#v", this.MountPath)+",\n")
	s = append(s, "SubPath: "+fmt.Sprintf("%#v", this.SubPath)+",\n")
	s = append(s, "ReadOnly: "+fmt.Sprintf("%#v", this.ReadOnly)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	s = append(s, "FileMode: "+fmt.Sprintf("%#v", this.FileMode)+",\n")
	s = append(s, "Remote: "+fmt.Sprintf("%#v", this.Remote)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ActionMethod) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&aranyagopb.ActionMethod{")
	if this.Action != nil {
		s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ActionMethod_Exec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aranyagopb.ActionMethod_Exec{` +
		`Exec:` + fmt.Sprintf("%#v", this.Exec) + `}`}, ", ")
	return s
}
func (this *ActionMethod_Http) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aranyagopb.ActionMethod_Http{` +
		`Http:` + fmt.Sprintf("%#v", this.Http) + `}`}, ", ")
	return s
}
func (this *ActionMethod_Socket) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&aranyagopb.ActionMethod_Socket{` +
		`Socket:` + fmt.Sprintf("%#v", this.Socket) + `}`}, ", ")
	return s
}
func (this *ActionMethod_ActionExec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.ActionMethod_ActionExec{")
	s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ActionMethod_ActionHTTP) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&aranyagopb.ActionMethod_ActionHTTP{")
	s = append(s, "Method: "+fmt.Sprintf("%#v", this.Method)+",\n")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ActionMethod_ActionSocket) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&aranyagopb.ActionMethod_ActionSocket{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Probe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&aranyagopb.Probe{")
	if this.Method != nil {
		s = append(s, "Method: "+fmt.Sprintf("%#v", this.Method)+",\n")
	}
	s = append(s, "InitialDelay: "+fmt.Sprintf("%#v", this.InitialDelay)+",\n")
	s = append(s, "ProbeTimeout: "+fmt.Sprintf("%#v", this.ProbeTimeout)+",\n")
	s = append(s, "ProbeInterval: "+fmt.Sprintf("%#v", this.ProbeInterval)+",\n")
	s = append(s, "SuccessThreshold: "+fmt.Sprintf("%#v", this.SuccessThreshold)+",\n")
	s = append(s, "FailureThreshold: "+fmt.Sprintf("%#v", this.FailureThreshold)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&aranyagopb.ContainerSpec{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Image: "+fmt.Sprintf("%#v", this.Image)+",\n")
	s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	s = append(s, "Args: "+fmt.Sprintf("%#v", this.Args)+",\n")
	s = append(s, "WorkingDir: "+fmt.Sprintf("%#v", this.WorkingDir)+",\n")
	s = append(s, "Stdin: "+fmt.Sprintf("%#v", this.Stdin)+",\n")
	s = append(s, "StdinOnce: "+fmt.Sprintf("%#v", this.StdinOnce)+",\n")
	s = append(s, "Tty: "+fmt.Sprintf("%#v", this.Tty)+",\n")
	keysForEnvs := make([]string, 0, len(this.Envs))
	for k, _ := range this.Envs {
		keysForEnvs = append(keysForEnvs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEnvs)
	mapStringForEnvs := "map[string]string{"
	for _, k := range keysForEnvs {
		mapStringForEnvs += fmt.Sprintf("%#v: %#v,", k, this.Envs[k])
	}
	mapStringForEnvs += "}"
	if this.Envs != nil {
		s = append(s, "Envs: "+mapStringForEnvs+",\n")
	}
	keysForMounts := make([]string, 0, len(this.Mounts))
	for k, _ := range this.Mounts {
		keysForMounts = append(keysForMounts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMounts)
	mapStringForMounts := "map[string]*MountOptions{"
	for _, k := range keysForMounts {
		mapStringForMounts += fmt.Sprintf("%#v: %#v,", k, this.Mounts[k])
	}
	mapStringForMounts += "}"
	if this.Mounts != nil {
		s = append(s, "Mounts: "+mapStringForMounts+",\n")
	}
	if this.ReadinessCheck != nil {
		s = append(s, "ReadinessCheck: "+fmt.Sprintf("%#v", this.ReadinessCheck)+",\n")
	}
	if this.LivenessCheck != nil {
		s = append(s, "LivenessCheck: "+fmt.Sprintf("%#v", this.LivenessCheck)+",\n")
	}
	if this.Security != nil {
		s = append(s, "Security: "+fmt.Sprintf("%#v", this.Security)+",\n")
	}
	if this.HookPostStart != nil {
		s = append(s, "HookPostStart: "+fmt.Sprintf("%#v", this.HookPostStart)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 26)
	s = append(s, "&aranyagopb.CreateOptions{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "RestartPolicy: "+fmt.Sprintf("%#v", this.RestartPolicy)+",\n")
	s = append(s, "HostIpc: "+fmt.Sprintf("%#v", this.HostIpc)+",\n")
	s = append(s, "HostNetwork: "+fmt.Sprintf("%#v", this.HostNetwork)+",\n")
	s = append(s, "HostPid: "+fmt.Sprintf("%#v", this.HostPid)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "SharePid: "+fmt.Sprintf("%#v", this.SharePid)+",\n")
	if this.Containers != nil {
		s = append(s, "Containers: "+fmt.Sprintf("%#v", this.Containers)+",\n")
	}
	s = append(s, "WaitContainers: "+fmt.Sprintf("%#v", this.WaitContainers)+",\n")
	keysForPorts := make([]string, 0, len(this.Ports))
	for k, _ := range this.Ports {
		keysForPorts = append(keysForPorts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPorts)
	mapStringForPorts := "map[string]*ContainerPort{"
	for _, k := range keysForPorts {
		mapStringForPorts += fmt.Sprintf("%#v: %#v,", k, this.Ports[k])
	}
	mapStringForPorts += "}"
	if this.Ports != nil {
		s = append(s, "Ports: "+mapStringForPorts+",\n")
	}
	s = append(s, "NameServers: "+fmt.Sprintf("%#v", this.NameServers)+",\n")
	s = append(s, "SearchDomains: "+fmt.Sprintf("%#v", this.SearchDomains)+",\n")
	keysForHosts := make([]string, 0, len(this.Hosts))
	for k, _ := range this.Hosts {
		keysForHosts = append(keysForHosts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHosts)
	mapStringForHosts := "map[string]string{"
	for _, k := range keysForHosts {
		mapStringForHosts += fmt.Sprintf("%#v: %#v,", k, this.Hosts[k])
	}
	mapStringForHosts += "}"
	if this.Hosts != nil {
		s = append(s, "Hosts: "+mapStringForHosts+",\n")
	}
	s = append(s, "DnsOptions: "+fmt.Sprintf("%#v", this.DnsOptions)+",\n")
	if this.NetworkOptions != nil {
		s = append(s, "NetworkOptions: "+fmt.Sprintf("%#v", this.NetworkOptions)+",\n")
	}
	keysForHostPaths := make([]string, 0, len(this.HostPaths))
	for k, _ := range this.HostPaths {
		keysForHostPaths = append(keysForHostPaths, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHostPaths)
	mapStringForHostPaths := "map[string]string{"
	for _, k := range keysForHostPaths {
		mapStringForHostPaths += fmt.Sprintf("%#v: %#v,", k, this.HostPaths[k])
	}
	mapStringForHostPaths += "}"
	if this.HostPaths != nil {
		s = append(s, "HostPaths: "+mapStringForHostPaths+",\n")
	}
	keysForVolumeData := make([]string, 0, len(this.VolumeData))
	for k, _ := range this.VolumeData {
		keysForVolumeData = append(keysForVolumeData, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVolumeData)
	mapStringForVolumeData := "map[string]*NamedData{"
	for _, k := range keysForVolumeData {
		mapStringForVolumeData += fmt.Sprintf("%#v: %#v,", k, this.VolumeData[k])
	}
	mapStringForVolumeData += "}"
	if this.VolumeData != nil {
		s = append(s, "VolumeData: "+mapStringForVolumeData+",\n")
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "DeletePodOnFailure: "+fmt.Sprintf("%#v", this.DeletePodOnFailure)+",\n")
	keysForSysctls := make([]string, 0, len(this.Sysctls))
	for k, _ := range this.Sysctls {
		keysForSysctls = append(keysForSysctls, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSysctls)
	mapStringForSysctls := "map[string]string{"
	for _, k := range keysForSysctls {
		mapStringForSysctls += fmt.Sprintf("%#v: %#v,", k, this.Sysctls[k])
	}
	mapStringForSysctls += "}"
	if this.Sysctls != nil {
		s = append(s, "Sysctls: "+mapStringForSysctls+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&aranyagopb.DeleteOptions{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Containers: "+fmt.Sprintf("%#v", this.Containers)+",\n")
	s = append(s, "GraceTime: "+fmt.Sprintf("%#v", this.GraceTime)+",\n")
	keysForHookPreStop := make([]string, 0, len(this.HookPreStop))
	for k, _ := range this.HookPreStop {
		keysForHookPreStop = append(keysForHookPreStop, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHookPreStop)
	mapStringForHookPreStop := "map[string]*ActionMethod{"
	for _, k := range keysForHookPreStop {
		mapStringForHookPreStop += fmt.Sprintf("%#v: %#v,", k, this.HookPreStop[k])
	}
	mapStringForHookPreStop += "}"
	if this.HookPreStop != nil {
		s = append(s, "HookPreStop: "+mapStringForHookPreStop+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&aranyagopb.ListOptions{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "All: "+fmt.Sprintf("%#v", this.All)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCmdPod(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *PodCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Options != nil {
		{
			size := m.Options.Size()
			i -= size
			if _, err := m.Options.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Action != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PodCmd_SyncOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodCmd_SyncOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SyncOptions != nil {
		{
			size, err := m.SyncOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PodCmd_ImageEnsureOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodCmd_ImageEnsureOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ImageEnsureOptions != nil {
		{
			size, err := m.ImageEnsureOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *PodCmd_CreateOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodCmd_CreateOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateOptions != nil {
		{
			size, err := m.CreateOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PodCmd_DeleteOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodCmd_DeleteOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeleteOptions != nil {
		{
			size, err := m.DeleteOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *PodCmd_ListOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodCmd_ListOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ListOptions != nil {
		{
			size, err := m.ListOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AuthConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RegistryToken) > 0 {
		i -= len(m.RegistryToken)
		copy(dAtA[i:], m.RegistryToken)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.RegistryToken)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.IdentityToken) > 0 {
		i -= len(m.IdentityToken)
		copy(dAtA[i:], m.IdentityToken)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.IdentityToken)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ServerAddress) > 0 {
		i -= len(m.ServerAddress)
		copy(dAtA[i:], m.ServerAddress)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.ServerAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Auth) > 0 {
		i -= len(m.Auth)
		copy(dAtA[i:], m.Auth)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Auth)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImagePull) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImagePull) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImagePull) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PullPolicy != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.PullPolicy))
		i--
		dAtA[i] = 0x18
	}
	if m.AuthConfig != nil {
		{
			size, err := m.AuthConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *ImageEnsureOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageEnsureOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImageEnsureOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ImagePull) > 0 {
		for k := range m.ImagePull {
			v := m.ImagePull[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCmdPod(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NamedData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamedData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DataMap) > 0 {
		for k := range m.DataMap {
			v := m.DataMap[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintCmdPod(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ContainerPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HostIp) > 0 {
		i -= len(m.HostIp)
		copy(dAtA[i:], m.HostIp)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.HostIp)))
		i--
		dAtA[i] = 0x22
	}
	if m.HostPort != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.HostPort))
		i--
		dAtA[i] = 0x18
	}
	if m.ContainerPort != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.ContainerPort))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SELinuxOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SELinuxOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SELinuxOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Level) > 0 {
		i -= len(m.Level)
		copy(dAtA[i:], m.Level)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Level)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SelinuxOptions != nil {
		{
			size, err := m.SelinuxOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ProcMountKind != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.ProcMountKind))
		i--
		dAtA[i] = 0x48
	}
	if len(m.CapsDrop) > 0 {
		for iNdEx := len(m.CapsDrop) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CapsDrop[iNdEx])
			copy(dAtA[i:], m.CapsDrop[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.CapsDrop[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CapsAdd) > 0 {
		for iNdEx := len(m.CapsAdd) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CapsAdd[iNdEx])
			copy(dAtA[i:], m.CapsAdd[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.CapsAdd[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Group != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x30
	}
	if m.User != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.User))
		i--
		dAtA[i] = 0x28
	}
	if m.ReadOnlyRootfs {
		i--
		if m.ReadOnlyRootfs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.NonRoot {
		i--
		if m.NonRoot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AllowNewPrivileges {
		i--
		if m.AllowNewPrivileges {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Privileged {
		i--
		if m.Privileged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MountOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MountOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MountOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Remote {
		i--
		if m.Remote {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.FileMode != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.FileMode))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Options[iNdEx])
			copy(dAtA[i:], m.Options[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Options[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if m.ReadOnly {
		i--
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.SubPath) > 0 {
		i -= len(m.SubPath)
		copy(dAtA[i:], m.SubPath)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.SubPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MountPath) > 0 {
		i -= len(m.MountPath)
		copy(dAtA[i:], m.MountPath)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.MountPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionMethod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionMethod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionMethod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		{
			size := m.Action.Size()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionMethod_Exec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionMethod_Exec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Exec != nil {
		{
			size, err := m.Exec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ActionMethod_Http) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionMethod_Http) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Http != nil {
		{
			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ActionMethod_Socket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionMethod_Socket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Socket != nil {
		{
			size, err := m.Socket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ActionMethod_ActionExec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionMethod_ActionExec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionMethod_ActionExec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		for iNdEx := len(m.Command) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Command[iNdEx])
			copy(dAtA[i:], m.Command[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Command[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionMethod_ActionHTTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionMethod_ActionHTTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionMethod_ActionHTTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCmdPod(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionMethod_ActionSocket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionMethod_ActionSocket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionMethod_ActionSocket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Probe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Probe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Probe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FailureThreshold != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.FailureThreshold))
		i--
		dAtA[i] = 0x30
	}
	if m.SuccessThreshold != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.SuccessThreshold))
		i--
		dAtA[i] = 0x28
	}
	if m.ProbeInterval != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.ProbeInterval))
		i--
		dAtA[i] = 0x20
	}
	if m.ProbeTimeout != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.ProbeTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.InitialDelay != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.InitialDelay))
		i--
		dAtA[i] = 0x10
	}
	if m.Method != nil {
		{
			size, err := m.Method.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HookPostStart != nil {
		{
			size, err := m.HookPostStart.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.Security != nil {
		{
			size, err := m.Security.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.LivenessCheck != nil {
		{
			size, err := m.LivenessCheck.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.ReadinessCheck != nil {
		{
			size, err := m.ReadinessCheck.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Mounts) > 0 {
		for k := range m.Mounts {
			v := m.Mounts[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCmdPod(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.Envs) > 0 {
		for k := range m.Envs {
			v := m.Envs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.Tty {
		i--
		if m.Tty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.StdinOnce {
		i--
		if m.StdinOnce {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Stdin {
		i--
		if m.Stdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.WorkingDir) > 0 {
		i -= len(m.WorkingDir)
		copy(dAtA[i:], m.WorkingDir)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.WorkingDir)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Command) > 0 {
		for iNdEx := len(m.Command) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Command[iNdEx])
			copy(dAtA[i:], m.Command[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Command[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sysctls) > 0 {
		for k := range m.Sysctls {
			v := m.Sysctls[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xfa
		}
	}
	if m.DeletePodOnFailure {
		i--
		if m.DeletePodOnFailure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.VolumeData) > 0 {
		for k := range m.VolumeData {
			v := m.VolumeData[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCmdPod(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.HostPaths) > 0 {
		for k := range m.HostPaths {
			v := m.HostPaths[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.NetworkOptions != nil {
		{
			size, err := m.NetworkOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmdPod(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.DnsOptions) > 0 {
		for iNdEx := len(m.DnsOptions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DnsOptions[iNdEx])
			copy(dAtA[i:], m.DnsOptions[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.DnsOptions[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.Hosts) > 0 {
		for k := range m.Hosts {
			v := m.Hosts[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.SearchDomains) > 0 {
		for iNdEx := len(m.SearchDomains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SearchDomains[iNdEx])
			copy(dAtA[i:], m.SearchDomains[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.SearchDomains[iNdEx])))
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.NameServers) > 0 {
		for iNdEx := len(m.NameServers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NameServers[iNdEx])
			copy(dAtA[i:], m.NameServers[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.NameServers[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.Ports) > 0 {
		for k := range m.Ports {
			v := m.Ports[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCmdPod(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.WaitContainers {
		i--
		if m.WaitContainers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.Containers) > 0 {
		for iNdEx := len(m.Containers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Containers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCmdPod(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.SharePid {
		i--
		if m.SharePid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x42
	}
	if m.HostPid {
		i--
		if m.HostPid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.HostNetwork {
		i--
		if m.HostNetwork {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.HostIpc {
		i--
		if m.HostIpc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.RestartPolicy != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.RestartPolicy))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PodUid) > 0 {
		i -= len(m.PodUid)
		copy(dAtA[i:], m.PodUid)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.PodUid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HookPreStop) > 0 {
		for k := range m.HookPreStop {
			v := m.HookPreStop[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCmdPod(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCmdPod(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCmdPod(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.GraceTime != 0 {
		i = encodeVarintCmdPod(dAtA, i, uint64(m.GraceTime))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Containers) > 0 {
		for iNdEx := len(m.Containers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Containers[iNdEx])
			copy(dAtA[i:], m.Containers[iNdEx])
			i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Containers[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PodUid) > 0 {
		i -= len(m.PodUid)
		copy(dAtA[i:], m.PodUid)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.PodUid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.All {
		i--
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCmdPod(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCmdPod(dAtA []byte, offset int, v uint64) int {
	offset -= sovCmdPod(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PodCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovCmdPod(uint64(m.Action))
	}
	if m.Options != nil {
		n += m.Options.Size()
	}
	return n
}

func (m *PodCmd_SyncOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SyncOptions != nil {
		l = m.SyncOptions.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}
func (m *PodCmd_ImageEnsureOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImageEnsureOptions != nil {
		l = m.ImageEnsureOptions.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}
func (m *PodCmd_CreateOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateOptions != nil {
		l = m.CreateOptions.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}
func (m *PodCmd_DeleteOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteOptions != nil {
		l = m.DeleteOptions.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}
func (m *PodCmd_ListOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ListOptions != nil {
		l = m.ListOptions.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}
func (m *AuthConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Auth)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.ServerAddress)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.IdentityToken)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.RegistryToken)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}

func (m *ImagePull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthConfig != nil {
		l = m.AuthConfig.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.PullPolicy != 0 {
		n += 1 + sovCmdPod(uint64(m.PullPolicy))
	}
	return n
}

func (m *ImageEnsureOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ImagePull) > 0 {
		for k, v := range m.ImagePull {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdPod(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NamedData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DataMap) > 0 {
		for k, v := range m.DataMap {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovCmdPod(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ContainerPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.ContainerPort != 0 {
		n += 1 + sovCmdPod(uint64(m.ContainerPort))
	}
	if m.HostPort != 0 {
		n += 1 + sovCmdPod(uint64(m.HostPort))
	}
	l = len(m.HostIp)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}

func (m *SELinuxOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Level)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}

func (m *SecurityOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Privileged {
		n += 2
	}
	if m.AllowNewPrivileges {
		n += 2
	}
	if m.NonRoot {
		n += 2
	}
	if m.ReadOnlyRootfs {
		n += 2
	}
	if m.User != 0 {
		n += 1 + sovCmdPod(uint64(m.User))
	}
	if m.Group != 0 {
		n += 1 + sovCmdPod(uint64(m.Group))
	}
	if len(m.CapsAdd) > 0 {
		for _, s := range m.CapsAdd {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if len(m.CapsDrop) > 0 {
		for _, s := range m.CapsDrop {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if m.ProcMountKind != 0 {
		n += 1 + sovCmdPod(uint64(m.ProcMountKind))
	}
	if m.SelinuxOptions != nil {
		l = m.SelinuxOptions.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}

func (m *MountOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MountPath)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.SubPath)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.ReadOnly {
		n += 2
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, s := range m.Options {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if m.FileMode != 0 {
		n += 1 + sovCmdPod(uint64(m.FileMode))
	}
	if m.Remote {
		n += 2
	}
	return n
}

func (m *ActionMethod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		n += m.Action.Size()
	}
	return n
}

func (m *ActionMethod_Exec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exec != nil {
		l = m.Exec.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}
func (m *ActionMethod_Http) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}
func (m *ActionMethod_Socket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Socket != nil {
		l = m.Socket.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}
func (m *ActionMethod_ActionExec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	return n
}

func (m *ActionMethod_ActionHTTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	return n
}

func (m *ActionMethod_ActionSocket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	return n
}

func (m *Probe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Method != nil {
		l = m.Method.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.InitialDelay != 0 {
		n += 1 + sovCmdPod(uint64(m.InitialDelay))
	}
	if m.ProbeTimeout != 0 {
		n += 1 + sovCmdPod(uint64(m.ProbeTimeout))
	}
	if m.ProbeInterval != 0 {
		n += 1 + sovCmdPod(uint64(m.ProbeInterval))
	}
	if m.SuccessThreshold != 0 {
		n += 1 + sovCmdPod(uint64(m.SuccessThreshold))
	}
	if m.FailureThreshold != 0 {
		n += 1 + sovCmdPod(uint64(m.FailureThreshold))
	}
	return n
}

func (m *ContainerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	l = len(m.WorkingDir)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.Stdin {
		n += 2
	}
	if m.StdinOnce {
		n += 2
	}
	if m.Tty {
		n += 2
	}
	if len(m.Envs) > 0 {
		for k, v := range m.Envs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + 1 + len(v) + sovCmdPod(uint64(len(v)))
			n += mapEntrySize + 1 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	if len(m.Mounts) > 0 {
		for k, v := range m.Mounts {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdPod(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	if m.ReadinessCheck != nil {
		l = m.ReadinessCheck.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.LivenessCheck != nil {
		l = m.LivenessCheck.Size()
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.Security != nil {
		l = m.Security.Size()
		n += 2 + l + sovCmdPod(uint64(l))
	}
	if m.HookPostStart != nil {
		l = m.HookPostStart.Size()
		n += 2 + l + sovCmdPod(uint64(l))
	}
	return n
}

func (m *CreateOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.RestartPolicy != 0 {
		n += 1 + sovCmdPod(uint64(m.RestartPolicy))
	}
	if m.HostIpc {
		n += 2
	}
	if m.HostNetwork {
		n += 2
	}
	if m.HostPid {
		n += 2
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.SharePid {
		n += 2
	}
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.Size()
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if m.WaitContainers {
		n += 2
	}
	if len(m.Ports) > 0 {
		for k, v := range m.Ports {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdPod(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	if len(m.NameServers) > 0 {
		for _, s := range m.NameServers {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if len(m.SearchDomains) > 0 {
		for _, s := range m.SearchDomains {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if len(m.Hosts) > 0 {
		for k, v := range m.Hosts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + 1 + len(v) + sovCmdPod(uint64(len(v)))
			n += mapEntrySize + 2 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	if len(m.DnsOptions) > 0 {
		for _, s := range m.DnsOptions {
			l = len(s)
			n += 2 + l + sovCmdPod(uint64(l))
		}
	}
	if m.NetworkOptions != nil {
		l = m.NetworkOptions.Size()
		n += 2 + l + sovCmdPod(uint64(l))
	}
	if len(m.HostPaths) > 0 {
		for k, v := range m.HostPaths {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + 1 + len(v) + sovCmdPod(uint64(len(v)))
			n += mapEntrySize + 2 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	if len(m.VolumeData) > 0 {
		for k, v := range m.VolumeData {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdPod(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + 1 + len(v) + sovCmdPod(uint64(len(v)))
			n += mapEntrySize + 2 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	if m.DeletePodOnFailure {
		n += 3
	}
	if len(m.Sysctls) > 0 {
		for k, v := range m.Sysctls {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + 1 + len(v) + sovCmdPod(uint64(len(v)))
			n += mapEntrySize + 2 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DeleteOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if len(m.Containers) > 0 {
		for _, s := range m.Containers {
			l = len(s)
			n += 1 + l + sovCmdPod(uint64(l))
		}
	}
	if m.GraceTime != 0 {
		n += 1 + sovCmdPod(uint64(m.GraceTime))
	}
	if len(m.HookPreStop) > 0 {
		for k, v := range m.HookPreStop {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdPod(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdPod(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdPod(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ListOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCmdPod(uint64(l))
	}
	if m.All {
		n += 2
	}
	return n
}

func sovCmdPod(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCmdPod(x uint64) (n int) {
	return sovCmdPod(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *PodCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`Options:` + fmt.Sprintf("%v", this.Options) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_SyncOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_SyncOptions{`,
		`SyncOptions:` + strings.Replace(fmt.Sprintf("%v", this.SyncOptions), "SyncOptions", "SyncOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_ImageEnsureOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_ImageEnsureOptions{`,
		`ImageEnsureOptions:` + strings.Replace(fmt.Sprintf("%v", this.ImageEnsureOptions), "ImageEnsureOptions", "ImageEnsureOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_CreateOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_CreateOptions{`,
		`CreateOptions:` + strings.Replace(fmt.Sprintf("%v", this.CreateOptions), "CreateOptions", "CreateOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_DeleteOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_DeleteOptions{`,
		`DeleteOptions:` + strings.Replace(fmt.Sprintf("%v", this.DeleteOptions), "DeleteOptions", "DeleteOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_ListOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_ListOptions{`,
		`ListOptions:` + strings.Replace(fmt.Sprintf("%v", this.ListOptions), "ListOptions", "ListOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthConfig{`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`Password:` + fmt.Sprintf("%v", this.Password) + `,`,
		`Auth:` + fmt.Sprintf("%v", this.Auth) + `,`,
		`ServerAddress:` + fmt.Sprintf("%v", this.ServerAddress) + `,`,
		`IdentityToken:` + fmt.Sprintf("%v", this.IdentityToken) + `,`,
		`RegistryToken:` + fmt.Sprintf("%v", this.RegistryToken) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImagePull) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImagePull{`,
		`AuthConfig:` + strings.Replace(this.AuthConfig.String(), "AuthConfig", "AuthConfig", 1) + `,`,
		`PullPolicy:` + fmt.Sprintf("%v", this.PullPolicy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageEnsureOptions) String() string {
	if this == nil {
		return "nil"
	}
	keysForImagePull := make([]string, 0, len(this.ImagePull))
	for k, _ := range this.ImagePull {
		keysForImagePull = append(keysForImagePull, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForImagePull)
	mapStringForImagePull := "map[string]*ImagePull{"
	for _, k := range keysForImagePull {
		mapStringForImagePull += fmt.Sprintf("%v: %v,", k, this.ImagePull[k])
	}
	mapStringForImagePull += "}"
	s := strings.Join([]string{`&ImageEnsureOptions{`,
		`ImagePull:` + mapStringForImagePull + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamedData) String() string {
	if this == nil {
		return "nil"
	}
	keysForDataMap := make([]string, 0, len(this.DataMap))
	for k, _ := range this.DataMap {
		keysForDataMap = append(keysForDataMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDataMap)
	mapStringForDataMap := "map[string][]byte{"
	for _, k := range keysForDataMap {
		mapStringForDataMap += fmt.Sprintf("%v: %v,", k, this.DataMap[k])
	}
	mapStringForDataMap += "}"
	s := strings.Join([]string{`&NamedData{`,
		`DataMap:` + mapStringForDataMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerPort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerPort{`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`ContainerPort:` + fmt.Sprintf("%v", this.ContainerPort) + `,`,
		`HostPort:` + fmt.Sprintf("%v", this.HostPort) + `,`,
		`HostIp:` + fmt.Sprintf("%v", this.HostIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SELinuxOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SELinuxOptions{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Level:` + fmt.Sprintf("%v", this.Level) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityOptions{`,
		`Privileged:` + fmt.Sprintf("%v", this.Privileged) + `,`,
		`AllowNewPrivileges:` + fmt.Sprintf("%v", this.AllowNewPrivileges) + `,`,
		`NonRoot:` + fmt.Sprintf("%v", this.NonRoot) + `,`,
		`ReadOnlyRootfs:` + fmt.Sprintf("%v", this.ReadOnlyRootfs) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`Group:` + fmt.Sprintf("%v", this.Group) + `,`,
		`CapsAdd:` + fmt.Sprintf("%v", this.CapsAdd) + `,`,
		`CapsDrop:` + fmt.Sprintf("%v", this.CapsDrop) + `,`,
		`ProcMountKind:` + fmt.Sprintf("%v", this.ProcMountKind) + `,`,
		`SelinuxOptions:` + strings.Replace(this.SelinuxOptions.String(), "SELinuxOptions", "SELinuxOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MountOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MountOptions{`,
		`MountPath:` + fmt.Sprintf("%v", this.MountPath) + `,`,
		`SubPath:` + fmt.Sprintf("%v", this.SubPath) + `,`,
		`ReadOnly:` + fmt.Sprintf("%v", this.ReadOnly) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Options:` + fmt.Sprintf("%v", this.Options) + `,`,
		`FileMode:` + fmt.Sprintf("%v", this.FileMode) + `,`,
		`Remote:` + fmt.Sprintf("%v", this.Remote) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ActionMethod) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ActionMethod{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ActionMethod_Exec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ActionMethod_Exec{`,
		`Exec:` + strings.Replace(fmt.Sprintf("%v", this.Exec), "ActionMethod_ActionExec", "ActionMethod_ActionExec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ActionMethod_Http) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ActionMethod_Http{`,
		`Http:` + strings.Replace(fmt.Sprintf("%v", this.Http), "ActionMethod_ActionHTTP", "ActionMethod_ActionHTTP", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ActionMethod_Socket) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ActionMethod_Socket{`,
		`Socket:` + strings.Replace(fmt.Sprintf("%v", this.Socket), "ActionMethod_ActionSocket", "ActionMethod_ActionSocket", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ActionMethod_ActionExec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ActionMethod_ActionExec{`,
		`Command:` + fmt.Sprintf("%v", this.Command) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ActionMethod_ActionHTTP) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHeaders := "[]*KeyValuePair{"
	for _, f := range this.Headers {
		repeatedStringForHeaders += strings.Replace(fmt.Sprintf("%v", f), "KeyValuePair", "KeyValuePair", 1) + ","
	}
	repeatedStringForHeaders += "}"
	s := strings.Join([]string{`&ActionMethod_ActionHTTP{`,
		`Method:` + fmt.Sprintf("%v", this.Method) + `,`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`Headers:` + repeatedStringForHeaders + `,`,
		`}`,
	}, "")
	return s
}
func (this *ActionMethod_ActionSocket) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ActionMethod_ActionSocket{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Probe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Probe{`,
		`Method:` + strings.Replace(this.Method.String(), "ActionMethod", "ActionMethod", 1) + `,`,
		`InitialDelay:` + fmt.Sprintf("%v", this.InitialDelay) + `,`,
		`ProbeTimeout:` + fmt.Sprintf("%v", this.ProbeTimeout) + `,`,
		`ProbeInterval:` + fmt.Sprintf("%v", this.ProbeInterval) + `,`,
		`SuccessThreshold:` + fmt.Sprintf("%v", this.SuccessThreshold) + `,`,
		`FailureThreshold:` + fmt.Sprintf("%v", this.FailureThreshold) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerSpec) String() string {
	if this == nil {
		return "nil"
	}
	keysForEnvs := make([]string, 0, len(this.Envs))
	for k, _ := range this.Envs {
		keysForEnvs = append(keysForEnvs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEnvs)
	mapStringForEnvs := "map[string]string{"
	for _, k := range keysForEnvs {
		mapStringForEnvs += fmt.Sprintf("%v: %v,", k, this.Envs[k])
	}
	mapStringForEnvs += "}"
	keysForMounts := make([]string, 0, len(this.Mounts))
	for k, _ := range this.Mounts {
		keysForMounts = append(keysForMounts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMounts)
	mapStringForMounts := "map[string]*MountOptions{"
	for _, k := range keysForMounts {
		mapStringForMounts += fmt.Sprintf("%v: %v,", k, this.Mounts[k])
	}
	mapStringForMounts += "}"
	s := strings.Join([]string{`&ContainerSpec{`,
		`Image:` + fmt.Sprintf("%v", this.Image) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Command:` + fmt.Sprintf("%v", this.Command) + `,`,
		`Args:` + fmt.Sprintf("%v", this.Args) + `,`,
		`WorkingDir:` + fmt.Sprintf("%v", this.WorkingDir) + `,`,
		`Stdin:` + fmt.Sprintf("%v", this.Stdin) + `,`,
		`StdinOnce:` + fmt.Sprintf("%v", this.StdinOnce) + `,`,
		`Tty:` + fmt.Sprintf("%v", this.Tty) + `,`,
		`Envs:` + mapStringForEnvs + `,`,
		`Mounts:` + mapStringForMounts + `,`,
		`ReadinessCheck:` + strings.Replace(this.ReadinessCheck.String(), "Probe", "Probe", 1) + `,`,
		`LivenessCheck:` + strings.Replace(this.LivenessCheck.String(), "Probe", "Probe", 1) + `,`,
		`Security:` + strings.Replace(this.Security.String(), "SecurityOptions", "SecurityOptions", 1) + `,`,
		`HookPostStart:` + strings.Replace(this.HookPostStart.String(), "ActionMethod", "ActionMethod", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateOptions) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForContainers := "[]*ContainerSpec{"
	for _, f := range this.Containers {
		repeatedStringForContainers += strings.Replace(f.String(), "ContainerSpec", "ContainerSpec", 1) + ","
	}
	repeatedStringForContainers += "}"
	keysForPorts := make([]string, 0, len(this.Ports))
	for k, _ := range this.Ports {
		keysForPorts = append(keysForPorts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPorts)
	mapStringForPorts := "map[string]*ContainerPort{"
	for _, k := range keysForPorts {
		mapStringForPorts += fmt.Sprintf("%v: %v,", k, this.Ports[k])
	}
	mapStringForPorts += "}"
	keysForHosts := make([]string, 0, len(this.Hosts))
	for k, _ := range this.Hosts {
		keysForHosts = append(keysForHosts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHosts)
	mapStringForHosts := "map[string]string{"
	for _, k := range keysForHosts {
		mapStringForHosts += fmt.Sprintf("%v: %v,", k, this.Hosts[k])
	}
	mapStringForHosts += "}"
	keysForHostPaths := make([]string, 0, len(this.HostPaths))
	for k, _ := range this.HostPaths {
		keysForHostPaths = append(keysForHostPaths, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHostPaths)
	mapStringForHostPaths := "map[string]string{"
	for _, k := range keysForHostPaths {
		mapStringForHostPaths += fmt.Sprintf("%v: %v,", k, this.HostPaths[k])
	}
	mapStringForHostPaths += "}"
	keysForVolumeData := make([]string, 0, len(this.VolumeData))
	for k, _ := range this.VolumeData {
		keysForVolumeData = append(keysForVolumeData, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVolumeData)
	mapStringForVolumeData := "map[string]*NamedData{"
	for _, k := range keysForVolumeData {
		mapStringForVolumeData += fmt.Sprintf("%v: %v,", k, this.VolumeData[k])
	}
	mapStringForVolumeData += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForSysctls := make([]string, 0, len(this.Sysctls))
	for k, _ := range this.Sysctls {
		keysForSysctls = append(keysForSysctls, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSysctls)
	mapStringForSysctls := "map[string]string{"
	for _, k := range keysForSysctls {
		mapStringForSysctls += fmt.Sprintf("%v: %v,", k, this.Sysctls[k])
	}
	mapStringForSysctls += "}"
	s := strings.Join([]string{`&CreateOptions{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`RestartPolicy:` + fmt.Sprintf("%v", this.RestartPolicy) + `,`,
		`HostIpc:` + fmt.Sprintf("%v", this.HostIpc) + `,`,
		`HostNetwork:` + fmt.Sprintf("%v", this.HostNetwork) + `,`,
		`HostPid:` + fmt.Sprintf("%v", this.HostPid) + `,`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`SharePid:` + fmt.Sprintf("%v", this.SharePid) + `,`,
		`Containers:` + repeatedStringForContainers + `,`,
		`WaitContainers:` + fmt.Sprintf("%v", this.WaitContainers) + `,`,
		`Ports:` + mapStringForPorts + `,`,
		`NameServers:` + fmt.Sprintf("%v", this.NameServers) + `,`,
		`SearchDomains:` + fmt.Sprintf("%v", this.SearchDomains) + `,`,
		`Hosts:` + mapStringForHosts + `,`,
		`DnsOptions:` + fmt.Sprintf("%v", this.DnsOptions) + `,`,
		`NetworkOptions:` + strings.Replace(fmt.Sprintf("%v", this.NetworkOptions), "NetworkOptions", "NetworkOptions", 1) + `,`,
		`HostPaths:` + mapStringForHostPaths + `,`,
		`VolumeData:` + mapStringForVolumeData + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`DeletePodOnFailure:` + fmt.Sprintf("%v", this.DeletePodOnFailure) + `,`,
		`Sysctls:` + mapStringForSysctls + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteOptions) String() string {
	if this == nil {
		return "nil"
	}
	keysForHookPreStop := make([]string, 0, len(this.HookPreStop))
	for k, _ := range this.HookPreStop {
		keysForHookPreStop = append(keysForHookPreStop, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHookPreStop)
	mapStringForHookPreStop := "map[string]*ActionMethod{"
	for _, k := range keysForHookPreStop {
		mapStringForHookPreStop += fmt.Sprintf("%v: %v,", k, this.HookPreStop[k])
	}
	mapStringForHookPreStop += "}"
	s := strings.Join([]string{`&DeleteOptions{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Containers:` + fmt.Sprintf("%v", this.Containers) + `,`,
		`GraceTime:` + fmt.Sprintf("%v", this.GraceTime) + `,`,
		`HookPreStop:` + mapStringForHookPreStop + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListOptions{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`All:` + fmt.Sprintf("%v", this.All) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCmdPod(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *PodCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= PodCmd_Action(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SyncOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_SyncOptions{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageEnsureOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ImageEnsureOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_ImageEnsureOptions{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_CreateOptions{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_DeleteOptions{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ListOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_ListOptions{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Auth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdentityToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistryToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegistryToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImagePull) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImagePull: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImagePull: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthConfig == nil {
				m.AuthConfig = &AuthConfig{}
			}
			if err := m.AuthConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PullPolicy", wireType)
			}
			m.PullPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PullPolicy |= ImagePullPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageEnsureOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageEnsureOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageEnsureOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePull", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImagePull == nil {
				m.ImagePull = make(map[string]*ImagePull)
			}
			var mapkey string
			var mapvalue *ImagePull
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdPod
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ImagePull{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ImagePull[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataMap == nil {
				m.DataMap = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthCmdPod
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DataMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPort", wireType)
			}
			m.ContainerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			m.HostPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SELinuxOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SELinuxOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SELinuxOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowNewPrivileges", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowNewPrivileges = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonRoot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NonRoot = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnlyRootfs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnlyRootfs = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			m.User = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.User |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapsAdd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapsAdd = append(m.CapsAdd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapsDrop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapsDrop = append(m.CapsDrop, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcMountKind", wireType)
			}
			m.ProcMountKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcMountKind |= SecurityOptions_ProcMountKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelinuxOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SelinuxOptions == nil {
				m.SelinuxOptions = &SELinuxOptions{}
			}
			if err := m.SelinuxOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MountOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MountOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MountOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMode", wireType)
			}
			m.FileMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileMode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remote", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remote = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionMethod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionMethod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionMethod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActionMethod_ActionExec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionMethod_Exec{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActionMethod_ActionHTTP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionMethod_Http{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Socket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActionMethod_ActionSocket{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionMethod_Socket{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionMethod_ActionExec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionExec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionExec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionMethod_ActionHTTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionHTTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionHTTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &KeyValuePair{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionMethod_ActionSocket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionSocket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionSocket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Probe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Probe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Probe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Method == nil {
				m.Method = &ActionMethod{}
			}
			if err := m.Method.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialDelay", wireType)
			}
			m.InitialDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialDelay |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbeTimeout", wireType)
			}
			m.ProbeTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProbeTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbeInterval", wireType)
			}
			m.ProbeInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProbeInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessThreshold", wireType)
			}
			m.SuccessThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccessThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureThreshold", wireType)
			}
			m.FailureThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FailureThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkingDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stdin = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdinOnce", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StdinOnce = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tty = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Envs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Envs == nil {
				m.Envs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Envs[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mounts == nil {
				m.Mounts = make(map[string]*MountOptions)
			}
			var mapkey string
			var mapvalue *MountOptions
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdPod
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MountOptions{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Mounts[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadinessCheck == nil {
				m.ReadinessCheck = &Probe{}
			}
			if err := m.ReadinessCheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivenessCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LivenessCheck == nil {
				m.LivenessCheck = &Probe{}
			}
			if err := m.LivenessCheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Security == nil {
				m.Security = &SecurityOptions{}
			}
			if err := m.Security.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HookPostStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HookPostStart == nil {
				m.HookPostStart = &ActionMethod{}
			}
			if err := m.HookPostStart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartPolicy", wireType)
			}
			m.RestartPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestartPolicy |= RestartPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIpc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostIpc = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostNetwork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostNetwork = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostPid = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SharePid = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, &ContainerSpec{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitContainers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WaitContainers = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ports == nil {
				m.Ports = make(map[string]*ContainerPort)
			}
			var mapkey string
			var mapvalue *ContainerPort
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdPod
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ContainerPort{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ports[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameServers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameServers = append(m.NameServers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchDomains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchDomains = append(m.SearchDomains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hosts == nil {
				m.Hosts = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Hosts[mapkey] = mapvalue
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsOptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsOptions = append(m.DnsOptions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkOptions == nil {
				m.NetworkOptions = &NetworkOptions{}
			}
			if err := m.NetworkOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HostPaths == nil {
				m.HostPaths = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HostPaths[mapkey] = mapvalue
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeData == nil {
				m.VolumeData = make(map[string]*NamedData)
			}
			var mapkey string
			var mapvalue *NamedData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdPod
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NamedData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VolumeData[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletePodOnFailure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeletePodOnFailure = bool(v != 0)
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sysctls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sysctls == nil {
				m.Sysctls = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sysctls[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraceTime", wireType)
			}
			m.GraceTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GraceTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HookPreStop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HookPreStop == nil {
				m.HookPreStop = make(map[string]*ActionMethod)
			}
			var mapkey string
			var mapvalue *ActionMethod
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdPod
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdPod
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdPod
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdPod
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ActionMethod{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdPod(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdPod
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HookPreStop[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdPod
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdPod
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCmdPod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdPod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCmdPod(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCmdPod
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmdPod
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCmdPod
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCmdPod
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCmdPod
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCmdPod        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCmdPod          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCmdPod = fmt.Errorf("proto: unexpected end of group")
)
