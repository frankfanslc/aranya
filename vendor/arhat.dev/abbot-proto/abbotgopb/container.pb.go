// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: container.proto

package abbotgopb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CNI capabilities args
// https://github.com/containernetworking/cni/blob/master/CONVENTIONS.md#well-known-capabilities
type CNICapArgs struct {
	// Types that are valid to be assigned to Option:
	//	*CNICapArgs_PortMapArg
	//	*CNICapArgs_BandwidthArg
	//	*CNICapArgs_IpRangeArg
	//	*CNICapArgs_DnsConfigArg
	//	*CNICapArgs_IpAddressesArg
	//	*CNICapArgs_MacAddressArg
	//	*CNICapArgs_InfinibandGuidArg
	//	*CNICapArgs_DeviceIdArg
	Option isCNICapArgs_Option `protobuf_oneof:"option"`
}

func (m *CNICapArgs) Reset()      { *m = CNICapArgs{} }
func (*CNICapArgs) ProtoMessage() {}
func (*CNICapArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{0}
}
func (m *CNICapArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNICapArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNICapArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNICapArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNICapArgs.Merge(m, src)
}
func (m *CNICapArgs) XXX_Size() int {
	return m.Size()
}
func (m *CNICapArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_CNICapArgs.DiscardUnknown(m)
}

var xxx_messageInfo_CNICapArgs proto.InternalMessageInfo

type isCNICapArgs_Option interface {
	isCNICapArgs_Option()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CNICapArgs_PortMapArg struct {
	PortMapArg *CNICapArgs_PortMap `protobuf:"bytes,1,opt,name=port_map_arg,json=portMapArg,proto3,oneof" json:"port_map_arg,omitempty"`
}
type CNICapArgs_BandwidthArg struct {
	BandwidthArg *CNICapArgs_Bandwidth `protobuf:"bytes,2,opt,name=bandwidth_arg,json=bandwidthArg,proto3,oneof" json:"bandwidth_arg,omitempty"`
}
type CNICapArgs_IpRangeArg struct {
	IpRangeArg *CNICapArgs_IPRange `protobuf:"bytes,3,opt,name=ip_range_arg,json=ipRangeArg,proto3,oneof" json:"ip_range_arg,omitempty"`
}
type CNICapArgs_DnsConfigArg struct {
	DnsConfigArg *CNICapArgs_DNSConfig `protobuf:"bytes,4,opt,name=dns_config_arg,json=dnsConfigArg,proto3,oneof" json:"dns_config_arg,omitempty"`
}
type CNICapArgs_IpAddressesArg struct {
	IpAddressesArg *CNICapArgs_IPAddresses `protobuf:"bytes,5,opt,name=ip_addresses_arg,json=ipAddressesArg,proto3,oneof" json:"ip_addresses_arg,omitempty"`
}
type CNICapArgs_MacAddressArg struct {
	MacAddressArg *CNICapArgs_MacAddress `protobuf:"bytes,6,opt,name=mac_address_arg,json=macAddressArg,proto3,oneof" json:"mac_address_arg,omitempty"`
}
type CNICapArgs_InfinibandGuidArg struct {
	InfinibandGuidArg *CNICapArgs_InfinibandGUID `protobuf:"bytes,7,opt,name=infiniband_guid_arg,json=infinibandGuidArg,proto3,oneof" json:"infiniband_guid_arg,omitempty"`
}
type CNICapArgs_DeviceIdArg struct {
	DeviceIdArg *CNICapArgs_DeviceID `protobuf:"bytes,8,opt,name=device_id_arg,json=deviceIdArg,proto3,oneof" json:"device_id_arg,omitempty"`
}

func (*CNICapArgs_PortMapArg) isCNICapArgs_Option()        {}
func (*CNICapArgs_BandwidthArg) isCNICapArgs_Option()      {}
func (*CNICapArgs_IpRangeArg) isCNICapArgs_Option()        {}
func (*CNICapArgs_DnsConfigArg) isCNICapArgs_Option()      {}
func (*CNICapArgs_IpAddressesArg) isCNICapArgs_Option()    {}
func (*CNICapArgs_MacAddressArg) isCNICapArgs_Option()     {}
func (*CNICapArgs_InfinibandGuidArg) isCNICapArgs_Option() {}
func (*CNICapArgs_DeviceIdArg) isCNICapArgs_Option()       {}

func (m *CNICapArgs) GetOption() isCNICapArgs_Option {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *CNICapArgs) GetPortMapArg() *CNICapArgs_PortMap {
	if x, ok := m.GetOption().(*CNICapArgs_PortMapArg); ok {
		return x.PortMapArg
	}
	return nil
}

func (m *CNICapArgs) GetBandwidthArg() *CNICapArgs_Bandwidth {
	if x, ok := m.GetOption().(*CNICapArgs_BandwidthArg); ok {
		return x.BandwidthArg
	}
	return nil
}

func (m *CNICapArgs) GetIpRangeArg() *CNICapArgs_IPRange {
	if x, ok := m.GetOption().(*CNICapArgs_IpRangeArg); ok {
		return x.IpRangeArg
	}
	return nil
}

func (m *CNICapArgs) GetDnsConfigArg() *CNICapArgs_DNSConfig {
	if x, ok := m.GetOption().(*CNICapArgs_DnsConfigArg); ok {
		return x.DnsConfigArg
	}
	return nil
}

func (m *CNICapArgs) GetIpAddressesArg() *CNICapArgs_IPAddresses {
	if x, ok := m.GetOption().(*CNICapArgs_IpAddressesArg); ok {
		return x.IpAddressesArg
	}
	return nil
}

func (m *CNICapArgs) GetMacAddressArg() *CNICapArgs_MacAddress {
	if x, ok := m.GetOption().(*CNICapArgs_MacAddressArg); ok {
		return x.MacAddressArg
	}
	return nil
}

func (m *CNICapArgs) GetInfinibandGuidArg() *CNICapArgs_InfinibandGUID {
	if x, ok := m.GetOption().(*CNICapArgs_InfinibandGuidArg); ok {
		return x.InfinibandGuidArg
	}
	return nil
}

func (m *CNICapArgs) GetDeviceIdArg() *CNICapArgs_DeviceID {
	if x, ok := m.GetOption().(*CNICapArgs_DeviceIdArg); ok {
		return x.DeviceIdArg
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CNICapArgs) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CNICapArgs_PortMapArg)(nil),
		(*CNICapArgs_BandwidthArg)(nil),
		(*CNICapArgs_IpRangeArg)(nil),
		(*CNICapArgs_DnsConfigArg)(nil),
		(*CNICapArgs_IpAddressesArg)(nil),
		(*CNICapArgs_MacAddressArg)(nil),
		(*CNICapArgs_InfinibandGuidArg)(nil),
		(*CNICapArgs_DeviceIdArg)(nil),
	}
}

type CNICapArgs_PortMap struct {
	ContainerPort int32  `protobuf:"varint,1,opt,name=container_port,json=containerPort,proto3" json:"containerPort"`
	HostPort      int32  `protobuf:"varint,2,opt,name=host_port,json=hostPort,proto3" json:"hostPort"`
	Protocol      string `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol"`
	HostIp        string `protobuf:"bytes,4,opt,name=host_ip,json=hostIp,proto3" json:"hostIP"`
}

func (m *CNICapArgs_PortMap) Reset()      { *m = CNICapArgs_PortMap{} }
func (*CNICapArgs_PortMap) ProtoMessage() {}
func (*CNICapArgs_PortMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{0, 0}
}
func (m *CNICapArgs_PortMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNICapArgs_PortMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNICapArgs_PortMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNICapArgs_PortMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNICapArgs_PortMap.Merge(m, src)
}
func (m *CNICapArgs_PortMap) XXX_Size() int {
	return m.Size()
}
func (m *CNICapArgs_PortMap) XXX_DiscardUnknown() {
	xxx_messageInfo_CNICapArgs_PortMap.DiscardUnknown(m)
}

var xxx_messageInfo_CNICapArgs_PortMap proto.InternalMessageInfo

func (m *CNICapArgs_PortMap) GetContainerPort() int32 {
	if m != nil {
		return m.ContainerPort
	}
	return 0
}

func (m *CNICapArgs_PortMap) GetHostPort() int32 {
	if m != nil {
		return m.HostPort
	}
	return 0
}

func (m *CNICapArgs_PortMap) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *CNICapArgs_PortMap) GetHostIp() string {
	if m != nil {
		return m.HostIp
	}
	return ""
}

type CNICapArgs_Bandwidth struct {
	IngressRate  int32 `protobuf:"varint,1,opt,name=ingress_rate,json=ingressRate,proto3" json:"ingressRate,omitempty"`
	IngressBurst int32 `protobuf:"varint,2,opt,name=ingress_burst,json=ingressBurst,proto3" json:"ingressBurst,omitempty"`
	EgressRate   int32 `protobuf:"varint,3,opt,name=egress_rate,json=egressRate,proto3" json:"egressRate,omitempty"`
	EgressBurst  int32 `protobuf:"varint,4,opt,name=egress_burst,json=egressBurst,proto3" json:"egressBurst,omitempty"`
}

func (m *CNICapArgs_Bandwidth) Reset()      { *m = CNICapArgs_Bandwidth{} }
func (*CNICapArgs_Bandwidth) ProtoMessage() {}
func (*CNICapArgs_Bandwidth) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{0, 1}
}
func (m *CNICapArgs_Bandwidth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNICapArgs_Bandwidth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNICapArgs_Bandwidth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNICapArgs_Bandwidth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNICapArgs_Bandwidth.Merge(m, src)
}
func (m *CNICapArgs_Bandwidth) XXX_Size() int {
	return m.Size()
}
func (m *CNICapArgs_Bandwidth) XXX_DiscardUnknown() {
	xxx_messageInfo_CNICapArgs_Bandwidth.DiscardUnknown(m)
}

var xxx_messageInfo_CNICapArgs_Bandwidth proto.InternalMessageInfo

func (m *CNICapArgs_Bandwidth) GetIngressRate() int32 {
	if m != nil {
		return m.IngressRate
	}
	return 0
}

func (m *CNICapArgs_Bandwidth) GetIngressBurst() int32 {
	if m != nil {
		return m.IngressBurst
	}
	return 0
}

func (m *CNICapArgs_Bandwidth) GetEgressRate() int32 {
	if m != nil {
		return m.EgressRate
	}
	return 0
}

func (m *CNICapArgs_Bandwidth) GetEgressBurst() int32 {
	if m != nil {
		return m.EgressBurst
	}
	return 0
}

type CNICapArgs_IPRange struct {
	Subnet     string `protobuf:"bytes,1,opt,name=subnet,proto3" json:"subnet"`
	RangeStart string `protobuf:"bytes,2,opt,name=range_start,json=rangeStart,proto3" json:"rangeStart,omitempty"`
	RangeEnd   string `protobuf:"bytes,3,opt,name=range_end,json=rangeEnd,proto3" json:"rangeEnd,omitempty"`
	Gateway    string `protobuf:"bytes,4,opt,name=gateway,proto3" json:"gateway,omitempty"`
}

func (m *CNICapArgs_IPRange) Reset()      { *m = CNICapArgs_IPRange{} }
func (*CNICapArgs_IPRange) ProtoMessage() {}
func (*CNICapArgs_IPRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{0, 2}
}
func (m *CNICapArgs_IPRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNICapArgs_IPRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNICapArgs_IPRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNICapArgs_IPRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNICapArgs_IPRange.Merge(m, src)
}
func (m *CNICapArgs_IPRange) XXX_Size() int {
	return m.Size()
}
func (m *CNICapArgs_IPRange) XXX_DiscardUnknown() {
	xxx_messageInfo_CNICapArgs_IPRange.DiscardUnknown(m)
}

var xxx_messageInfo_CNICapArgs_IPRange proto.InternalMessageInfo

func (m *CNICapArgs_IPRange) GetSubnet() string {
	if m != nil {
		return m.Subnet
	}
	return ""
}

func (m *CNICapArgs_IPRange) GetRangeStart() string {
	if m != nil {
		return m.RangeStart
	}
	return ""
}

func (m *CNICapArgs_IPRange) GetRangeEnd() string {
	if m != nil {
		return m.RangeEnd
	}
	return ""
}

func (m *CNICapArgs_IPRange) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

type CNICapArgs_DNSConfig struct {
	Servers  []string `protobuf:"bytes,1,rep,name=servers,proto3" json:"servers,omitempty"`
	Searches []string `protobuf:"bytes,2,rep,name=searches,proto3" json:"searches,omitempty"`
	Options  []string `protobuf:"bytes,3,rep,name=options,proto3" json:"options,omitempty"`
}

func (m *CNICapArgs_DNSConfig) Reset()      { *m = CNICapArgs_DNSConfig{} }
func (*CNICapArgs_DNSConfig) ProtoMessage() {}
func (*CNICapArgs_DNSConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{0, 3}
}
func (m *CNICapArgs_DNSConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNICapArgs_DNSConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNICapArgs_DNSConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNICapArgs_DNSConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNICapArgs_DNSConfig.Merge(m, src)
}
func (m *CNICapArgs_DNSConfig) XXX_Size() int {
	return m.Size()
}
func (m *CNICapArgs_DNSConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CNICapArgs_DNSConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CNICapArgs_DNSConfig proto.InternalMessageInfo

func (m *CNICapArgs_DNSConfig) GetServers() []string {
	if m != nil {
		return m.Servers
	}
	return nil
}

func (m *CNICapArgs_DNSConfig) GetSearches() []string {
	if m != nil {
		return m.Searches
	}
	return nil
}

func (m *CNICapArgs_DNSConfig) GetOptions() []string {
	if m != nil {
		return m.Options
	}
	return nil
}

type CNICapArgs_IPAddresses struct {
	Ips []string `protobuf:"bytes,1,rep,name=ips,proto3" json:"ips,omitempty"`
}

func (m *CNICapArgs_IPAddresses) Reset()      { *m = CNICapArgs_IPAddresses{} }
func (*CNICapArgs_IPAddresses) ProtoMessage() {}
func (*CNICapArgs_IPAddresses) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{0, 4}
}
func (m *CNICapArgs_IPAddresses) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNICapArgs_IPAddresses) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNICapArgs_IPAddresses.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNICapArgs_IPAddresses) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNICapArgs_IPAddresses.Merge(m, src)
}
func (m *CNICapArgs_IPAddresses) XXX_Size() int {
	return m.Size()
}
func (m *CNICapArgs_IPAddresses) XXX_DiscardUnknown() {
	xxx_messageInfo_CNICapArgs_IPAddresses.DiscardUnknown(m)
}

var xxx_messageInfo_CNICapArgs_IPAddresses proto.InternalMessageInfo

func (m *CNICapArgs_IPAddresses) GetIps() []string {
	if m != nil {
		return m.Ips
	}
	return nil
}

type CNICapArgs_MacAddress struct {
	Mac string `protobuf:"bytes,1,opt,name=mac,proto3" json:"mac,omitempty"`
}

func (m *CNICapArgs_MacAddress) Reset()      { *m = CNICapArgs_MacAddress{} }
func (*CNICapArgs_MacAddress) ProtoMessage() {}
func (*CNICapArgs_MacAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{0, 5}
}
func (m *CNICapArgs_MacAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNICapArgs_MacAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNICapArgs_MacAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNICapArgs_MacAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNICapArgs_MacAddress.Merge(m, src)
}
func (m *CNICapArgs_MacAddress) XXX_Size() int {
	return m.Size()
}
func (m *CNICapArgs_MacAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_CNICapArgs_MacAddress.DiscardUnknown(m)
}

var xxx_messageInfo_CNICapArgs_MacAddress proto.InternalMessageInfo

func (m *CNICapArgs_MacAddress) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

type CNICapArgs_InfinibandGUID struct {
	InfinibandGuid string `protobuf:"bytes,1,opt,name=infiniband_guid,json=infinibandGuid,proto3" json:"infinibandGUID,omitempty"`
}

func (m *CNICapArgs_InfinibandGUID) Reset()      { *m = CNICapArgs_InfinibandGUID{} }
func (*CNICapArgs_InfinibandGUID) ProtoMessage() {}
func (*CNICapArgs_InfinibandGUID) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{0, 6}
}
func (m *CNICapArgs_InfinibandGUID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNICapArgs_InfinibandGUID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNICapArgs_InfinibandGUID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNICapArgs_InfinibandGUID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNICapArgs_InfinibandGUID.Merge(m, src)
}
func (m *CNICapArgs_InfinibandGUID) XXX_Size() int {
	return m.Size()
}
func (m *CNICapArgs_InfinibandGUID) XXX_DiscardUnknown() {
	xxx_messageInfo_CNICapArgs_InfinibandGUID.DiscardUnknown(m)
}

var xxx_messageInfo_CNICapArgs_InfinibandGUID proto.InternalMessageInfo

func (m *CNICapArgs_InfinibandGUID) GetInfinibandGuid() string {
	if m != nil {
		return m.InfinibandGuid
	}
	return ""
}

type CNICapArgs_DeviceID struct {
	DeviceId string `protobuf:"bytes,1,opt,name=device_id,json=deviceId,proto3" json:"deviceID,omitempty"`
}

func (m *CNICapArgs_DeviceID) Reset()      { *m = CNICapArgs_DeviceID{} }
func (*CNICapArgs_DeviceID) ProtoMessage() {}
func (*CNICapArgs_DeviceID) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{0, 7}
}
func (m *CNICapArgs_DeviceID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNICapArgs_DeviceID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNICapArgs_DeviceID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNICapArgs_DeviceID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNICapArgs_DeviceID.Merge(m, src)
}
func (m *CNICapArgs_DeviceID) XXX_Size() int {
	return m.Size()
}
func (m *CNICapArgs_DeviceID) XXX_DiscardUnknown() {
	xxx_messageInfo_CNICapArgs_DeviceID.DiscardUnknown(m)
}

var xxx_messageInfo_CNICapArgs_DeviceID proto.InternalMessageInfo

func (m *CNICapArgs_DeviceID) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

type ContainerNetworkEnsureRequest struct {
	// (required) container id
	ContainerId string `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	// (required) pid will be used to form the netns path (/proc/<pid>/ns/net)
	Pid uint32 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
	// (optional) capabilities args
	CapArgs []*CNICapArgs `protobuf:"bytes,3,rep,name=cap_args,json=capArgs,proto3" json:"cap_args,omitempty"`
	// (optional) cni_args
	// https://github.com/containernetworking/cni/blob/master/CONVENTIONS.md#cni_args
	CniArgs map[string]string `protobuf:"bytes,4,rep,name=cni_args,json=cniArgs,proto3" json:"cni_args,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ContainerNetworkEnsureRequest) Reset()      { *m = ContainerNetworkEnsureRequest{} }
func (*ContainerNetworkEnsureRequest) ProtoMessage() {}
func (*ContainerNetworkEnsureRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{1}
}
func (m *ContainerNetworkEnsureRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerNetworkEnsureRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerNetworkEnsureRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerNetworkEnsureRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerNetworkEnsureRequest.Merge(m, src)
}
func (m *ContainerNetworkEnsureRequest) XXX_Size() int {
	return m.Size()
}
func (m *ContainerNetworkEnsureRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerNetworkEnsureRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerNetworkEnsureRequest proto.InternalMessageInfo

func (m *ContainerNetworkEnsureRequest) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

func (m *ContainerNetworkEnsureRequest) GetPid() uint32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *ContainerNetworkEnsureRequest) GetCapArgs() []*CNICapArgs {
	if m != nil {
		return m.CapArgs
	}
	return nil
}

func (m *ContainerNetworkEnsureRequest) GetCniArgs() map[string]string {
	if m != nil {
		return m.CniArgs
	}
	return nil
}

// Restore container network with previous container config
type ContainerNetworkRestoreRequest struct {
	// (required) container id
	ContainerId string `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	// (required) pid to generate netns path
	Pid uint32 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
}

func (m *ContainerNetworkRestoreRequest) Reset()      { *m = ContainerNetworkRestoreRequest{} }
func (*ContainerNetworkRestoreRequest) ProtoMessage() {}
func (*ContainerNetworkRestoreRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{2}
}
func (m *ContainerNetworkRestoreRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerNetworkRestoreRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerNetworkRestoreRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerNetworkRestoreRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerNetworkRestoreRequest.Merge(m, src)
}
func (m *ContainerNetworkRestoreRequest) XXX_Size() int {
	return m.Size()
}
func (m *ContainerNetworkRestoreRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerNetworkRestoreRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerNetworkRestoreRequest proto.InternalMessageInfo

func (m *ContainerNetworkRestoreRequest) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

func (m *ContainerNetworkRestoreRequest) GetPid() uint32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

type ContainerNetworkDeleteRequest struct {
	// (required) container id
	ContainerId string `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	// (required) pid will be used to form the netns path (/proc/<pid>/ns/net)
	Pid uint32 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
}

func (m *ContainerNetworkDeleteRequest) Reset()      { *m = ContainerNetworkDeleteRequest{} }
func (*ContainerNetworkDeleteRequest) ProtoMessage() {}
func (*ContainerNetworkDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{3}
}
func (m *ContainerNetworkDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerNetworkDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerNetworkDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerNetworkDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerNetworkDeleteRequest.Merge(m, src)
}
func (m *ContainerNetworkDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *ContainerNetworkDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerNetworkDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerNetworkDeleteRequest proto.InternalMessageInfo

func (m *ContainerNetworkDeleteRequest) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

func (m *ContainerNetworkDeleteRequest) GetPid() uint32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

// Update CNI config by rendering the config template predefined in abbot's config
// this Request containes all variables supported in the config template
type ContainerNetworkConfigEnsureRequest struct {
	Ipv4Subnet string `protobuf:"bytes,1,opt,name=ipv4_subnet,json=ipv4Subnet,proto3" json:"ipv4_subnet,omitempty"`
	Ipv6Subnet string `protobuf:"bytes,2,opt,name=ipv6_subnet,json=ipv6Subnet,proto3" json:"ipv6_subnet,omitempty"`
}

func (m *ContainerNetworkConfigEnsureRequest) Reset()      { *m = ContainerNetworkConfigEnsureRequest{} }
func (*ContainerNetworkConfigEnsureRequest) ProtoMessage() {}
func (*ContainerNetworkConfigEnsureRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{4}
}
func (m *ContainerNetworkConfigEnsureRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerNetworkConfigEnsureRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerNetworkConfigEnsureRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerNetworkConfigEnsureRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerNetworkConfigEnsureRequest.Merge(m, src)
}
func (m *ContainerNetworkConfigEnsureRequest) XXX_Size() int {
	return m.Size()
}
func (m *ContainerNetworkConfigEnsureRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerNetworkConfigEnsureRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerNetworkConfigEnsureRequest proto.InternalMessageInfo

func (m *ContainerNetworkConfigEnsureRequest) GetIpv4Subnet() string {
	if m != nil {
		return m.Ipv4Subnet
	}
	return ""
}

func (m *ContainerNetworkConfigEnsureRequest) GetIpv6Subnet() string {
	if m != nil {
		return m.Ipv6Subnet
	}
	return ""
}

type ContainerNetworkConfigQueryRequest struct {
}

func (m *ContainerNetworkConfigQueryRequest) Reset()      { *m = ContainerNetworkConfigQueryRequest{} }
func (*ContainerNetworkConfigQueryRequest) ProtoMessage() {}
func (*ContainerNetworkConfigQueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{5}
}
func (m *ContainerNetworkConfigQueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerNetworkConfigQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerNetworkConfigQueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerNetworkConfigQueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerNetworkConfigQueryRequest.Merge(m, src)
}
func (m *ContainerNetworkConfigQueryRequest) XXX_Size() int {
	return m.Size()
}
func (m *ContainerNetworkConfigQueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerNetworkConfigQueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerNetworkConfigQueryRequest proto.InternalMessageInfo

type ContainerNetworkQueryRequest struct {
	// (optional) conainer id of the infra container
	ContainerId string `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	// (optional) pid of the infra container
	Pid uint32 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
}

func (m *ContainerNetworkQueryRequest) Reset()      { *m = ContainerNetworkQueryRequest{} }
func (*ContainerNetworkQueryRequest) ProtoMessage() {}
func (*ContainerNetworkQueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{6}
}
func (m *ContainerNetworkQueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerNetworkQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerNetworkQueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerNetworkQueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerNetworkQueryRequest.Merge(m, src)
}
func (m *ContainerNetworkQueryRequest) XXX_Size() int {
	return m.Size()
}
func (m *ContainerNetworkQueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerNetworkQueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerNetworkQueryRequest proto.InternalMessageInfo

func (m *ContainerNetworkQueryRequest) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

func (m *ContainerNetworkQueryRequest) GetPid() uint32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

type ContainerNetworkConfigResponse struct {
	Ipv4Subnet string `protobuf:"bytes,1,opt,name=ipv4_subnet,json=ipv4Subnet,proto3" json:"ipv4_subnet,omitempty"`
	Ipv6Subnet string `protobuf:"bytes,2,opt,name=ipv6_subnet,json=ipv6Subnet,proto3" json:"ipv6_subnet,omitempty"`
}

func (m *ContainerNetworkConfigResponse) Reset()      { *m = ContainerNetworkConfigResponse{} }
func (*ContainerNetworkConfigResponse) ProtoMessage() {}
func (*ContainerNetworkConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{7}
}
func (m *ContainerNetworkConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerNetworkConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerNetworkConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerNetworkConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerNetworkConfigResponse.Merge(m, src)
}
func (m *ContainerNetworkConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *ContainerNetworkConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerNetworkConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerNetworkConfigResponse proto.InternalMessageInfo

func (m *ContainerNetworkConfigResponse) GetIpv4Subnet() string {
	if m != nil {
		return m.Ipv4Subnet
	}
	return ""
}

func (m *ContainerNetworkConfigResponse) GetIpv6Subnet() string {
	if m != nil {
		return m.Ipv6Subnet
	}
	return ""
}

type ContainerNetworkStatusResponse struct {
	Pid        uint32              `protobuf:"varint,1,opt,name=pid,proto3" json:"pid,omitempty"`
	Interfaces []*NetworkInterface `protobuf:"bytes,2,rep,name=interfaces,proto3" json:"interfaces,omitempty"`
}

func (m *ContainerNetworkStatusResponse) Reset()      { *m = ContainerNetworkStatusResponse{} }
func (*ContainerNetworkStatusResponse) ProtoMessage() {}
func (*ContainerNetworkStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{8}
}
func (m *ContainerNetworkStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerNetworkStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerNetworkStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerNetworkStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerNetworkStatusResponse.Merge(m, src)
}
func (m *ContainerNetworkStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *ContainerNetworkStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerNetworkStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerNetworkStatusResponse proto.InternalMessageInfo

func (m *ContainerNetworkStatusResponse) GetPid() uint32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *ContainerNetworkStatusResponse) GetInterfaces() []*NetworkInterface {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

type ContainerNetworkStatusListResponse struct {
	// key: container id
	ContainerNetworks map[string]*ContainerNetworkStatusResponse `protobuf:"bytes,1,rep,name=container_networks,json=containerNetworks,proto3" json:"container_networks,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ContainerNetworkStatusListResponse) Reset()      { *m = ContainerNetworkStatusListResponse{} }
func (*ContainerNetworkStatusListResponse) ProtoMessage() {}
func (*ContainerNetworkStatusListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7afe31759757e49a, []int{9}
}
func (m *ContainerNetworkStatusListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerNetworkStatusListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerNetworkStatusListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerNetworkStatusListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerNetworkStatusListResponse.Merge(m, src)
}
func (m *ContainerNetworkStatusListResponse) XXX_Size() int {
	return m.Size()
}
func (m *ContainerNetworkStatusListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerNetworkStatusListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerNetworkStatusListResponse proto.InternalMessageInfo

func (m *ContainerNetworkStatusListResponse) GetContainerNetworks() map[string]*ContainerNetworkStatusResponse {
	if m != nil {
		return m.ContainerNetworks
	}
	return nil
}

func init() {
	proto.RegisterType((*CNICapArgs)(nil), "abbot.CNICapArgs")
	proto.RegisterType((*CNICapArgs_PortMap)(nil), "abbot.CNICapArgs.PortMap")
	proto.RegisterType((*CNICapArgs_Bandwidth)(nil), "abbot.CNICapArgs.Bandwidth")
	proto.RegisterType((*CNICapArgs_IPRange)(nil), "abbot.CNICapArgs.IPRange")
	proto.RegisterType((*CNICapArgs_DNSConfig)(nil), "abbot.CNICapArgs.DNSConfig")
	proto.RegisterType((*CNICapArgs_IPAddresses)(nil), "abbot.CNICapArgs.IPAddresses")
	proto.RegisterType((*CNICapArgs_MacAddress)(nil), "abbot.CNICapArgs.MacAddress")
	proto.RegisterType((*CNICapArgs_InfinibandGUID)(nil), "abbot.CNICapArgs.InfinibandGUID")
	proto.RegisterType((*CNICapArgs_DeviceID)(nil), "abbot.CNICapArgs.DeviceID")
	proto.RegisterType((*ContainerNetworkEnsureRequest)(nil), "abbot.ContainerNetworkEnsureRequest")
	proto.RegisterMapType((map[string]string)(nil), "abbot.ContainerNetworkEnsureRequest.CniArgsEntry")
	proto.RegisterType((*ContainerNetworkRestoreRequest)(nil), "abbot.ContainerNetworkRestoreRequest")
	proto.RegisterType((*ContainerNetworkDeleteRequest)(nil), "abbot.ContainerNetworkDeleteRequest")
	proto.RegisterType((*ContainerNetworkConfigEnsureRequest)(nil), "abbot.ContainerNetworkConfigEnsureRequest")
	proto.RegisterType((*ContainerNetworkConfigQueryRequest)(nil), "abbot.ContainerNetworkConfigQueryRequest")
	proto.RegisterType((*ContainerNetworkQueryRequest)(nil), "abbot.ContainerNetworkQueryRequest")
	proto.RegisterType((*ContainerNetworkConfigResponse)(nil), "abbot.ContainerNetworkConfigResponse")
	proto.RegisterType((*ContainerNetworkStatusResponse)(nil), "abbot.ContainerNetworkStatusResponse")
	proto.RegisterType((*ContainerNetworkStatusListResponse)(nil), "abbot.ContainerNetworkStatusListResponse")
	proto.RegisterMapType((map[string]*ContainerNetworkStatusResponse)(nil), "abbot.ContainerNetworkStatusListResponse.ContainerNetworksEntry")
}

func init() { proto.RegisterFile("container.proto", fileDescriptor_7afe31759757e49a) }

var fileDescriptor_7afe31759757e49a = []byte{
	// 1200 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4f, 0x6f, 0xdb, 0xc6,
	0x13, 0x15, 0xa5, 0xd8, 0x92, 0x86, 0x92, 0x13, 0xf3, 0x97, 0xf8, 0xa7, 0xb0, 0x0e, 0xe5, 0xca,
	0x2d, 0x90, 0x02, 0x89, 0x8c, 0x28, 0x41, 0x9a, 0xa6, 0x0d, 0x12, 0x4b, 0x76, 0x63, 0x01, 0x89,
	0xe1, 0xd2, 0x35, 0x0a, 0xf4, 0x22, 0xac, 0xc8, 0x35, 0xbd, 0xb0, 0x45, 0xb2, 0xe4, 0x4a, 0x86,
	0x6f, 0x45, 0x7a, 0xed, 0xa1, 0x5f, 0xa1, 0xb7, 0x7e, 0x89, 0xde, 0x7b, 0x2a, 0x7c, 0xcc, 0x49,
	0xa8, 0xe5, 0x4b, 0xa1, 0x53, 0x3e, 0x42, 0xb1, 0x7f, 0x48, 0xad, 0x2d, 0x39, 0x87, 0xa6, 0x27,
	0xef, 0xbe, 0x7d, 0xef, 0xcd, 0x68, 0x77, 0x66, 0x68, 0xb8, 0xee, 0x04, 0x3e, 0x45, 0xc4, 0xc7,
	0x51, 0x3d, 0x8c, 0x02, 0x1a, 0x18, 0x73, 0xa8, 0xdb, 0x0d, 0xa8, 0x79, 0xdf, 0x23, 0xf4, 0xa0,
	0xdf, 0xad, 0x3b, 0x41, 0x6f, 0xcd, 0x0b, 0xbc, 0x60, 0x8d, 0x9f, 0x76, 0xfb, 0xfb, 0x7c, 0xc7,
	0x37, 0x7c, 0x25, 0x54, 0x26, 0xf4, 0x30, 0x45, 0x62, 0x5d, 0x7b, 0x53, 0x06, 0x68, 0x6d, 0xb7,
	0x5b, 0x28, 0x5c, 0x8f, 0xbc, 0xd8, 0x78, 0x06, 0xa5, 0x30, 0x88, 0x68, 0xa7, 0x87, 0xc2, 0x0e,
	0x8a, 0xbc, 0x8a, 0xb6, 0xa2, 0xdd, 0xd5, 0x1b, 0xb7, 0xeb, 0x3c, 0x4e, 0x7d, 0x42, 0xac, 0xef,
	0x04, 0x11, 0x7d, 0x8d, 0xc2, 0xad, 0x8c, 0x0d, 0xa1, 0x58, 0xae, 0x47, 0x9e, 0xd1, 0x84, 0x72,
	0x17, 0xf9, 0xee, 0x31, 0x71, 0xe9, 0x01, 0xd7, 0x67, 0xb9, 0xfe, 0xa3, 0x69, 0x7d, 0x33, 0xa1,
	0x6d, 0x65, 0xec, 0x52, 0xaa, 0x61, 0x1e, 0xcf, 0xa0, 0x44, 0xc2, 0x4e, 0x84, 0x7c, 0x0f, 0x73,
	0x8b, 0xdc, 0x55, 0x29, 0xb4, 0x77, 0x6c, 0x46, 0x62, 0x29, 0x90, 0x90, 0x2f, 0x99, 0xbc, 0x05,
	0x0b, 0xae, 0x1f, 0x77, 0x9c, 0xc0, 0xdf, 0x27, 0x1e, 0x37, 0xb8, 0x76, 0x55, 0x0e, 0x1b, 0xdb,
	0xbb, 0x2d, 0x4e, 0x63, 0x39, 0xb8, 0x7e, 0x2c, 0x36, 0xcc, 0xa4, 0x0d, 0x37, 0x48, 0xd8, 0x41,
	0xae, 0x1b, 0xe1, 0x38, 0xc6, 0x31, 0xb7, 0x99, 0xe3, 0x36, 0x77, 0x66, 0xe5, 0xb1, 0x9e, 0x10,
	0xb7, 0x32, 0xf6, 0x02, 0x09, 0xd3, 0x2d, 0xb3, 0xfa, 0x1a, 0xae, 0xf7, 0x90, 0x93, 0x78, 0x71,
	0xa7, 0x79, 0xee, 0xb4, 0x3c, 0xed, 0xf4, 0x1a, 0x39, 0x52, 0xbb, 0x95, 0xb1, 0xcb, 0xbd, 0x74,
	0xc7, 0x7c, 0x6c, 0xf8, 0x1f, 0xf1, 0xf7, 0x89, 0x4f, 0xd8, 0x65, 0x75, 0xbc, 0x3e, 0x71, 0xb9,
	0x57, 0x9e, 0x7b, 0xad, 0xcc, 0xc8, 0x2a, 0x25, 0xbf, 0xdc, 0x6b, 0x6f, 0x6c, 0x65, 0xec, 0xc5,
	0x89, 0xfc, 0x65, 0x9f, 0xb8, 0xcc, 0xf3, 0x05, 0x94, 0x5d, 0x3c, 0x20, 0x0e, 0xee, 0x48, 0xb7,
	0x02, 0x77, 0x33, 0x67, 0x5c, 0x15, 0xa7, 0x71, 0x1f, 0x5d, 0x48, 0xda, 0xcc, 0xc1, 0xfc, 0x5d,
	0x83, 0xbc, 0x2c, 0x05, 0xe3, 0x09, 0x2c, 0xa4, 0xf5, 0xd9, 0x61, 0x45, 0xc1, 0xab, 0x67, 0xae,
	0xb9, 0x38, 0x1e, 0x56, 0xcb, 0xe9, 0x09, 0x63, 0xdb, 0x17, 0xb7, 0xc6, 0x67, 0x50, 0x3c, 0x08,
	0x62, 0x2a, 0x44, 0x59, 0x2e, 0x2a, 0x8d, 0x87, 0xd5, 0x02, 0x03, 0x39, 0x3f, 0x5d, 0x19, 0x77,
	0xa1, 0xc0, 0x0b, 0xd7, 0x09, 0x8e, 0x78, 0x65, 0x14, 0x05, 0x33, 0xc1, 0xec, 0x74, 0x65, 0xac,
	0x42, 0x9e, 0x9b, 0x92, 0x90, 0x57, 0x40, 0xb1, 0x09, 0xe3, 0x61, 0x75, 0x9e, 0x41, 0xed, 0x1d,
	0x5b, 0xfc, 0x0d, 0xcd, 0x9f, 0xb2, 0x50, 0x4c, 0x4b, 0xd1, 0xf8, 0x0a, 0x4a, 0xc4, 0xf7, 0xf8,
	0x3b, 0x45, 0x88, 0x62, 0x99, 0xff, 0xed, 0xf1, 0xb0, 0x7a, 0x4b, 0xe2, 0x36, 0xa2, 0xf8, 0x5e,
	0xd0, 0x23, 0x14, 0xf7, 0x42, 0x7a, 0x62, 0xeb, 0x0a, 0x6c, 0x3c, 0x87, 0x72, 0xa2, 0xee, 0xf6,
	0xa3, 0x38, 0xf9, 0x25, 0xe6, 0x78, 0x58, 0x5d, 0x92, 0x07, 0x4d, 0x86, 0x2b, 0xfa, 0x92, 0x8a,
	0x1b, 0x5f, 0x80, 0x8e, 0x95, 0xe8, 0x39, 0x2e, 0xaf, 0x8c, 0x87, 0xd5, 0x9b, 0x78, 0x56, 0x70,
	0x98, 0xa0, 0x2c, 0x73, 0xac, 0x86, 0xbe, 0x36, 0xc9, 0x1c, 0xcf, 0x8c, 0xac, 0x2b, 0xb0, 0xf9,
	0xa7, 0x06, 0x79, 0xd9, 0x4d, 0x46, 0x0d, 0xe6, 0xe3, 0x7e, 0xd7, 0xc7, 0xe2, 0xf5, 0xe4, 0xad,
	0x09, 0xc4, 0x96, 0x7f, 0x59, 0xa2, 0xa2, 0x3f, 0x63, 0x8a, 0xe4, 0x8b, 0x15, 0x45, 0xa2, 0x1c,
	0xde, 0x65, 0xa8, 0x9a, 0xe8, 0x04, 0x35, 0x1e, 0x42, 0x51, 0x48, 0xb1, 0xef, 0xca, 0x07, 0x5c,
	0x1a, 0x0f, 0xab, 0x06, 0x07, 0x37, 0x7d, 0x57, 0x91, 0x15, 0x12, 0xcc, 0x58, 0x83, 0xbc, 0x87,
	0x28, 0x3e, 0x46, 0x27, 0xf2, 0x29, 0x6f, 0x8d, 0x87, 0xd5, 0x45, 0x09, 0x29, 0x8a, 0x84, 0x65,
	0xfe, 0xaa, 0x41, 0x31, 0xed, 0x6e, 0x26, 0x8f, 0x71, 0x34, 0xc0, 0x51, 0x5c, 0xd1, 0x56, 0x72,
	0x89, 0x5c, 0x42, 0xaa, 0x5c, 0x42, 0x46, 0x03, 0x0a, 0x31, 0x46, 0x91, 0x73, 0x80, 0xe3, 0x4a,
	0x96, 0x2b, 0x78, 0x8e, 0x09, 0xa6, 0xe6, 0x98, 0x60, 0x2c, 0x48, 0x10, 0x52, 0x12, 0xf8, 0x71,
	0x25, 0x37, 0x09, 0x22, 0x21, 0x35, 0x88, 0x84, 0xcc, 0x06, 0xe8, 0xca, 0xe4, 0x30, 0x56, 0x21,
	0x47, 0xc2, 0x24, 0x41, 0xde, 0x32, 0x24, 0x54, 0x75, 0xec, 0xd4, 0x7c, 0x00, 0x30, 0x99, 0x11,
	0x4c, 0xd2, 0x43, 0x8e, 0x7c, 0x27, 0x2e, 0xe9, 0x21, 0x47, 0x95, 0xf4, 0x90, 0x63, 0x7e, 0x07,
	0x0b, 0x17, 0x47, 0x81, 0xb1, 0x09, 0xd7, 0x2f, 0x4d, 0x12, 0x69, 0xb1, 0x3c, 0x1e, 0x56, 0x2b,
	0xe4, 0x02, 0x59, 0x71, 0x5b, 0xb8, 0x38, 0x3f, 0xcc, 0xe7, 0x50, 0x48, 0xa6, 0x02, 0x7b, 0xd5,
	0x74, 0x90, 0x48, 0x33, 0x7e, 0x63, 0x72, 0x54, 0xa8, 0x36, 0x85, 0x64, 0x7c, 0x34, 0x0b, 0x30,
	0x2f, 0xee, 0xa2, 0xf6, 0x73, 0x16, 0xee, 0xb4, 0x92, 0x89, 0xb0, 0x8d, 0xe9, 0x71, 0x10, 0x1d,
	0x6e, 0xfa, 0x71, 0x3f, 0xc2, 0x36, 0xfe, 0xa1, 0x8f, 0x63, 0x6a, 0x7c, 0x0c, 0xa5, 0xc9, 0x6c,
	0x49, 0x62, 0xd8, 0x7a, 0x8a, 0xb5, 0x5d, 0xe3, 0x06, 0xe4, 0x42, 0xe2, 0xf2, 0x62, 0x2c, 0xdb,
	0x6c, 0x69, 0xdc, 0x83, 0x82, 0x23, 0xbe, 0x63, 0xe2, 0x4d, 0xf4, 0xc6, 0xe2, 0xd4, 0x64, 0xb3,
	0xf3, 0x8e, 0xfc, 0xf4, 0xbd, 0x82, 0x82, 0xe3, 0x13, 0xc1, 0xbe, 0xc6, 0xd9, 0x0f, 0x12, 0xf6,
	0xfb, 0x52, 0xab, 0xb7, 0x7c, 0xc2, 0xf4, 0x9b, 0x3e, 0x8d, 0x4e, 0xec, 0xbc, 0x23, 0x76, 0xe6,
	0x53, 0x28, 0xa9, 0x07, 0x2c, 0xbb, 0x43, 0x7c, 0x22, 0xf3, 0x66, 0x4b, 0xe3, 0x26, 0xcc, 0x0d,
	0xd0, 0x51, 0x1f, 0x8b, 0xf6, 0xb1, 0xc5, 0xe6, 0x69, 0xf6, 0x89, 0x56, 0xdb, 0x03, 0xeb, 0x72,
	0x48, 0x1b, 0xc7, 0x34, 0xf8, 0xb0, 0xeb, 0xa8, 0x7d, 0x3b, 0x7d, 0xc9, 0x1b, 0xf8, 0x08, 0xd3,
	0x0f, 0x73, 0xf5, 0x60, 0xf5, 0xb2, 0xab, 0x68, 0xbb, 0x8b, 0x0f, 0x58, 0x05, 0x9d, 0x84, 0x83,
	0x47, 0x1d, 0x75, 0xb6, 0xb0, 0xef, 0xf6, 0xe0, 0xd1, 0xae, 0x98, 0x29, 0x82, 0xf0, 0x38, 0x21,
	0x64, 0x53, 0xc2, 0x63, 0x41, 0xa8, 0x7d, 0x02, 0xb5, 0xd9, 0x81, 0xbe, 0xe9, 0xe3, 0xe8, 0x44,
	0xc6, 0xa9, 0xed, 0xc2, 0xf2, 0x65, 0x96, 0x7a, 0xfe, 0xef, 0x7e, 0x63, 0x77, 0xfa, 0x41, 0x44,
	0x68, 0x1b, 0xc7, 0x61, 0xe0, 0xc7, 0xf8, 0x3f, 0xf8, 0x79, 0x87, 0xd3, 0x31, 0x76, 0x29, 0xa2,
	0xfd, 0x38, 0x8d, 0x21, 0xf3, 0xd2, 0x26, 0x05, 0xfe, 0x39, 0x00, 0xf1, 0x29, 0x8e, 0xf6, 0x91,
	0x23, 0x27, 0x95, 0xde, 0xf8, 0xbf, 0x2c, 0x5a, 0xe9, 0xd1, 0x4e, 0xce, 0x6d, 0x85, 0x5a, 0x7b,
	0x93, 0x9d, 0xbe, 0x4c, 0x11, 0xed, 0x15, 0x89, 0x69, 0x1a, 0x31, 0x00, 0x63, 0x72, 0x59, 0xbe,
	0xa0, 0x89, 0x11, 0xa5, 0x37, 0x5e, 0x5c, 0xd1, 0x1c, 0xd3, 0x36, 0x53, 0x14, 0xd9, 0x2b, 0x8b,
	0xce, 0x65, 0xdc, 0x3c, 0x84, 0xa5, 0xd9, 0xe4, 0x19, 0xfd, 0xf3, 0xa5, 0xda, 0x3f, 0x7a, 0xe3,
	0xd3, 0xf7, 0xe6, 0x93, 0xe4, 0xa2, 0xb4, 0x59, 0x73, 0xef, 0xf4, 0xcc, 0xca, 0xbc, 0x3d, 0xb3,
	0x32, 0xef, 0xce, 0x2c, 0xed, 0xc7, 0x91, 0xa5, 0xfd, 0x36, 0xb2, 0xb4, 0x3f, 0x46, 0x96, 0x76,
	0x3a, 0xb2, 0xb4, 0xbf, 0x46, 0x96, 0xf6, 0xf7, 0xc8, 0xca, 0xbc, 0x1b, 0x59, 0xda, 0x2f, 0xe7,
	0x56, 0xe6, 0xf4, 0xdc, 0xca, 0xbc, 0x3d, 0xb7, 0x32, 0xdf, 0x57, 0x51, 0x74, 0x80, 0x68, 0xdd,
	0xc5, 0x83, 0x35, 0x1e, 0xf0, 0xbe, 0xf8, 0xf7, 0x9a, 0xaf, 0xbd, 0x20, 0xec, 0x76, 0xe7, 0x39,
	0xf0, 0xf0, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf8, 0x05, 0x4f, 0x62, 0xad, 0x0b, 0x00, 0x00,
}

func (this *CNICapArgs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs)
	if !ok {
		that2, ok := that.(CNICapArgs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Option == nil {
		if this.Option != nil {
			return false
		}
	} else if this.Option == nil {
		return false
	} else if !this.Option.Equal(that1.Option) {
		return false
	}
	return true
}
func (this *CNICapArgs_PortMapArg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_PortMapArg)
	if !ok {
		that2, ok := that.(CNICapArgs_PortMapArg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PortMapArg.Equal(that1.PortMapArg) {
		return false
	}
	return true
}
func (this *CNICapArgs_BandwidthArg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_BandwidthArg)
	if !ok {
		that2, ok := that.(CNICapArgs_BandwidthArg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BandwidthArg.Equal(that1.BandwidthArg) {
		return false
	}
	return true
}
func (this *CNICapArgs_IpRangeArg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_IpRangeArg)
	if !ok {
		that2, ok := that.(CNICapArgs_IpRangeArg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpRangeArg.Equal(that1.IpRangeArg) {
		return false
	}
	return true
}
func (this *CNICapArgs_DnsConfigArg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_DnsConfigArg)
	if !ok {
		that2, ok := that.(CNICapArgs_DnsConfigArg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DnsConfigArg.Equal(that1.DnsConfigArg) {
		return false
	}
	return true
}
func (this *CNICapArgs_IpAddressesArg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_IpAddressesArg)
	if !ok {
		that2, ok := that.(CNICapArgs_IpAddressesArg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpAddressesArg.Equal(that1.IpAddressesArg) {
		return false
	}
	return true
}
func (this *CNICapArgs_MacAddressArg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_MacAddressArg)
	if !ok {
		that2, ok := that.(CNICapArgs_MacAddressArg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MacAddressArg.Equal(that1.MacAddressArg) {
		return false
	}
	return true
}
func (this *CNICapArgs_InfinibandGuidArg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_InfinibandGuidArg)
	if !ok {
		that2, ok := that.(CNICapArgs_InfinibandGuidArg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InfinibandGuidArg.Equal(that1.InfinibandGuidArg) {
		return false
	}
	return true
}
func (this *CNICapArgs_DeviceIdArg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_DeviceIdArg)
	if !ok {
		that2, ok := that.(CNICapArgs_DeviceIdArg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeviceIdArg.Equal(that1.DeviceIdArg) {
		return false
	}
	return true
}
func (this *CNICapArgs_PortMap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_PortMap)
	if !ok {
		that2, ok := that.(CNICapArgs_PortMap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContainerPort != that1.ContainerPort {
		return false
	}
	if this.HostPort != that1.HostPort {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.HostIp != that1.HostIp {
		return false
	}
	return true
}
func (this *CNICapArgs_Bandwidth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_Bandwidth)
	if !ok {
		that2, ok := that.(CNICapArgs_Bandwidth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IngressRate != that1.IngressRate {
		return false
	}
	if this.IngressBurst != that1.IngressBurst {
		return false
	}
	if this.EgressRate != that1.EgressRate {
		return false
	}
	if this.EgressBurst != that1.EgressBurst {
		return false
	}
	return true
}
func (this *CNICapArgs_IPRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_IPRange)
	if !ok {
		that2, ok := that.(CNICapArgs_IPRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Subnet != that1.Subnet {
		return false
	}
	if this.RangeStart != that1.RangeStart {
		return false
	}
	if this.RangeEnd != that1.RangeEnd {
		return false
	}
	if this.Gateway != that1.Gateway {
		return false
	}
	return true
}
func (this *CNICapArgs_DNSConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_DNSConfig)
	if !ok {
		that2, ok := that.(CNICapArgs_DNSConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Servers) != len(that1.Servers) {
		return false
	}
	for i := range this.Servers {
		if this.Servers[i] != that1.Servers[i] {
			return false
		}
	}
	if len(this.Searches) != len(that1.Searches) {
		return false
	}
	for i := range this.Searches {
		if this.Searches[i] != that1.Searches[i] {
			return false
		}
	}
	if len(this.Options) != len(that1.Options) {
		return false
	}
	for i := range this.Options {
		if this.Options[i] != that1.Options[i] {
			return false
		}
	}
	return true
}
func (this *CNICapArgs_IPAddresses) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_IPAddresses)
	if !ok {
		that2, ok := that.(CNICapArgs_IPAddresses)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ips) != len(that1.Ips) {
		return false
	}
	for i := range this.Ips {
		if this.Ips[i] != that1.Ips[i] {
			return false
		}
	}
	return true
}
func (this *CNICapArgs_MacAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_MacAddress)
	if !ok {
		that2, ok := that.(CNICapArgs_MacAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mac != that1.Mac {
		return false
	}
	return true
}
func (this *CNICapArgs_InfinibandGUID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_InfinibandGUID)
	if !ok {
		that2, ok := that.(CNICapArgs_InfinibandGUID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.InfinibandGuid != that1.InfinibandGuid {
		return false
	}
	return true
}
func (this *CNICapArgs_DeviceID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_DeviceID)
	if !ok {
		that2, ok := that.(CNICapArgs_DeviceID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DeviceId != that1.DeviceId {
		return false
	}
	return true
}
func (this *ContainerNetworkEnsureRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerNetworkEnsureRequest)
	if !ok {
		that2, ok := that.(ContainerNetworkEnsureRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContainerId != that1.ContainerId {
		return false
	}
	if this.Pid != that1.Pid {
		return false
	}
	if len(this.CapArgs) != len(that1.CapArgs) {
		return false
	}
	for i := range this.CapArgs {
		if !this.CapArgs[i].Equal(that1.CapArgs[i]) {
			return false
		}
	}
	if len(this.CniArgs) != len(that1.CniArgs) {
		return false
	}
	for i := range this.CniArgs {
		if this.CniArgs[i] != that1.CniArgs[i] {
			return false
		}
	}
	return true
}
func (this *ContainerNetworkRestoreRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerNetworkRestoreRequest)
	if !ok {
		that2, ok := that.(ContainerNetworkRestoreRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContainerId != that1.ContainerId {
		return false
	}
	if this.Pid != that1.Pid {
		return false
	}
	return true
}
func (this *ContainerNetworkDeleteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerNetworkDeleteRequest)
	if !ok {
		that2, ok := that.(ContainerNetworkDeleteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContainerId != that1.ContainerId {
		return false
	}
	if this.Pid != that1.Pid {
		return false
	}
	return true
}
func (this *ContainerNetworkConfigEnsureRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerNetworkConfigEnsureRequest)
	if !ok {
		that2, ok := that.(ContainerNetworkConfigEnsureRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ipv4Subnet != that1.Ipv4Subnet {
		return false
	}
	if this.Ipv6Subnet != that1.Ipv6Subnet {
		return false
	}
	return true
}
func (this *ContainerNetworkConfigQueryRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerNetworkConfigQueryRequest)
	if !ok {
		that2, ok := that.(ContainerNetworkConfigQueryRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ContainerNetworkQueryRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerNetworkQueryRequest)
	if !ok {
		that2, ok := that.(ContainerNetworkQueryRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContainerId != that1.ContainerId {
		return false
	}
	if this.Pid != that1.Pid {
		return false
	}
	return true
}
func (this *ContainerNetworkConfigResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerNetworkConfigResponse)
	if !ok {
		that2, ok := that.(ContainerNetworkConfigResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ipv4Subnet != that1.Ipv4Subnet {
		return false
	}
	if this.Ipv6Subnet != that1.Ipv6Subnet {
		return false
	}
	return true
}
func (this *ContainerNetworkStatusResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerNetworkStatusResponse)
	if !ok {
		that2, ok := that.(ContainerNetworkStatusResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pid != that1.Pid {
		return false
	}
	if len(this.Interfaces) != len(that1.Interfaces) {
		return false
	}
	for i := range this.Interfaces {
		if !this.Interfaces[i].Equal(that1.Interfaces[i]) {
			return false
		}
	}
	return true
}
func (this *ContainerNetworkStatusListResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerNetworkStatusListResponse)
	if !ok {
		that2, ok := that.(ContainerNetworkStatusListResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ContainerNetworks) != len(that1.ContainerNetworks) {
		return false
	}
	for i := range this.ContainerNetworks {
		if !this.ContainerNetworks[i].Equal(that1.ContainerNetworks[i]) {
			return false
		}
	}
	return true
}
func (this *CNICapArgs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&abbotgopb.CNICapArgs{")
	if this.Option != nil {
		s = append(s, "Option: "+fmt.Sprintf("%#v", this.Option)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CNICapArgs_PortMapArg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.CNICapArgs_PortMapArg{` +
		`PortMapArg:` + fmt.Sprintf("%#v", this.PortMapArg) + `}`}, ", ")
	return s
}
func (this *CNICapArgs_BandwidthArg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.CNICapArgs_BandwidthArg{` +
		`BandwidthArg:` + fmt.Sprintf("%#v", this.BandwidthArg) + `}`}, ", ")
	return s
}
func (this *CNICapArgs_IpRangeArg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.CNICapArgs_IpRangeArg{` +
		`IpRangeArg:` + fmt.Sprintf("%#v", this.IpRangeArg) + `}`}, ", ")
	return s
}
func (this *CNICapArgs_DnsConfigArg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.CNICapArgs_DnsConfigArg{` +
		`DnsConfigArg:` + fmt.Sprintf("%#v", this.DnsConfigArg) + `}`}, ", ")
	return s
}
func (this *CNICapArgs_IpAddressesArg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.CNICapArgs_IpAddressesArg{` +
		`IpAddressesArg:` + fmt.Sprintf("%#v", this.IpAddressesArg) + `}`}, ", ")
	return s
}
func (this *CNICapArgs_MacAddressArg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.CNICapArgs_MacAddressArg{` +
		`MacAddressArg:` + fmt.Sprintf("%#v", this.MacAddressArg) + `}`}, ", ")
	return s
}
func (this *CNICapArgs_InfinibandGuidArg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.CNICapArgs_InfinibandGuidArg{` +
		`InfinibandGuidArg:` + fmt.Sprintf("%#v", this.InfinibandGuidArg) + `}`}, ", ")
	return s
}
func (this *CNICapArgs_DeviceIdArg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.CNICapArgs_DeviceIdArg{` +
		`DeviceIdArg:` + fmt.Sprintf("%#v", this.DeviceIdArg) + `}`}, ", ")
	return s
}
func (this *CNICapArgs_PortMap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&abbotgopb.CNICapArgs_PortMap{")
	s = append(s, "ContainerPort: "+fmt.Sprintf("%#v", this.ContainerPort)+",\n")
	s = append(s, "HostPort: "+fmt.Sprintf("%#v", this.HostPort)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "HostIp: "+fmt.Sprintf("%#v", this.HostIp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CNICapArgs_Bandwidth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&abbotgopb.CNICapArgs_Bandwidth{")
	s = append(s, "IngressRate: "+fmt.Sprintf("%#v", this.IngressRate)+",\n")
	s = append(s, "IngressBurst: "+fmt.Sprintf("%#v", this.IngressBurst)+",\n")
	s = append(s, "EgressRate: "+fmt.Sprintf("%#v", this.EgressRate)+",\n")
	s = append(s, "EgressBurst: "+fmt.Sprintf("%#v", this.EgressBurst)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CNICapArgs_IPRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&abbotgopb.CNICapArgs_IPRange{")
	s = append(s, "Subnet: "+fmt.Sprintf("%#v", this.Subnet)+",\n")
	s = append(s, "RangeStart: "+fmt.Sprintf("%#v", this.RangeStart)+",\n")
	s = append(s, "RangeEnd: "+fmt.Sprintf("%#v", this.RangeEnd)+",\n")
	s = append(s, "Gateway: "+fmt.Sprintf("%#v", this.Gateway)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CNICapArgs_DNSConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&abbotgopb.CNICapArgs_DNSConfig{")
	s = append(s, "Servers: "+fmt.Sprintf("%#v", this.Servers)+",\n")
	s = append(s, "Searches: "+fmt.Sprintf("%#v", this.Searches)+",\n")
	s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CNICapArgs_IPAddresses) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&abbotgopb.CNICapArgs_IPAddresses{")
	s = append(s, "Ips: "+fmt.Sprintf("%#v", this.Ips)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CNICapArgs_MacAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&abbotgopb.CNICapArgs_MacAddress{")
	s = append(s, "Mac: "+fmt.Sprintf("%#v", this.Mac)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CNICapArgs_InfinibandGUID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&abbotgopb.CNICapArgs_InfinibandGUID{")
	s = append(s, "InfinibandGuid: "+fmt.Sprintf("%#v", this.InfinibandGuid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CNICapArgs_DeviceID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&abbotgopb.CNICapArgs_DeviceID{")
	s = append(s, "DeviceId: "+fmt.Sprintf("%#v", this.DeviceId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerNetworkEnsureRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&abbotgopb.ContainerNetworkEnsureRequest{")
	s = append(s, "ContainerId: "+fmt.Sprintf("%#v", this.ContainerId)+",\n")
	s = append(s, "Pid: "+fmt.Sprintf("%#v", this.Pid)+",\n")
	if this.CapArgs != nil {
		s = append(s, "CapArgs: "+fmt.Sprintf("%#v", this.CapArgs)+",\n")
	}
	keysForCniArgs := make([]string, 0, len(this.CniArgs))
	for k, _ := range this.CniArgs {
		keysForCniArgs = append(keysForCniArgs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForCniArgs)
	mapStringForCniArgs := "map[string]string{"
	for _, k := range keysForCniArgs {
		mapStringForCniArgs += fmt.Sprintf("%#v: %#v,", k, this.CniArgs[k])
	}
	mapStringForCniArgs += "}"
	if this.CniArgs != nil {
		s = append(s, "CniArgs: "+mapStringForCniArgs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerNetworkRestoreRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&abbotgopb.ContainerNetworkRestoreRequest{")
	s = append(s, "ContainerId: "+fmt.Sprintf("%#v", this.ContainerId)+",\n")
	s = append(s, "Pid: "+fmt.Sprintf("%#v", this.Pid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerNetworkDeleteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&abbotgopb.ContainerNetworkDeleteRequest{")
	s = append(s, "ContainerId: "+fmt.Sprintf("%#v", this.ContainerId)+",\n")
	s = append(s, "Pid: "+fmt.Sprintf("%#v", this.Pid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerNetworkConfigEnsureRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&abbotgopb.ContainerNetworkConfigEnsureRequest{")
	s = append(s, "Ipv4Subnet: "+fmt.Sprintf("%#v", this.Ipv4Subnet)+",\n")
	s = append(s, "Ipv6Subnet: "+fmt.Sprintf("%#v", this.Ipv6Subnet)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerNetworkConfigQueryRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&abbotgopb.ContainerNetworkConfigQueryRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerNetworkQueryRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&abbotgopb.ContainerNetworkQueryRequest{")
	s = append(s, "ContainerId: "+fmt.Sprintf("%#v", this.ContainerId)+",\n")
	s = append(s, "Pid: "+fmt.Sprintf("%#v", this.Pid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerNetworkConfigResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&abbotgopb.ContainerNetworkConfigResponse{")
	s = append(s, "Ipv4Subnet: "+fmt.Sprintf("%#v", this.Ipv4Subnet)+",\n")
	s = append(s, "Ipv6Subnet: "+fmt.Sprintf("%#v", this.Ipv6Subnet)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerNetworkStatusResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&abbotgopb.ContainerNetworkStatusResponse{")
	s = append(s, "Pid: "+fmt.Sprintf("%#v", this.Pid)+",\n")
	if this.Interfaces != nil {
		s = append(s, "Interfaces: "+fmt.Sprintf("%#v", this.Interfaces)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerNetworkStatusListResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&abbotgopb.ContainerNetworkStatusListResponse{")
	keysForContainerNetworks := make([]string, 0, len(this.ContainerNetworks))
	for k, _ := range this.ContainerNetworks {
		keysForContainerNetworks = append(keysForContainerNetworks, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForContainerNetworks)
	mapStringForContainerNetworks := "map[string]*ContainerNetworkStatusResponse{"
	for _, k := range keysForContainerNetworks {
		mapStringForContainerNetworks += fmt.Sprintf("%#v: %#v,", k, this.ContainerNetworks[k])
	}
	mapStringForContainerNetworks += "}"
	if this.ContainerNetworks != nil {
		s = append(s, "ContainerNetworks: "+mapStringForContainerNetworks+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringContainer(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *CNICapArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNICapArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Option != nil {
		{
			size := m.Option.Size()
			i -= size
			if _, err := m.Option.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CNICapArgs_PortMapArg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_PortMapArg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PortMapArg != nil {
		{
			size, err := m.PortMapArg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContainer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CNICapArgs_BandwidthArg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_BandwidthArg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BandwidthArg != nil {
		{
			size, err := m.BandwidthArg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContainer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CNICapArgs_IpRangeArg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_IpRangeArg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpRangeArg != nil {
		{
			size, err := m.IpRangeArg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContainer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CNICapArgs_DnsConfigArg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_DnsConfigArg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DnsConfigArg != nil {
		{
			size, err := m.DnsConfigArg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContainer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CNICapArgs_IpAddressesArg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_IpAddressesArg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpAddressesArg != nil {
		{
			size, err := m.IpAddressesArg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContainer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CNICapArgs_MacAddressArg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_MacAddressArg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MacAddressArg != nil {
		{
			size, err := m.MacAddressArg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContainer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *CNICapArgs_InfinibandGuidArg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_InfinibandGuidArg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InfinibandGuidArg != nil {
		{
			size, err := m.InfinibandGuidArg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContainer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *CNICapArgs_DeviceIdArg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_DeviceIdArg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeviceIdArg != nil {
		{
			size, err := m.DeviceIdArg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContainer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *CNICapArgs_PortMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNICapArgs_PortMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_PortMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HostIp) > 0 {
		i -= len(m.HostIp)
		copy(dAtA[i:], m.HostIp)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.HostIp)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x1a
	}
	if m.HostPort != 0 {
		i = encodeVarintContainer(dAtA, i, uint64(m.HostPort))
		i--
		dAtA[i] = 0x10
	}
	if m.ContainerPort != 0 {
		i = encodeVarintContainer(dAtA, i, uint64(m.ContainerPort))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CNICapArgs_Bandwidth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNICapArgs_Bandwidth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_Bandwidth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EgressBurst != 0 {
		i = encodeVarintContainer(dAtA, i, uint64(m.EgressBurst))
		i--
		dAtA[i] = 0x20
	}
	if m.EgressRate != 0 {
		i = encodeVarintContainer(dAtA, i, uint64(m.EgressRate))
		i--
		dAtA[i] = 0x18
	}
	if m.IngressBurst != 0 {
		i = encodeVarintContainer(dAtA, i, uint64(m.IngressBurst))
		i--
		dAtA[i] = 0x10
	}
	if m.IngressRate != 0 {
		i = encodeVarintContainer(dAtA, i, uint64(m.IngressRate))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CNICapArgs_IPRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNICapArgs_IPRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_IPRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Gateway) > 0 {
		i -= len(m.Gateway)
		copy(dAtA[i:], m.Gateway)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Gateway)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RangeEnd) > 0 {
		i -= len(m.RangeEnd)
		copy(dAtA[i:], m.RangeEnd)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.RangeEnd)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RangeStart) > 0 {
		i -= len(m.RangeStart)
		copy(dAtA[i:], m.RangeStart)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.RangeStart)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Subnet) > 0 {
		i -= len(m.Subnet)
		copy(dAtA[i:], m.Subnet)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Subnet)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CNICapArgs_DNSConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNICapArgs_DNSConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_DNSConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Options[iNdEx])
			copy(dAtA[i:], m.Options[iNdEx])
			i = encodeVarintContainer(dAtA, i, uint64(len(m.Options[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Searches) > 0 {
		for iNdEx := len(m.Searches) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Searches[iNdEx])
			copy(dAtA[i:], m.Searches[iNdEx])
			i = encodeVarintContainer(dAtA, i, uint64(len(m.Searches[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Servers) > 0 {
		for iNdEx := len(m.Servers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Servers[iNdEx])
			copy(dAtA[i:], m.Servers[iNdEx])
			i = encodeVarintContainer(dAtA, i, uint64(len(m.Servers[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CNICapArgs_IPAddresses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNICapArgs_IPAddresses) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_IPAddresses) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ips) > 0 {
		for iNdEx := len(m.Ips) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ips[iNdEx])
			copy(dAtA[i:], m.Ips[iNdEx])
			i = encodeVarintContainer(dAtA, i, uint64(len(m.Ips[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CNICapArgs_MacAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNICapArgs_MacAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_MacAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Mac) > 0 {
		i -= len(m.Mac)
		copy(dAtA[i:], m.Mac)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Mac)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CNICapArgs_InfinibandGUID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNICapArgs_InfinibandGUID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_InfinibandGUID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InfinibandGuid) > 0 {
		i -= len(m.InfinibandGuid)
		copy(dAtA[i:], m.InfinibandGuid)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.InfinibandGuid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CNICapArgs_DeviceID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNICapArgs_DeviceID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_DeviceID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerNetworkEnsureRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerNetworkEnsureRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerNetworkEnsureRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CniArgs) > 0 {
		for k := range m.CniArgs {
			v := m.CniArgs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintContainer(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintContainer(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintContainer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CapArgs) > 0 {
		for iNdEx := len(m.CapArgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CapArgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContainer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Pid != 0 {
		i = encodeVarintContainer(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ContainerId) > 0 {
		i -= len(m.ContainerId)
		copy(dAtA[i:], m.ContainerId)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.ContainerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerNetworkRestoreRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerNetworkRestoreRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerNetworkRestoreRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pid != 0 {
		i = encodeVarintContainer(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ContainerId) > 0 {
		i -= len(m.ContainerId)
		copy(dAtA[i:], m.ContainerId)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.ContainerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerNetworkDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerNetworkDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerNetworkDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pid != 0 {
		i = encodeVarintContainer(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ContainerId) > 0 {
		i -= len(m.ContainerId)
		copy(dAtA[i:], m.ContainerId)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.ContainerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerNetworkConfigEnsureRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerNetworkConfigEnsureRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerNetworkConfigEnsureRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ipv6Subnet) > 0 {
		i -= len(m.Ipv6Subnet)
		copy(dAtA[i:], m.Ipv6Subnet)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Ipv6Subnet)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ipv4Subnet) > 0 {
		i -= len(m.Ipv4Subnet)
		copy(dAtA[i:], m.Ipv4Subnet)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Ipv4Subnet)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerNetworkConfigQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerNetworkConfigQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerNetworkConfigQueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ContainerNetworkQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerNetworkQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerNetworkQueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pid != 0 {
		i = encodeVarintContainer(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ContainerId) > 0 {
		i -= len(m.ContainerId)
		copy(dAtA[i:], m.ContainerId)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.ContainerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerNetworkConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerNetworkConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerNetworkConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ipv6Subnet) > 0 {
		i -= len(m.Ipv6Subnet)
		copy(dAtA[i:], m.Ipv6Subnet)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Ipv6Subnet)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ipv4Subnet) > 0 {
		i -= len(m.Ipv4Subnet)
		copy(dAtA[i:], m.Ipv4Subnet)
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Ipv4Subnet)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerNetworkStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerNetworkStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerNetworkStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for iNdEx := len(m.Interfaces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Interfaces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContainer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Pid != 0 {
		i = encodeVarintContainer(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContainerNetworkStatusListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerNetworkStatusListResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerNetworkStatusListResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContainerNetworks) > 0 {
		for k := range m.ContainerNetworks {
			v := m.ContainerNetworks[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintContainer(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintContainer(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintContainer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintContainer(dAtA []byte, offset int, v uint64) int {
	offset -= sovContainer(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CNICapArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Option != nil {
		n += m.Option.Size()
	}
	return n
}

func (m *CNICapArgs_PortMapArg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortMapArg != nil {
		l = m.PortMapArg.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}
func (m *CNICapArgs_BandwidthArg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BandwidthArg != nil {
		l = m.BandwidthArg.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}
func (m *CNICapArgs_IpRangeArg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpRangeArg != nil {
		l = m.IpRangeArg.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}
func (m *CNICapArgs_DnsConfigArg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DnsConfigArg != nil {
		l = m.DnsConfigArg.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}
func (m *CNICapArgs_IpAddressesArg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpAddressesArg != nil {
		l = m.IpAddressesArg.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}
func (m *CNICapArgs_MacAddressArg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MacAddressArg != nil {
		l = m.MacAddressArg.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}
func (m *CNICapArgs_InfinibandGuidArg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InfinibandGuidArg != nil {
		l = m.InfinibandGuidArg.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}
func (m *CNICapArgs_DeviceIdArg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeviceIdArg != nil {
		l = m.DeviceIdArg.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}
func (m *CNICapArgs_PortMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContainerPort != 0 {
		n += 1 + sovContainer(uint64(m.ContainerPort))
	}
	if m.HostPort != 0 {
		n += 1 + sovContainer(uint64(m.HostPort))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.HostIp)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}

func (m *CNICapArgs_Bandwidth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IngressRate != 0 {
		n += 1 + sovContainer(uint64(m.IngressRate))
	}
	if m.IngressBurst != 0 {
		n += 1 + sovContainer(uint64(m.IngressBurst))
	}
	if m.EgressRate != 0 {
		n += 1 + sovContainer(uint64(m.EgressRate))
	}
	if m.EgressBurst != 0 {
		n += 1 + sovContainer(uint64(m.EgressBurst))
	}
	return n
}

func (m *CNICapArgs_IPRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Subnet)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.RangeStart)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.RangeEnd)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.Gateway)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}

func (m *CNICapArgs_DNSConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Servers) > 0 {
		for _, s := range m.Servers {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.Searches) > 0 {
		for _, s := range m.Searches {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.Options) > 0 {
		for _, s := range m.Options {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	return n
}

func (m *CNICapArgs_IPAddresses) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ips) > 0 {
		for _, s := range m.Ips {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	return n
}

func (m *CNICapArgs_MacAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}

func (m *CNICapArgs_InfinibandGUID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InfinibandGuid)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}

func (m *CNICapArgs_DeviceID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}

func (m *ContainerNetworkEnsureRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.Pid != 0 {
		n += 1 + sovContainer(uint64(m.Pid))
	}
	if len(m.CapArgs) > 0 {
		for _, e := range m.CapArgs {
			l = e.Size()
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.CniArgs) > 0 {
		for k, v := range m.CniArgs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovContainer(uint64(len(k))) + 1 + len(v) + sovContainer(uint64(len(v)))
			n += mapEntrySize + 1 + sovContainer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ContainerNetworkRestoreRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.Pid != 0 {
		n += 1 + sovContainer(uint64(m.Pid))
	}
	return n
}

func (m *ContainerNetworkDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.Pid != 0 {
		n += 1 + sovContainer(uint64(m.Pid))
	}
	return n
}

func (m *ContainerNetworkConfigEnsureRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ipv4Subnet)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.Ipv6Subnet)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}

func (m *ContainerNetworkConfigQueryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ContainerNetworkQueryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.Pid != 0 {
		n += 1 + sovContainer(uint64(m.Pid))
	}
	return n
}

func (m *ContainerNetworkConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ipv4Subnet)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.Ipv6Subnet)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}

func (m *ContainerNetworkStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pid != 0 {
		n += 1 + sovContainer(uint64(m.Pid))
	}
	if len(m.Interfaces) > 0 {
		for _, e := range m.Interfaces {
			l = e.Size()
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	return n
}

func (m *ContainerNetworkStatusListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ContainerNetworks) > 0 {
		for k, v := range m.ContainerNetworks {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovContainer(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovContainer(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovContainer(uint64(mapEntrySize))
		}
	}
	return n
}

func sovContainer(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozContainer(x uint64) (n int) {
	return sovContainer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CNICapArgs) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs{`,
		`Option:` + fmt.Sprintf("%v", this.Option) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_PortMapArg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_PortMapArg{`,
		`PortMapArg:` + strings.Replace(fmt.Sprintf("%v", this.PortMapArg), "CNICapArgs_PortMap", "CNICapArgs_PortMap", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_BandwidthArg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_BandwidthArg{`,
		`BandwidthArg:` + strings.Replace(fmt.Sprintf("%v", this.BandwidthArg), "CNICapArgs_Bandwidth", "CNICapArgs_Bandwidth", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_IpRangeArg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_IpRangeArg{`,
		`IpRangeArg:` + strings.Replace(fmt.Sprintf("%v", this.IpRangeArg), "CNICapArgs_IPRange", "CNICapArgs_IPRange", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_DnsConfigArg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_DnsConfigArg{`,
		`DnsConfigArg:` + strings.Replace(fmt.Sprintf("%v", this.DnsConfigArg), "CNICapArgs_DNSConfig", "CNICapArgs_DNSConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_IpAddressesArg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_IpAddressesArg{`,
		`IpAddressesArg:` + strings.Replace(fmt.Sprintf("%v", this.IpAddressesArg), "CNICapArgs_IPAddresses", "CNICapArgs_IPAddresses", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_MacAddressArg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_MacAddressArg{`,
		`MacAddressArg:` + strings.Replace(fmt.Sprintf("%v", this.MacAddressArg), "CNICapArgs_MacAddress", "CNICapArgs_MacAddress", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_InfinibandGuidArg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_InfinibandGuidArg{`,
		`InfinibandGuidArg:` + strings.Replace(fmt.Sprintf("%v", this.InfinibandGuidArg), "CNICapArgs_InfinibandGUID", "CNICapArgs_InfinibandGUID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_DeviceIdArg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_DeviceIdArg{`,
		`DeviceIdArg:` + strings.Replace(fmt.Sprintf("%v", this.DeviceIdArg), "CNICapArgs_DeviceID", "CNICapArgs_DeviceID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_PortMap) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_PortMap{`,
		`ContainerPort:` + fmt.Sprintf("%v", this.ContainerPort) + `,`,
		`HostPort:` + fmt.Sprintf("%v", this.HostPort) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`HostIp:` + fmt.Sprintf("%v", this.HostIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_Bandwidth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_Bandwidth{`,
		`IngressRate:` + fmt.Sprintf("%v", this.IngressRate) + `,`,
		`IngressBurst:` + fmt.Sprintf("%v", this.IngressBurst) + `,`,
		`EgressRate:` + fmt.Sprintf("%v", this.EgressRate) + `,`,
		`EgressBurst:` + fmt.Sprintf("%v", this.EgressBurst) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_IPRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_IPRange{`,
		`Subnet:` + fmt.Sprintf("%v", this.Subnet) + `,`,
		`RangeStart:` + fmt.Sprintf("%v", this.RangeStart) + `,`,
		`RangeEnd:` + fmt.Sprintf("%v", this.RangeEnd) + `,`,
		`Gateway:` + fmt.Sprintf("%v", this.Gateway) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_DNSConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_DNSConfig{`,
		`Servers:` + fmt.Sprintf("%v", this.Servers) + `,`,
		`Searches:` + fmt.Sprintf("%v", this.Searches) + `,`,
		`Options:` + fmt.Sprintf("%v", this.Options) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_IPAddresses) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_IPAddresses{`,
		`Ips:` + fmt.Sprintf("%v", this.Ips) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_MacAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_MacAddress{`,
		`Mac:` + fmt.Sprintf("%v", this.Mac) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_InfinibandGUID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_InfinibandGUID{`,
		`InfinibandGuid:` + fmt.Sprintf("%v", this.InfinibandGuid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_DeviceID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_DeviceID{`,
		`DeviceId:` + fmt.Sprintf("%v", this.DeviceId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerNetworkEnsureRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCapArgs := "[]*CNICapArgs{"
	for _, f := range this.CapArgs {
		repeatedStringForCapArgs += strings.Replace(f.String(), "CNICapArgs", "CNICapArgs", 1) + ","
	}
	repeatedStringForCapArgs += "}"
	keysForCniArgs := make([]string, 0, len(this.CniArgs))
	for k, _ := range this.CniArgs {
		keysForCniArgs = append(keysForCniArgs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForCniArgs)
	mapStringForCniArgs := "map[string]string{"
	for _, k := range keysForCniArgs {
		mapStringForCniArgs += fmt.Sprintf("%v: %v,", k, this.CniArgs[k])
	}
	mapStringForCniArgs += "}"
	s := strings.Join([]string{`&ContainerNetworkEnsureRequest{`,
		`ContainerId:` + fmt.Sprintf("%v", this.ContainerId) + `,`,
		`Pid:` + fmt.Sprintf("%v", this.Pid) + `,`,
		`CapArgs:` + repeatedStringForCapArgs + `,`,
		`CniArgs:` + mapStringForCniArgs + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerNetworkRestoreRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerNetworkRestoreRequest{`,
		`ContainerId:` + fmt.Sprintf("%v", this.ContainerId) + `,`,
		`Pid:` + fmt.Sprintf("%v", this.Pid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerNetworkDeleteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerNetworkDeleteRequest{`,
		`ContainerId:` + fmt.Sprintf("%v", this.ContainerId) + `,`,
		`Pid:` + fmt.Sprintf("%v", this.Pid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerNetworkConfigEnsureRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerNetworkConfigEnsureRequest{`,
		`Ipv4Subnet:` + fmt.Sprintf("%v", this.Ipv4Subnet) + `,`,
		`Ipv6Subnet:` + fmt.Sprintf("%v", this.Ipv6Subnet) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerNetworkConfigQueryRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerNetworkConfigQueryRequest{`,
		`}`,
	}, "")
	return s
}
func (this *ContainerNetworkQueryRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerNetworkQueryRequest{`,
		`ContainerId:` + fmt.Sprintf("%v", this.ContainerId) + `,`,
		`Pid:` + fmt.Sprintf("%v", this.Pid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerNetworkConfigResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerNetworkConfigResponse{`,
		`Ipv4Subnet:` + fmt.Sprintf("%v", this.Ipv4Subnet) + `,`,
		`Ipv6Subnet:` + fmt.Sprintf("%v", this.Ipv6Subnet) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerNetworkStatusResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInterfaces := "[]*NetworkInterface{"
	for _, f := range this.Interfaces {
		repeatedStringForInterfaces += strings.Replace(fmt.Sprintf("%v", f), "NetworkInterface", "NetworkInterface", 1) + ","
	}
	repeatedStringForInterfaces += "}"
	s := strings.Join([]string{`&ContainerNetworkStatusResponse{`,
		`Pid:` + fmt.Sprintf("%v", this.Pid) + `,`,
		`Interfaces:` + repeatedStringForInterfaces + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerNetworkStatusListResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForContainerNetworks := make([]string, 0, len(this.ContainerNetworks))
	for k, _ := range this.ContainerNetworks {
		keysForContainerNetworks = append(keysForContainerNetworks, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForContainerNetworks)
	mapStringForContainerNetworks := "map[string]*ContainerNetworkStatusResponse{"
	for _, k := range keysForContainerNetworks {
		mapStringForContainerNetworks += fmt.Sprintf("%v: %v,", k, this.ContainerNetworks[k])
	}
	mapStringForContainerNetworks += "}"
	s := strings.Join([]string{`&ContainerNetworkStatusListResponse{`,
		`ContainerNetworks:` + mapStringForContainerNetworks + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringContainer(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *CNICapArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNICapArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNICapArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMapArg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CNICapArgs_PortMap{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &CNICapArgs_PortMapArg{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BandwidthArg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CNICapArgs_Bandwidth{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &CNICapArgs_BandwidthArg{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpRangeArg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CNICapArgs_IPRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &CNICapArgs_IpRangeArg{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsConfigArg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CNICapArgs_DNSConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &CNICapArgs_DnsConfigArg{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddressesArg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CNICapArgs_IPAddresses{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &CNICapArgs_IpAddressesArg{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddressArg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CNICapArgs_MacAddress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &CNICapArgs_MacAddressArg{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfinibandGuidArg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CNICapArgs_InfinibandGUID{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &CNICapArgs_InfinibandGuidArg{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceIdArg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CNICapArgs_DeviceID{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &CNICapArgs_DeviceIdArg{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNICapArgs_PortMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPort", wireType)
			}
			m.ContainerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			m.HostPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNICapArgs_Bandwidth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bandwidth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bandwidth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressRate", wireType)
			}
			m.IngressRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngressRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressBurst", wireType)
			}
			m.IngressBurst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngressBurst |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressRate", wireType)
			}
			m.EgressRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EgressRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressBurst", wireType)
			}
			m.EgressBurst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EgressBurst |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNICapArgs_IPRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeStart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeStart = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEnd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeEnd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNICapArgs_DNSConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Servers = append(m.Servers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Searches", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Searches = append(m.Searches, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNICapArgs_IPAddresses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAddresses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAddresses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ips", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ips = append(m.Ips, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNICapArgs_MacAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MacAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MacAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNICapArgs_InfinibandGUID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfinibandGUID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfinibandGUID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfinibandGuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InfinibandGuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNICapArgs_DeviceID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerNetworkEnsureRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerNetworkEnsureRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerNetworkEnsureRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapArgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapArgs = append(m.CapArgs, &CNICapArgs{})
			if err := m.CapArgs[len(m.CapArgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CniArgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CniArgs == nil {
				m.CniArgs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowContainer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContainer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthContainer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthContainer
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContainer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthContainer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthContainer
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipContainer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthContainer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CniArgs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerNetworkRestoreRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerNetworkRestoreRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerNetworkRestoreRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerNetworkDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerNetworkDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerNetworkDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerNetworkConfigEnsureRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerNetworkConfigEnsureRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerNetworkConfigEnsureRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Subnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4Subnet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Subnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6Subnet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerNetworkConfigQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerNetworkConfigQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerNetworkConfigQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerNetworkQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerNetworkQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerNetworkQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerNetworkConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerNetworkConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerNetworkConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Subnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4Subnet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Subnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6Subnet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerNetworkStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerNetworkStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerNetworkStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, &NetworkInterface{})
			if err := m.Interfaces[len(m.Interfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerNetworkStatusListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerNetworkStatusListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerNetworkStatusListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerNetworks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContainer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerNetworks == nil {
				m.ContainerNetworks = make(map[string]*ContainerNetworkStatusResponse)
			}
			var mapkey string
			var mapvalue *ContainerNetworkStatusResponse
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowContainer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContainer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthContainer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthContainer
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContainer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthContainer
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthContainer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ContainerNetworkStatusResponse{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipContainer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthContainer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ContainerNetworks[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipContainer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthContainer
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupContainer
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthContainer
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthContainer        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowContainer          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupContainer = fmt.Errorf("proto: unexpected end of group")
)
